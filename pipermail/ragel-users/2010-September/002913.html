<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [ragel-users] parser getting gigantic ?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:ragel-users%40colm.net?Subject=Re%3A%20%5Bragel-users%5D%20parser%20getting%20gigantic%20%3F&In-Reply-To=%3CAANLkTin3%2BrrwwKt-i4vXChzg1ELmn7sB8gespN-DPHHx%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   
   <LINK REL="Next"  HREF="002914.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[ragel-users] parser getting gigantic ?</H1>
    <B>M P</B> 
    <A HREF="mailto:ragel-users%40colm.net?Subject=Re%3A%20%5Bragel-users%5D%20parser%20getting%20gigantic%20%3F&In-Reply-To=%3CAANLkTin3%2BrrwwKt-i4vXChzg1ELmn7sB8gespN-DPHHx%40mail.gmail.com%3E"
       TITLE="[ragel-users] parser getting gigantic ?">buserror at gmail.com
       </A><BR>
    <I>Thu Sep  2 14:41:36 UTC 2010</I>
    <P><UL>
        
        <LI>Next message: <A HREF="002914.html">[ragel-users] parser getting gigantic ?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2913">[ date ]</a>
              <a href="thread.html#2913">[ thread ]</a>
              <a href="subject.html#2913">[ subject ]</a>
              <a href="author.html#2913">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I decided to play with Ragel by making a parser for an extended
version of JSON.

After falling into every single pitfall possible, I managed to get the
whole thing working pretty well, but I just had a look at the
generated code and it reached 600KB total, using -G1 (!)

So, what am I doing wrong ? I'm certain there's probably a lot of
stuff wrong with the way I made the parser, but really, I'm not sure
what so having experts eyeballing this would be very nice...

There are 2 different json parsers in the file; one is for the string
constants, one (the main one) is for the language proper...


/*
 * IF YOU ARE LOOKING AT A .c FILE, YOUR ARE LOOKING AT THE WRONG ONE
 *
 * This file is autogenerated from a .rl source file for 'ragel'
parser generator.
 */
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

#include &quot;json.h&quot;

%%{
	machine json_str;
	write data;
}%%

static char * json_append_utf8_glyph(
	char * dst,
	unsigned long inUnicode )
{
	if (!(inUnicode &amp; ~0x7f)) {
		*dst++ = ((char)inUnicode);
		return dst;	// that was easy
	}
	unsigned char *cur = dst;

	unsigned long currentMask = ~0x7ff;
	int bits = 6;
	int header = 5;

	while ((inUnicode &amp; currentMask) &amp;&amp; bits &lt;= 24) {
		currentMask = currentMask &lt;&lt; 6;
		bits += 6; header--;
	}
	*cur++ = (0xfe &lt;&lt; header) | (unsigned char)(inUnicode &gt;&gt; (bits));
	bits -= 6;
	while (bits &gt;= 0) {
		*cur++ = 0x80 | ((unsigned char)(inUnicode &gt;&gt; bits) &amp; 0x3f);
		bits -= 6;
	}
	return cur;
}

int json_parse_string(char * str, char *end, char * out)
{
	char *p = str, *pe = end ? end : str + strlen( str ), *eof = pe;
	int cs;
	out = out ? out : str;
	uint16_t u;
	%%{
		machine json_str;

		xxdigit = (
			([0-9] @{ u = (u &lt;&lt; 4) | fc - '0'; }) |
			([a-f] @{ u = (u &lt;&lt; 4) | fc - 'a' + 0xa; }) |
			([A-F] @{ u = (u &lt;&lt; 4) | fc - 'A' + 0xa; })			
		);
		utf16 = ( xxdigit{4} ) &gt;{ u = 0; } @{ out = json_append_utf8_glyph(out, u); };
		
		normal = any @{*out++ = fc;};
		escape =
				('\\' %{ *out++ = '\\'; } ) |
				('t' %{ *out++ = '\t'; } )  |
				('b' %{ *out++ = '\b'; } )  |
				('f' %{ *out++ = '\f'; } )  |
				('n' %{ *out++ = '\n'; } )  |
				('r' %{ *out++ = '\r'; } )  |
				('u' utf16 ) |
				( normal -- [\\tbfntu] )
			;
		main := (
			('\\' escape) |
			( normal -- '\\' )
		)*;
		
		# Initialize and execute.
		write init;
		write exec;
	}%%
	*out = 0;
	
	return 0;
}

%%{
	machine json;
	write data;
}%%

int json_parse( json_driver_t *d, char * str )
{
	char *p = str, *pe = str + strlen( str ), *eof = pe;
	int cs;
	int stack[32], top = 0;
	int integer_sign;	// for integer decode
	char * float_start;
	json_driver_value_t v;
	uint32_t b64;
	int b64_cnt;
	
	%%{
		machine json;
		action obj_field_list_start { d-&gt;open_object(d); }
		action obj_field_list_done { d-&gt;close_object(d); }
		action obj_value_list_start { d-&gt;open_array(d); }
		action obj_value_list_done { d-&gt;close_array(d); }
		action obj_create_name { d-&gt;set_name(d, &amp;v); }
		action obj_set_flag { if (d-&gt;add_flag) d-&gt;add_flag(d, &amp;v); }
		action obj_set_string { d-&gt;set_value(d, json_driver_type_string, &amp;v); }
		action obj_set_integer { d-&gt;set_value(d, json_driver_type_integer, &amp;v); }
		action obj_set_float { d-&gt;set_value(d, json_driver_type_float, &amp;v); }
		action obj_set_hex { d-&gt;set_value(d, json_driver_type_hex, &amp;v); }
		action obj_set_true { v.u.v_bool = 1; d-&gt;set_value(d,
json_driver_type_bool, &amp;v); }
		action obj_set_false { v.u.v_bool = 0; d-&gt;set_value(d,
json_driver_type_bool, &amp;v); }
		action obj_set_null { d-&gt;set_value(d, json_driver_type_null, NULL); }
		
		action obj_start_data { if (d-&gt;open_data) d-&gt;open_data(d); }
		action obj_flush_data { if (d-&gt;add_data) for (int s=16,i = 0;
i&lt;b64_cnt; i++,s-=8) d-&gt;add_data(d, (b64 &gt;&gt; s) &amp; 0xff); }
		action obj_end_data { if (d-&gt;close_data) d-&gt;close_data(d); }
		
		W = [ \t\n]**;

		#
		# quoted or unquoted string
		#
		action str_init { v.u.v_str.start = v.u.v_str.end = fpc; }
		action str_done { v.u.v_str.end = fpc; }
			
		string = '&quot;' ((([^&quot;] | '\&quot;')*) &gt;str_init %str_done)  '&quot;';
		ident = ((alpha | '_') (alnum | '_')*) &gt;str_init %str_done;
		
		#
		#	negative/positive Integer
		#
		action integer_init { v.u.v_int = 0; integer_sign = 1; }
		action integer_minus { integer_sign = -1; }
		action integer_digit { v.u.v_int = (v.u.v_int * 10) + (fc - '0'); }
		action integer_done {  v.u.v_int *= integer_sign; }
		
		integer = (('-' @integer_minus | '+')? (digit+ @integer_digit))
			&gt;integer_init %integer_done;
		
		#
		# hex integer
		#
		xxdigit = (
			([0-9] @{ v.u.v_int = (v.u.v_int &lt;&lt; 4) | fc - '0'; }) |
			([a-f] @{ v.u.v_int = (v.u.v_int &lt;&lt; 4) | fc - 'a' + 0xa; }) |
			([A-F] @{ v.u.v_int = (v.u.v_int &lt;&lt; 4) | fc - 'A' + 0xa; })			
		);
		hex = (('-' @integer_minus | '+')?( '0x' xxdigit+))
			&gt;integer_init %integer_done;
		
		#
		# float/double value
		#
		action float_init { float_start = fpc; }
		action float_done { sscanf(float_start, &quot;%lf&quot;, &amp;v.u.v_float); }
		#
		# float values
		#
		float = (
			('-' | '+')? digit* '.' digit+ [fd]?
		) &gt;float_init %float_done;

		#
		# base64 decoder
		#
		base64_char = (
			([A-Z] @{ b64 = (b64 &lt;&lt; 6) | (fc - 'A'); }) |
			([a-z] @{ b64 = (b64 &lt;&lt; 6) | (fc - 'a' + 26 ); }) |
			([0-9] @{ b64 = (b64 &lt;&lt; 6) | (fc - '0' + 52 ); }) |
			('+' @{ b64 = (b64 &lt;&lt; 6) | 62; }) |
			('/' @{ b64 = (b64 &lt;&lt; 6) | 63; })
		);
		base64_pad = '=' @{ b64 = (b64 &lt;&lt; 6); };
		base64_four = (
			base64_char base64_char base64_char base64_char
		) %{ b64_cnt = 3; } %obj_flush_data;
		base64_padder = (
			base64_char base64_char
			(
				(( base64_char base64_pad )
					%{ b64_cnt = 2; } ) |
				(( base64_pad base64_pad )
					%{ b64_cnt = 1; } )
			)
		) %obj_flush_data;

		base64 = ( base64_four** (base64_four | base64_padder) ) &gt;{b64 = 0;}
				%err{ printf(&quot;### base64 Error : '%s'\n&quot;, p); };

		#
		# JSON value, extended
		#
		json_value = (
			(string %obj_set_string) |
			(integer %obj_set_integer) |
			(hex %obj_set_hex ) |
			(float %obj_set_float) |
			('true' %obj_set_true) |
			('false' %obj_set_false) |
			('null' %obj_set_null) |
			('{' @{ fhold; fcall obj_field_list; } ) |
			('[' @{ fhold; fcall json_value_list; } ) |
			(('%' (W base64)* W '%') &gt;obj_start_data %obj_end_data)
		);
		
		json_value_list := (
			'[' (
				'' |
				(W json_value (W ',' W json_value)* )
			) W ','? W ']'
		) &gt;obj_value_list_start @obj_value_list_done @{ fret; }
				%err{ printf(&quot;### Array[%d] Error : '%s'\n&quot;, top, p); };
		
		obj_field_flag = ( ident ) %obj_set_flag;
		obj_field_flags = (
			'(' W obj_field_flag (W ',' W obj_field_flag)** ')'
		);
		obj_field = ((string | ident) %obj_create_name) W obj_field_flags? W
':' W json_value;
		
		obj_field_list := (
			'{' (
				'' |
				(W obj_field (W ',' W obj_field)** )
			) W ','? W '}'
		) &gt;obj_field_list_start @obj_field_list_done @{ fret; }
				%err{ printf(&quot;### Object[%d] Error : '%s'\n&quot;, top, p); };
		
		main := (
			W json_value
		) %err{ printf(&quot;### JSON Error : '%s'\n&quot;, p); };

		# Initialize and execute.
		write init;
		write exec;
	}%%

	return 0;
};

#ifdef JSON_TEST_UNIT
static void d_set_name(struct json_driver_t *d,
		json_driver_value_t * v)
{
	int l = v-&gt;u.v_str.end - v-&gt;u.v_str.start;
	printf(&quot;\&quot;%*.*s\&quot;: &quot;, l, l, v-&gt;u.v_str.start);
}

static void d_open_array(struct json_driver_t *d)
{
	printf(&quot;[&quot;);fflush(stdout);
}

static void d_open_object(struct json_driver_t *d)
{
	printf(&quot;{&quot;);fflush(stdout);
}

static void d_set_value(struct json_driver_t *d,
		int type,
		json_driver_value_t * v)
{
	switch (type) {
		case json_driver_type_null:
			printf(&quot;null, &quot;);
			break;
		case json_driver_type_bool:
			printf(&quot;%s, &quot;, v-&gt;u.v_bool ? &quot;true&quot; : &quot;false&quot;);
			break;
		case json_driver_type_integer:
			printf(&quot;%d, &quot;, (int)v-&gt;u.v_int);
			break;
		case json_driver_type_hex:
			printf(&quot;0x%x, &quot;, (int)v-&gt;u.v_int);
			break;
		case json_driver_type_float:
			printf(&quot;%f, &quot;, (float)v-&gt;u.v_float);
			break;
		case json_driver_type_string: {
			char buf[256];
			json_parse_string(v-&gt;u.v_str.start, v-&gt;u.v_str.end, buf);
			printf(&quot;\&quot;%s\&quot;: &quot;, buf);
		}	break;
	}
	fflush(stdout);
}

static void d_close_array(struct json_driver_t *d)
{
	printf(&quot;],&quot;);fflush(stdout);
}

static void d_close_object(struct json_driver_t *d)
{
	printf(&quot;},&quot;);fflush(stdout);
}

static void d_open_data(struct json_driver_t *d)
{
	printf(&quot;%% '&quot;);fflush(stdout);	
}
static void d_add_data(struct json_driver_t *d, uint8_t data)
{
	printf(&quot;%c&quot;,data);fflush(stdout);
}
static void d_close_data(struct json_driver_t *d)
{
	printf(&quot;' %%,&quot;);fflush(stdout);
}

json_driver_t driver = {
	.set_name = d_set_name,
	.open_array = d_open_array,
	.open_object = d_open_object,
	.set_value = d_set_value,
	.close_array = d_close_array,
	.close_object = d_close_object,
	
	.open_data = d_open_data,
	.add_data = d_add_data,
	.close_data = d_close_data,
};

int main(int argc, char * argv[])
{

	for (int i = 1; i &lt; argc; i++) {
		printf(&quot;### parsing '%s'\n&quot;, argv[i]);
		json_parse(&amp;driver, argv[i]);printf(&quot;\n&quot;);
	}
	return 0;
}

#endif

_______________________________________________
ragel-users mailing list
<A HREF="http://www.colm.net/cgi-bin/mailman/listinfo/ragel-users">ragel-users at complang.org</A>
<A HREF="http://www.complang.org/mailman/listinfo/ragel-users">http://www.complang.org/mailman/listinfo/ragel-users</A>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="002914.html">[ragel-users] parser getting gigantic ?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2913">[ date ]</a>
              <a href="thread.html#2913">[ thread ]</a>
              <a href="subject.html#2913">[ subject ]</a>
              <a href="author.html#2913">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.colm.net/cgi-bin/mailman/listinfo/ragel-users">More information about the ragel-users
mailing list</a><br>
</body></html>
