From icib... at gmail.com  Fri Feb  2 22:07:05 2007
From: icib... at gmail.com (Ivan Cibiri)
Date: Fri, 02 Feb 2007 14:07:05 -0800
Subject: rlcodegen: parse error
Message-ID: <1170454025.547257.93190@a75g2000cwd.googlegroups.com>

I uploaded file Sample.rl
When I run following commands, I get error:

ragel -D -o Sample.xml Sample.rl
rlcodegen -o Sample.d Sample.xm
Sample.xml:145:30: parse error

Any idea what is going wrong?

Ivan


From thurs... at cs.queensu.ca  Fri Feb  2 23:41:54 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Fri, 02 Feb 2007 18:41:54 -0500
Subject: [ragel-users] rlcodegen: parse error
In-Reply-To: <1170454025.547257.93190@a75g2000cwd.googlegroups.com>
References: <1170454025.547257.93190@a75g2000cwd.googlegroups.com>
Message-ID: <45C3CC42.90703@cs.queensu.ca>

Hi Ivan,

Sample.rl fails for me at the frontend because it contains CR characters and
I am on linux. The new parser is not treating them as whitespace as it
should. So I fixed this, but then the XML file that is generated works okay
for me. I'm not sure if my fix to the frontend will fix your problem in the
backend though. Could you post the XML file that gives you trouble?

Regards,
 Adrian

Ivan Cibiri wrote:
> I uploaded file Sample.rl
> When I run following commands, I get error:
> 
> ragel -D -o Sample.xml Sample.rl
> rlcodegen -o Sample.d Sample.xm
> Sample.xml:145:30: parse error
> 
> Any idea what is going wrong?
> 
> Ivan
> 
> 
> 


From icib... at gmail.com  Sat Feb  3 06:27:13 2007
From: icib... at gmail.com (Ivan Cibiri)
Date: Sat, 03 Feb 2007 06:27:13 -0000
Subject: rlcodegen: parse error
In-Reply-To: <45C3CC42.90703@cs.queensu.ca>
References: <1170454025.547257.93190@a75g2000cwd.googlegroups.com>
   <45C3CC42.90703@cs.queensu.ca>
Message-ID: <1170484033.268822.319350@k78g2000cwa.googlegroups.com>

Hi Adrian,

sample.zip contains: Sample.rl Sample.xml and out.txt.

ragel -D -o Sample.xml Sample.rl

rlcodegen -o Sample.d Sample.xml
Sample.xml:139:2: parse error

Kind regards,
Ivan

> Could you post the XML file that gives you trouble?
>
> Regards,
>  Adrian
>


From thurs... at cs.queensu.ca  Sat Feb  3 16:49:06 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Sat, 03 Feb 2007 11:49:06 -0500
Subject: [ragel-users] Re: rlcodegen: parse error
In-Reply-To: <1170484033.268822.319350@k78g2000cwa.googlegroups.com>
References: <1170454025.547257.93190@a75g2000cwd.googlegroups.com> <45C3CC42.90703@cs.queensu.ca> <1170484033.268822.319350@k78g2000cwa.googlegroups.com>
Message-ID: <45C4BD02.2030109@cs.queensu.ca>

Hi,

I'm not able to reproduce the error. Can you confirm for me that
both executables are version 5.17. Also, what kind of system are you on 
and how was was Ragel compiled?

Thanks
  Adrian

Ivan Cibiri wrote:
> Hi Adrian,
> 
> sample.zip contains: Sample.rl Sample.xml and out.txt.
> 
> ragel -D -o Sample.xml Sample.rl
> 
> rlcodegen -o Sample.d Sample.xml
> Sample.xml:139:2: parse error
> 
> Kind regards,
> Ivan
> 
>> Could you post the XML file that gives you trouble?
>>
>> Regards,
>>  Adrian
>>
> 
> 
> 


From icib... at gmail.com  Sat Feb  3 17:54:14 2007
From: icib... at gmail.com (Ivan Cibiri)
Date: Sat, 3 Feb 2007 18:54:14 +0100
Subject: [ragel-users] Re: rlcodegen: parse error
In-Reply-To: <45C4BD02.2030109@cs.queensu.ca>
References: <1170454025.547257.93190@a75g2000cwd.googlegroups.com>
	 <45C3CC42.90703@cs.queensu.ca>
	 <1170484033.268822.319350@k78g2000cwa.googlegroups.com>
	 <45C4BD02.2030109@cs.queensu.ca>
Message-ID: <aed7ed7e0702030954m3c2c172dw59174d55802d2c3b@mail.gmail.com>

Hi,

Hi,

Both executables are from
http://www.cs.queensu.ca/~thurston/ragel/ragel-5.17-w32bin.zip , downloaded
2.2.2007.

I am running Windows XP Pro SP2 and all fixes.

Ivan.

On 2/3/07, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
>
>
> Hi,
>
> I'm not able to reproduce the error. Can you confirm for me that
> both executables are version 5.17. Also, what kind of system are you on
> and how was was Ragel compiled?
>
> Thanks
>   Adrian
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.colm.net/pipermail/ragel/attachments/20070203/fb41105d/attachment.html>

From icib... at gmail.com  Sat Feb  3 19:54:03 2007
From: icib... at gmail.com (Ivan Cibiri)
Date: Sat, 03 Feb 2007 19:54:03 -0000
Subject: rlcodegen: parse error
In-Reply-To: <aed7ed7e0702030954m3c2c172dw59174d55802d2c3b@mail.gmail.com>
References: <1170454025.547257.93190@a75g2000cwd.googlegroups.com>
   <45C3CC42.90703@cs.queensu.ca>
   <1170484033.268822.319350@k78g2000cwa.googlegroups.com>
   <45C4BD02.2030109@cs.queensu.ca>
   <aed7ed7e0702030954m3c2c172dw59174d55802d2c3b@mail.gmail.com>
Message-ID: <1170532443.134840.265070@l53g2000cwa.googlegroups.com>

Hi,

When I use binaries from http://www.cs.queensu.ca/~thurston/ragel/ragel-5.17-w32ntv.zip
, everything seems fine. There is no syntax error.

Ivan.

On Feb 3, 6:54 pm, "Ivan Cibiri" <icib... at gmail.com> wrote:
> Hi,
>
> Hi,
>
> Both executables are fromhttp://www.cs.queensu.ca/~thurston/ragel/ragel-5.17-w32bin.zip, downloaded
> 2.2.2007.
>
> I am running Windows XP Pro SP2 and all fixes.
>
> Ivan.
>
> On 2/3/07, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
>
>
>
> > Hi,
>
> > I'm not able to reproduce the error. Can you confirm for me that
> > both executables are version 5.17. Also, what kind of system are you on
> > and how was was Ragel compiled?
>
> > Thanks
> >   Adrian


From thurs... at cs.queensu.ca  Sun Feb  4 17:46:40 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Sun, 04 Feb 2007 12:46:40 -0500
Subject: [ragel-users] Re: rlcodegen: parse error
In-Reply-To: <1170532443.134840.265070@l53g2000cwa.googlegroups.com>
References: <1170454025.547257.93190@a75g2000cwd.googlegroups.com> <45C3CC42.90703@cs.queensu.ca> <1170484033.268822.319350@k78g2000cwa.googlegroups.com> <45C4BD02.2030109@cs.queensu.ca> <aed7ed7e0702030954m3c2c172dw59174d55802d2c3b@mail.gmail.com> <1170532443.134840.265070@l53g2000cwa.googlegroups.com>
Message-ID: <45C61C00.4070709@cs.queensu.ca>

Hi Ivan,

Thanks for your information. I was able to reproduce the problem, but 
not debug it since I am using a cross compiler (MinGW). A sprinkling of 
print statements didn't seem to give me any insight. For now I will take 
down the binaries produced by MinGW. This is not the first time I've had 
trouble getting working Win32 binaries using it.

So for now, Win32 options are:

1. Native binaries contributed by Josef Goettgens
2. Compiling on Windows using Cygwin.

Thanks,
  Adrian

Ivan Cibiri wrote:
> Hi,
> 
> When I use binaries from http://www.cs.queensu.ca/~thurston/ragel/ragel-5.17-w32ntv.zip
> , everything seems fine. There is no syntax error.
> 
> Ivan.
> 
> On Feb 3, 6:54 pm, "Ivan Cibiri" <icib... at gmail.com> wrote:
>> Hi,
>>
>> Hi,
>>
>> Both executables are fromhttp://www.cs.queensu.ca/~thurston/ragel/ragel-5.17-w32bin.zip, downloaded
>> 2.2.2007.
>>
>> I am running Windows XP Pro SP2 and all fixes.
>>
>> Ivan.
>>
>> On 2/3/07, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
>>
>>
>>
>>> Hi,
>>> I'm not able to reproduce the error. Can you confirm for me that
>>> both executables are version 5.17. Also, what kind of system are you on
>>> and how was was Ragel compiled?
>>> Thanks
>>>   Adrian
> 
> 
> 


From jason2... at jasonjobe.com  Mon Feb  5 17:51:18 2007
From: jason2... at jasonjobe.com (Jason)
Date: Mon, 05 Feb 2007 09:51:18 -0800
Subject: can't pull parse strings - BUG?
Message-ID: <1170697878.145251.186030@a75g2000cwd.googlegroups.com>

I've finally gotten a little time to start working with the new
pullscan example.

Everything was going well until I tried to add string tokens. The rl
(below) works as is but un-comment the String rules and all hell
breaks loose.

Any pointers would be most welcome.

---      TEST input file -------
[target go: 124 with:(1..9) num:1,298,99 int:87 float:1,299.987]

(list "some string")
(list 'some other string')

-------------- mod_pullscan.rl ------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BUFSIZE 4096

typedef struct _Scanner {
	/* Scanner state. */
    int cs;
    int act;
    int have;
    int curline;
    char *tokstart;
    char *tokend;
    char *p;
    char *pe;
	FILE *file;
	int done;

	/* Token data */
	char *data;
	int len;
    int value;
	char *token_name;
	char buf[BUFSIZE];
} Scanner;


void scan_init( Scanner *s, FILE *file )
{
	memset (s, '\0', sizeof(Scanner));
	s->curline = 1;
	s->file = file;
}

#define TK_NO_TOKEN (-1)
#define TK_ERR 128
#define TK_EOF 129
#define TK_Identifier 130
#define TK_Number 131
#define TK_Keyword 132
#define TK_String 133


%%{
	machine Scanner;
	write data;
}%%

#define ret_tok( _tok ) token = _tok; s->data = s->tokstart; s-
>token_name = #_tok
#define ret_char( _tok ) token = _tok; s->data = s->tokstart; s-
>token_name = "TK_Char"

int scan( Scanner *s )
{
	char *p = s->p;
	char *pe = s->pe;
	int token = TK_NO_TOKEN;
	int space, readlen;

	while ( 1 ) {
		if ( p == pe ) {
			printf("scanner: need more data\n");

			if ( s->tokstart == 0 )
				s->have = 0;
			else {
				/* There is data that needs to be shifted over. */
				printf("scanner: buffer broken mid token\n");
				s->have = pe - s->tokstart;
				memmove( s->buf, s->tokstart, s->have );
				s->tokend -= (s->tokstart-s->buf);
				s->tokstart = s->buf;
			}

			p = s->buf + s->have;
			space = BUFSIZE - s->have;

			if ( space == 0 ) {
				/* We filled up the buffer trying to scan a token. */
				printf("scanner: out of buffer space\n");
				return TK_ERR;
			}

			if ( s->done ) {
				printf("scanner: end of file\n");
				p[0] = 0;
				readlen = 1;
			}
			else {
				readlen = fread( p, 1, space, s->file );
				if ( readlen < space )
					s->done = 1;
			}

			pe = p + readlen;
		}

		%%{
			machine Scanner;
			access s->;

			newline = '\n' @{s->curline += 1;};
			any_count_line = any | newline;

			main := |*

			# Alpha numberic characters or underscore.
			alnum_u = alnum | '_';

			# Alpha charactres or underscore.
			alpha_u = alpha | '_';

			ident = alpha_u alnum_u*;

			# Identifiers
			ident =>
				{ ret_tok( TK_Identifier ); fbreak; };

			# Keywords
			ident ':' => {
				ret_tok (TK_Keyword); fbreak;
			};

	# Strings
#			"'" ( [^'\\] | /\\./ )* "'" => { ret_tok (TK_String); };
#			'"' ( [^"\\] | /\\./ )* '"' => { ret_tok (TK_String); };

			# Whitespace
			[ \t\n];

			# Number
			digit+ =>
				{ ret_tok( TK_Number ); fbreak; };

			# EOF
			0 =>
				{ ret_tok( TK_EOF ); fbreak; };

			# Anything else
			any =>
				{ ret_char( *p ); fbreak; };

			*|;

			write exec;
		}%%

		if ( s->cs == Scanner_error )
			return TK_ERR;

		if ( token != TK_NO_TOKEN ) {
			/* Save p and pe. fbreak does not advance p. */
			s->p = p + 1;
			s->pe = pe;
			s->len = s->p - s->data;
			return token;
		}
	}
}


int main (int argc, char** argv)
{
	Scanner ss;
	int tok;

	scan_init(&ss, stdin);

	while ( 1 ) {
		tok = scan (&ss);
		if ( tok == TK_EOF ) {
			printf ("parser: EOF\n");
			break;
		}
		else if ( tok == TK_ERR ) {
			printf ("parser: ERR\n");
			break;
		}
		else {
			printf ("parser: %s(%d) \"", ss.token_name, tok);
			fwrite ( ss.data, 1, ss.len, stdout );
			printf ("\"\n" );
		}
	}

	return 0;
}


From thurs... at cs.queensu.ca  Mon Feb  5 18:25:54 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Mon, 05 Feb 2007 13:25:54 -0500
Subject: [ragel-users] can't pull parse strings - BUG?
In-Reply-To: <1170697878.145251.186030@a75g2000cwd.googlegroups.com>
References: <1170697878.145251.186030@a75g2000cwd.googlegroups.com>
Message-ID: <45C776B2.4010206@cs.queensu.ca>

Ahhh, sorry this example is broken. It's missing a %% write init; in the
init function. Move the write data up, add the init and also add fbreaks
after your ret_tok(TK_String) and your troubles should go away.

Note that it worked before adding in the strings because it was just chance
that the start state had id 0.

-Adrian

Jason wrote:
> I've finally gotten a little time to start working with the new
> pullscan example.
> 
> Everything was going well until I tried to add string tokens. The rl
> (below) works as is but un-comment the String rules and all hell
> breaks loose.
> 
> Any pointers would be most welcome.
> 
> ---      TEST input file -------
> [target go: 124 with:(1..9) num:1,298,99 int:87 float:1,299.987]
> 
> (list "some string")
> (list 'some other string')
> 
> -------------- mod_pullscan.rl ------------
> #include <stdio.h>
> #include <stdlib.h>
> #include <string.h>
> 
> #define BUFSIZE 4096
> 
> typedef struct _Scanner {
> 	/* Scanner state. */
>     int cs;
>     int act;
>     int have;
>     int curline;
>     char *tokstart;
>     char *tokend;
>     char *p;
>     char *pe;
> 	FILE *file;
> 	int done;
> 
> 	/* Token data */
> 	char *data;
> 	int len;
>     int value;
> 	char *token_name;
> 	char buf[BUFSIZE];
> } Scanner;
> 
> 
> void scan_init( Scanner *s, FILE *file )
> {
> 	memset (s, '\0', sizeof(Scanner));
> 	s->curline = 1;
> 	s->file = file;
> }
> 
> #define TK_NO_TOKEN (-1)
> #define TK_ERR 128
> #define TK_EOF 129
> #define TK_Identifier 130
> #define TK_Number 131
> #define TK_Keyword 132
> #define TK_String 133
> 
> 
> %%{
> 	machine Scanner;
> 	write data;
> }%%
> 
> #define ret_tok( _tok ) token = _tok; s->data = s->tokstart; s-
>> token_name = #_tok
> #define ret_char( _tok ) token = _tok; s->data = s->tokstart; s-
>> token_name = "TK_Char"
> 
> int scan( Scanner *s )
> {
> 	char *p = s->p;
> 	char *pe = s->pe;
> 	int token = TK_NO_TOKEN;
> 	int space, readlen;
> 
> 	while ( 1 ) {
> 		if ( p == pe ) {
> 			printf("scanner: need more data\n");
> 
> 			if ( s->tokstart == 0 )
> 				s->have = 0;
> 			else {
> 				/* There is data that needs to be shifted over. */
> 				printf("scanner: buffer broken mid token\n");
> 				s->have = pe - s->tokstart;
> 				memmove( s->buf, s->tokstart, s->have );
> 				s->tokend -= (s->tokstart-s->buf);
> 				s->tokstart = s->buf;
> 			}
> 
> 			p = s->buf + s->have;
> 			space = BUFSIZE - s->have;
> 
> 			if ( space == 0 ) {
> 				/* We filled up the buffer trying to scan a token. */
> 				printf("scanner: out of buffer space\n");
> 				return TK_ERR;
> 			}
> 
> 			if ( s->done ) {
> 				printf("scanner: end of file\n");
> 				p[0] = 0;
> 				readlen = 1;
> 			}
> 			else {
> 				readlen = fread( p, 1, space, s->file );
> 				if ( readlen < space )
> 					s->done = 1;
> 			}
> 
> 			pe = p + readlen;
> 		}
> 
> 		%%{
> 			machine Scanner;
> 			access s->;
> 
> 			newline = '\n' @{s->curline += 1;};
> 			any_count_line = any | newline;
> 
> 			main := |*
> 
> 			# Alpha numberic characters or underscore.
> 			alnum_u = alnum | '_';
> 
> 			# Alpha charactres or underscore.
> 			alpha_u = alpha | '_';
> 
> 			ident = alpha_u alnum_u*;
> 
> 			# Identifiers
> 			ident =>
> 				{ ret_tok( TK_Identifier ); fbreak; };
> 
> 			# Keywords
> 			ident ':' => {
> 				ret_tok (TK_Keyword); fbreak;
> 			};
> 
> 	# Strings
> #			"'" ( [^'\\] | /\\./ )* "'" => { ret_tok (TK_String); };
> #			'"' ( [^"\\] | /\\./ )* '"' => { ret_tok (TK_String); };
> 
> 			# Whitespace
> 			[ \t\n];
> 
> 			# Number
> 			digit+ =>
> 				{ ret_tok( TK_Number ); fbreak; };
> 
> 			# EOF
> 			0 =>
> 				{ ret_tok( TK_EOF ); fbreak; };
> 
> 			# Anything else
> 			any =>
> 				{ ret_char( *p ); fbreak; };
> 
> 			*|;
> 
> 			write exec;
> 		}%%
> 
> 		if ( s->cs == Scanner_error )
> 			return TK_ERR;
> 
> 		if ( token != TK_NO_TOKEN ) {
> 			/* Save p and pe. fbreak does not advance p. */
> 			s->p = p + 1;
> 			s->pe = pe;
> 			s->len = s->p - s->data;
> 			return token;
> 		}
> 	}
> }
> 
> 
> int main (int argc, char** argv)
> {
> 	Scanner ss;
> 	int tok;
> 
> 	scan_init(&ss, stdin);
> 
> 	while ( 1 ) {
> 		tok = scan (&ss);
> 		if ( tok == TK_EOF ) {
> 			printf ("parser: EOF\n");
> 			break;
> 		}
> 		else if ( tok == TK_ERR ) {
> 			printf ("parser: ERR\n");
> 			break;
> 		}
> 		else {
> 			printf ("parser: %s(%d) \"", ss.token_name, tok);
> 			fwrite ( ss.data, 1, ss.len, stdout );
> 			printf ("\"\n" );
> 		}
> 	}
> 
> 	return 0;
> }
> 
> 
> 


From jason2... at jasonjobe.com  Mon Feb  5 18:51:18 2007
From: jason2... at jasonjobe.com (Jason)
Date: Mon, 05 Feb 2007 10:51:18 -0800
Subject: can't pull parse strings - BUG?
In-Reply-To: <45C776B2.4010206@cs.queensu.ca>
References: <1170697878.145251.186030@a75g2000cwd.googlegroups.com>
   <45C776B2.4010206@cs.queensu.ca>
Message-ID: <1170701478.988422.11130@a75g2000cwd.googlegroups.com>

Great! Strings now work.

However :-(

I added in rules to distinguish between integers and floats (reals).

	# Numbers
	digit+ => {
		ret_tok (TK_Integer); fbreak;
	};

	digit+'.' digit+ => {
		ret_tok (TK_Real); fbreak;
	};

Those were OK but I also want to recognize numbers separated by commas
(e.g. 1,299 and 1,299.987).

So I added these rules

	digit{1,3} (',' digit{3})+ {
		ret_tok (TK_Integer); fbreak;
	};
and
	digit{1,3} (',' digit{3})+ '.' digit+ {
		ret_tok (TK_Real); fbreak;
	};

But this reports the following error:

ragel pullscan.rl | rlcodegen -G2 -o pullscan.c
gcc -pedantic -Wall -O3 -g -c -o pullscan.o pullscan.c
pullscan.rl: In function 'scan':
pullscan.rl:1: error: 'act' undeclared (first use in this function)
pullscan.rl:1: error: (Each undeclared identifier is reported only
once
pullscan.rl:1: error: for each function it appears in.)
make: *** [pullscan.o] Error 1

Any ideas?

thanks,
Jason


From thurs... at cs.queensu.ca  Mon Feb  5 19:24:27 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Mon, 05 Feb 2007 14:24:27 -0500
Subject: [ragel-users] Re: can't pull parse strings - BUG?
In-Reply-To: <1170701478.988422.11130@a75g2000cwd.googlegroups.com>
References: <1170697878.145251.186030@a75g2000cwd.googlegroups.com> <45C776B2.4010206@cs.queensu.ca> <1170701478.988422.11130@a75g2000cwd.googlegroups.com>
Message-ID: <45C7846B.8060207@cs.queensu.ca>

Hi,

The variable "act" is needed by scanners when they must backtrack to the
last matched rule and the rule cannot be determined statically. You can just
add "int act;" alongside tokstart et al. Section 2.7 of the manual will help
you out.

Cheers,
 Adrian

Jason wrote:
> Great! Strings now work.
> 
> However :-(
> 
> I added in rules to distinguish between integers and floats (reals).
> 
> 	# Numbers
> 	digit+ => {
> 		ret_tok (TK_Integer); fbreak;
> 	};
> 
> 	digit+'.' digit+ => {
> 		ret_tok (TK_Real); fbreak;
> 	};
> 
> Those were OK but I also want to recognize numbers separated by commas
> (e.g. 1,299 and 1,299.987).
> 
> So I added these rules
> 
> 	digit{1,3} (',' digit{3})+ {
> 		ret_tok (TK_Integer); fbreak;
> 	};
> and
> 	digit{1,3} (',' digit{3})+ '.' digit+ {
> 		ret_tok (TK_Real); fbreak;
> 	};
> 
> But this reports the following error:
> 
> ragel pullscan.rl | rlcodegen -G2 -o pullscan.c
> gcc -pedantic -Wall -O3 -g -c -o pullscan.o pullscan.c
> pullscan.rl: In function 'scan':
> pullscan.rl:1: error: 'act' undeclared (first use in this function)
> pullscan.rl:1: error: (Each undeclared identifier is reported only
> once
> pullscan.rl:1: error: for each function it appears in.)
> make: *** [pullscan.o] Error 1
> 
> Any ideas?
> 
> thanks,
> Jason
> 
> 
> 


From jason2... at jasonjobe.com  Mon Feb  5 19:43:50 2007
From: jason2... at jasonjobe.com (Jason)
Date: Mon, 05 Feb 2007 11:43:50 -0800
Subject: can't pull parse strings - BUG?
In-Reply-To: <45C7846B.8060207@cs.queensu.ca>
References: <1170697878.145251.186030@a75g2000cwd.googlegroups.com>
   <45C776B2.4010206@cs.queensu.ca>
   <1170701478.988422.11130@a75g2000cwd.googlegroups.com>
   <45C7846B.8060207@cs.queensu.ca>
Message-ID: <1170704630.316602.144290@a75g2000cwd.googlegroups.com>

Adrian,

I think I found a bug, then. Note that "int act" is already declared
in our example.

In looking through the generated code I found several uses of "s->act"
but I also found it missing in the switch.

I hope this helpful.

cheers,
Jason


#line 1 "pullscan.rl"
	{	switch( act ) {
	case 6:
	{
		ret_tok (TK_Integer); {{p = (( s->tokend))-1;}goto _out14;}
	}
	break;
	case 8:
	{ ret_tok (TK_Integer); {{p = (( s->tokend))-1;}goto _out14;} }
	break;
	default: break;
	}
	{p = (( s->tokend))-1;}}
	goto st14;
st14:


From thurs... at cs.queensu.ca  Mon Feb  5 20:46:27 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Mon, 5 Feb 2007 15:46:27 -0500 (EST)
Subject: [ragel-users] Re: can't pull parse strings - BUG?
In-Reply-To: <1170704630.316602.144290@a75g2000cwd.googlegroups.com>
References: <1170697878.145251.186030@a75g2000cwd.googlegroups.com>
    <45C776B2.4010206@cs.queensu.ca>
    <1170701478.988422.11130@a75g2000cwd.googlegroups.com>
    <45C7846B.8060207@cs.queensu.ca>
    <1170704630.316602.144290@a75g2000cwd.googlegroups.com>
Message-ID: <55079.130.15.15.124.1170708387.squirrel@mambo.cs.queensu.ca>

Indeed, that is a bug. The act variable should be referenced in the same
way througout the generated code. Thanks!

-Adrian


>
> Adrian,
>
> I think I found a bug, then. Note that "int act" is already declared
> in our example.
>
> In looking through the generated code I found several uses of "s->act"
> but I also found it missing in the switch.
>
> I hope this helpful.
>
> cheers,
> Jason
>
>
> #line 1 "pullscan.rl"
> 	{	switch( act ) {
> 	case 6:
> 	{
> 		ret_tok (TK_Integer); {{p = (( s->tokend))-1;}goto _out14;}
> 	}
> 	break;
> 	case 8:
> 	{ ret_tok (TK_Integer); {{p = (( s->tokend))-1;}goto _out14;} }
> 	break;
> 	default: break;
> 	}
> 	{p = (( s->tokend))-1;}}
> 	goto st14;
> st14:
>
>
> >



From la... at laramies.com  Wed Feb  7 21:41:09 2007
From: la... at laramies.com (Arne Goedeke)
Date: Wed, 07 Feb 2007 13:41:09 -0800
Subject: json parser in ragel
Message-ID: <1170884469.176493.125530@v45g2000cwv.googlegroups.com>

Hello!

i somewhat finished my json parser in ragel and would like to put it
here for public discussion ,). also, thanks to you adrian for the cool
software.
the source-code is a little hard to read because it is full of ifdefs
and glue to the pike api (i use the parser as a module in pike). in
the first one i wrote i build my own stack to do the recursive parsing
but found this solution much better due to its simplicity. here is the
link:

http://laramies.com/ragel/json/

arne


From thurs... at cs.queensu.ca  Wed Feb  7 23:23:34 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Wed, 07 Feb 2007 18:23:34 -0500
Subject: [ragel-users] json parser in ragel
In-Reply-To: <1170884469.176493.125530@v45g2000cwv.googlegroups.com>
References: <1170884469.176493.125530@v45g2000cwv.googlegroups.com>
Message-ID: <45CA5F76.4040904@cs.queensu.ca>

Hello Arne,

This style of parser, where you implement recursive structures by 
calling parsing functions, is something that I imagined you could with 
ragel, but I never actually tried it out. It's nice to see that it can 
work. Thanks for sharing it!

Question for you: If you had a dynamically-sized stack for fcall/fret 
would you have used that mechanism? Or would you still have prefered to 
separate the parser out into different functions?

Cheers,
  Adrian

Arne Goedeke wrote:
> Hello!
> 
> i somewhat finished my json parser in ragel and would like to put it
> here for public discussion ,). also, thanks to you adrian for the cool
> software.
> the source-code is a little hard to read because it is full of ifdefs
> and glue to the pike api (i use the parser as a module in pike). in
> the first one i wrote i build my own stack to do the recursive parsing
> but found this solution much better due to its simplicity. here is the
> link:
> 
> http://laramies.com/ragel/json/
> 
> arne
> 
> 
> 


From la... at laramies.com  Thu Feb  8 10:43:11 2007
From: la... at laramies.com (Arne Goedeke)
Date: Thu, 08 Feb 2007 02:43:11 -0800
Subject: json parser in ragel
In-Reply-To: <45CA5F76.4040904@cs.queensu.ca>
References: <1170884469.176493.125530@v45g2000cwv.googlegroups.com>
   <45CA5F76.4040904@cs.queensu.ca>
Message-ID: <1170931391.948687.70830@v45g2000cwv.googlegroups.com>


On Feb 8, 12:23 am, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
> Question for you: If you had a dynamically-sized stack for fcall/fret
> would you have used that mechanism? Or would you still have prefered to
> separate the parser out into different functions?

Well, I probably would in case I do not need to create recursive data
structures along the way to store all things I already parsed. Not
sure, maybe the dynamically sized stack could keep arbitrary data too.

arne


From la... at laramies.com  Thu Feb  8 22:48:24 2007
From: la... at laramies.com (Arne Goedeke)
Date: Thu, 08 Feb 2007 14:48:24 -0800
Subject: making \n, \t etc printable
Message-ID: <1170974904.959480.139950@s48g2000cws.googlegroups.com>

hey!

I thought it would be nice for most people to have \n, \t and such
being printed out by rlcodegen -Vp using backslash escapes. here is my
patch:

--- common/common.h	2007-01-21 23:58:22.000000000 +0100
+++ common/common.h	2007-02-08 23:24:29.000000000 +0100
@@ -60,7 +60,11 @@

 	bool isUpper() const { return ( 'A' <= key && key <= 'Z' ); }
 	bool isLower() const { return ( 'a' <= key && key <= 'z' ); }
-	bool isPrintable() const { return ( 32 <= key && key < 127 ); }
+	bool isPrintable() const
+	{
+	    return ( 32 <= key && key < 127 ) || key == '\b' || key == '\t'
+		    || key == '\n' || key == '\f' || key == '\r';
+	}

 	Key toUpper() const
 		{ return Key( 'A' + ( key - 'a' ) ); }
--- rlcodegen/gvdotgen.cpp	2007-01-21 23:58:22.000000000 +0100
+++ rlcodegen/gvdotgen.cpp	2007-02-08 23:24:36.000000000 +0100
@@ -47,6 +47,21 @@
 			case '"': case '\\':
 				out << "\\" << cVal;
 				break;
+			case '\n':
+				out << "\\\\n";
+				break;
+			case '\t':
+				out << "\\\\t";
+				break;
+			case '\r':
+				out << "\\\\r";
+				break;
+			case '\b':
+				out << "\\\\b";
+				break;
+			case '\f':
+				out << "\\\\f";
+				break;
 			default:
 				out << cVal;
 				break;


From thurs... at cs.queensu.ca  Fri Feb  9 04:39:24 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Thu, 08 Feb 2007 23:39:24 -0500
Subject: [ragel-users] making \n, \t etc printable
In-Reply-To: <1170974904.959480.139950@s48g2000cws.googlegroups.com>
References: <1170974904.959480.139950@s48g2000cws.googlegroups.com>
Message-ID: <45CBFAFC.7060909@cs.queensu.ca>

Thanks, I applied it and added \a and \v.

One other character I'd like to change is 32. Printing it as ' ' looks a 
little strange sometimes. I'm thinking of changing it to SP instead.

-Adrian

Arne Goedeke wrote:
> hey!
> 
> I thought it would be nice for most people to have \n, \t and such
> being printed out by rlcodegen -Vp using backslash escapes. here is my
> patch:
> 
> --- common/common.h	2007-01-21 23:58:22.000000000 +0100
> +++ common/common.h	2007-02-08 23:24:29.000000000 +0100
> @@ -60,7 +60,11 @@
> 
>  	bool isUpper() const { return ( 'A' <= key && key <= 'Z' ); }
>  	bool isLower() const { return ( 'a' <= key && key <= 'z' ); }
> -	bool isPrintable() const { return ( 32 <= key && key < 127 ); }
> +	bool isPrintable() const
> +	{
> +	    return ( 32 <= key && key < 127 ) || key == '\b' || key == '\t'
> +		    || key == '\n' || key == '\f' || key == '\r';
> +	}
> 
>  	Key toUpper() const
>  		{ return Key( 'A' + ( key - 'a' ) ); }
> --- rlcodegen/gvdotgen.cpp	2007-01-21 23:58:22.000000000 +0100
> +++ rlcodegen/gvdotgen.cpp	2007-02-08 23:24:36.000000000 +0100
> @@ -47,6 +47,21 @@
>  			case '"': case '\\':
>  				out << "\\" << cVal;
>  				break;
> +			case '\n':
> +				out << "\\\\n";
> +				break;
> +			case '\t':
> +				out << "\\\\t";
> +				break;
> +			case '\r':
> +				out << "\\\\r";
> +				break;
> +			case '\b':
> +				out << "\\\\b";
> +				break;
> +			case '\f':
> +				out << "\\\\f";
> +				break;
>  			default:
>  				out << cVal;
>  				break;
> 
> 
> 


From er... at atlasocean.com  Fri Feb  9 06:01:51 2007
From: er... at atlasocean.com (Erich Ocean)
Date: Thu, 8 Feb 2007 22:01:51 -0800
Subject: How to execute a % action only when a zero-length match/accept occurs.
Message-ID: <6711A787-4EFC-4DC8-AB38-3A16AAF5DE6B@atlasocean.com>

Suppose we had the following machine:

%%{
machine test;

action FIRST {}
# Executed on recognition of the first character

action MATCH {}
# Executed on each character that puts the machine in a match state

action ACCEPT {}
# Executed when the machine accepts a match

main:= ( lower* >FIRST @MATCH %ACCEPT )? . ' ';
}%%

and we wanted the exact same machine, but with the ACCEPT action  
split into two:
- ACCEPT_AFTER_ZERO_LENGTH_MATCH_ONLY
- ACCEPT_AFTER_CHAR_MATCH_ONLY

Here's one way to do that in Ragel:

%%{
machine test;

action FIRST {}
# Executed on recognition of the first character

action MATCH {}
# Executed on each character that put the original machine in a match  
state

action ACCEPT_AFTER_CHAR_MATCH_ONLY {}
# Executed when the machine above accepted a match without  
recognizing any character

action ACCEPT_AFTER_ZERO_LENGTH_MATCH_ONLY {}
# Executed when the machine above accepted a match after recognizing  
a character

main := ( ('' %ACCEPT_AFTER_ZERO_LENGTH_MATCH_ONLY) | (lower+ >FIRST  
@MATCH %ACCEPT_AFTER_CHAR_MATCH_ONLY) ) . ' ';
}%%

The generated finite state machines are identical; only the actions  
executed are different. Notice that the Kleene star operator on lower  
has been changed to the one-or-more (+) operator.


From gdani... at gmail.com  Sun Feb  4 19:59:05 2007
From: gdani... at gmail.com (Greg)
Date: Sun, 04 Feb 2007 19:59:05 -0000
Subject: Next project using Ragel
Message-ID: <1170619145.522704.60670@q2g2000cwa.googlegroups.com>

Hello,

First of all I would like to thank Adrian Thurston for his tool. I am
using Ragel in my FdAjax module implementation for Lighttpd web
server. Using Ragel for parameters parsing instead of pure C code
makes the module much more secure. Keep up a good work.

Grzegorz Daniluk


From thurs... at cs.queensu.ca  Tue Feb  6 01:37:17 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Mon, 05 Feb 2007 20:37:17 -0500
Subject: [ragel-users] Next project using Ragel
In-Reply-To: <1170619145.522704.60670@q2g2000cwa.googlegroups.com>
References: <1170619145.522704.60670@q2g2000cwa.googlegroups.com>
Message-ID: <45C7DBCD.5020508@cs.queensu.ca>

That's great to hear! Thanks for sharing your use of Ragel with us. Is 
there a homepage for this project?

Regards,
  Adrian

Greg wrote:
> Hello,
> 
> First of all I would like to thank Adrian Thurston for his tool. I am
> using Ragel in my FdAjax module implementation for Lighttpd web
> server. Using Ragel for parameters parsing instead of pure C code
> makes the module much more secure. Keep up a good work.
> 
> Grzegorz Daniluk
> 
> 
> 


From gdani... at gmail.com  Fri Feb  9 09:30:31 2007
From: gdani... at gmail.com (Greg)
Date: Fri, 09 Feb 2007 01:30:31 -0800
Subject: Next project using Ragel
In-Reply-To: <45C7DBCD.5020508@cs.queensu.ca>
References: <1170619145.522704.60670@q2g2000cwa.googlegroups.com>
   <45C7DBCD.5020508@cs.queensu.ca>
Message-ID: <1171013431.329785.222340@m58g2000cwm.googlegroups.com>

> That's great to hear! Thanks for sharing your use of Ragel with us. Is
> there a homepage for this project?

I've posted two messages about FdAjax module in company blog. But the
simple homepage for it will be ready in 2 or 3 weeks.

During my CS course I learned flex and bison but Ragel interface to a
C program is much more convenient. It seems that easy integration with
host program is the key to success.

Regards,
Grzegorz Daniluk


From s... at mattmower.com  Fri Feb  9 09:51:48 2007
From: s... at mattmower.com (Matt Mower)
Date: Fri, 9 Feb 2007 09:51:48 +0000
Subject: [ragel-users] Re: Next project using Ragel
In-Reply-To: <1171013431.329785.222340@m58g2000cwm.googlegroups.com>
References: <1170619145.522704.60670@q2g2000cwa.googlegroups.com>
	 <45C7DBCD.5020508@cs.queensu.ca>
	 <1171013431.329785.222340@m58g2000cwm.googlegroups.com>
Message-ID: <d56373190702090151r4973939btf5d8ffaf49a1f0e1@mail.gmail.com>

On 09/02/07, Greg <gdani... at gmail.com> wrote:
> During my CS course I learned flex and bison but Ragel interface to a
> C program is much more convenient. It seems that easy integration with
> host program is the key to success.
>

I would agree with that. Following Why's SuperRedCloth example I had a
Ragel based Ruby extension running in about 5 minutes. It doesn't *do*
much yet, but it works and what it does do works fast.

M

-- 
Matt Mower :: http://matt.blogs.it/


From er... at atlasocean.com  Thu Feb  8 21:44:46 2007
From: er... at atlasocean.com (onitunes)
Date: Thu, 08 Feb 2007 13:44:46 -0800
Subject: syntax improvement, new operators
Message-ID: <1170971086.967308.154390@p10g2000cwp.googlegroups.com>

Hi!

I've been working on an extensive Ragel tutorial for Ragel, RegEx, and
FSM newbies based on a full PDF parser I built with Ragel. Based on
that work, I believe that the current Ragel action embedding names can
be both improved conceptually by re-categorizing and re-naming them,
and that doing so exposes three other operators that are missing in
the re-categorization and that I personally would like to see added to
Ragel. I have suggested currently unused symbols for them.

I'm posting this to the group to get some discussion and feedaback on
the proposal. Here are the operators and their suggested names and
categories. The new operators are listed at the end of each group, and
should be obivous.

I've also included some notes on what the operators mean, and also
some usage notes. Developing this conceptual framework has greatly
aided my understanding of Ragel and hopefully will help others as
well. I have found that action embeddings are the most difficult
aspect of Ragel to learn, and believe this conceptual framework
improves the situation immensely.

Best, Erich

Character Actions
=============

> aka First -- This action will be executed on the first character the machine recognizes.
$ aka Each -- This action will be executed on each character the
machine recognizes.
@ aka Match -- This action will be executed on characters the machine
recognizes that puts the machine into a match state.
< aka Continue -- (New) This action will be executed on the next
character the machine recognizes when the machine is in a match state.

Multiple character actions can be executed on the recognition of a
single character. For example, both the First and Each action are
executed (in that order) after the machine recognizes the very first
character.

Ragel guarantees that character actions will always be executed in the
following sequence:

Character_Actions_Seq = First Each+ Match (Continue Each+ Match)*
Machine_Accept;

Machine Actions
============

% aka Accept -- This action will only be executed when the machine
accepts a match.
%\ aka Fail -- (New) This action will only be executed when the
machine fails to either: (a) recognize a character, or (b) accept a
match.
%? aka Skip -- (New) This action will be executed instead of Fail when
either the Optional operator or the Kleene Star operator is applied to
the machine.

A machine can execute its Fail or Skip action even if it has already
recognized one-or-more characters. Therefore, to avoid resource leaks
you should:
	(a) only acquire resources in your First and Each actions that will
be cleaned up by your Fail or Skip action, and/or
	(b) acquire and release resources in your Match and Continue actions,
respectively.
The latter is usually the best choice if its an option.


From er... at atlasocean.com  Thu Feb  8 21:59:09 2007
From: er... at atlasocean.com (onitunes)
Date: Thu, 08 Feb 2007 13:59:09 -0800
Subject: syntax improvement, new operators
In-Reply-To: <1170971086.967308.154390@p10g2000cwp.googlegroups.com>
References: <1170971086.967308.154390@p10g2000cwp.googlegroups.com>
Message-ID: <1170971949.680711.134500@j27g2000cwj.googlegroups.com>

I want to add that a major motivation for the new actions is to
eliminate bugs caused by a misunderstanding of the Optional and Kleene
Star operators. Without the new actions, it's difficult to write
properly write code with Ragel that handles resource acquisition and
release. You *can* do it without the new operators by setting and
clearing external state flags, but that is error prone and requires
complex explanations of why it is necessary in the first place. Since
Ragel already has the knowledge to execute the new actions at the
correct places, I believe Ragel should provide the actions to users
directly instead of forcing us to maintain our own state flags
externally.

Best, Erich Ocean


From thurs... at cs.queensu.ca  Fri Feb  9 03:48:01 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Thu, 08 Feb 2007 22:48:01 -0500
Subject: [ragel-users] syntax improvement, new operators
In-Reply-To: <1170971086.967308.154390@p10g2000cwp.googlegroups.com>
References: <1170971086.967308.154390@p10g2000cwp.googlegroups.com>
Message-ID: <45CBEEF1.2060205@cs.queensu.ca>

Hi Erich,

I'm glad to see you are still working with Ragel! By the way, I've 
updated your name in the CREDITS file and elsewhere.

> Character Actions
> =============
> 
> > aka First -- This action will be executed on the first character the machine recognizes.
> $ aka Each -- This action will be executed on each character the
> machine recognizes.
> @ aka Match -- This action will be executed on characters the machine
> recognizes that puts the machine into a match state.
> < aka Continue -- (New) This action will be executed on the next
> character the machine recognizes when the machine is in a match state.

So it seems that you prefer to express these operators in terms of the 
characters of the input string that is processed. This is distinct from 
my approach, where I talk about the transitions of a regular 
expression's corresponding state machine.

I prefer to express the operators in terms of transitions because I find 
it to be very precise. For example, with "entering transition actions" 
you can go and look at the graphviz drawing and find the transitions 
which take you into the machine. That's me though, and I would very much 
like to hear what others think. Is it better to talk about the 
transitions that the actions are put into, or is better to talk about 
the characters that are moved over when the actions are executed?

The < operator you have given I find interesting. As I understand it, 
this would embed the action on the transitions which leave final states 
(but stay in the machine). Could you give an example of when it is useful?


> Machine Actions
> ============
> 
> % aka Accept -- This action will only be executed when the machine
> accepts a match.

The word "accept" I find to be somewhat ambiguous. It doesn't strike me 
that it means only one of "on the last character" or "on the next 
character." It seems to me that it could easily be interpreted as either 
of those. I chose the word "leaving" for this operator because it's 
clear to me that it means on the next character.

> %\ aka Fail -- (New) This action will only be executed when the
> machine fails to either: (a) recognize a character, or (b) accept a
> match.

I'm not quite sure what you mean with (b). I would assume you mean the 
same as above, what is currently known as the leaving (or pending out) 
operator. But then I believe this new operator would be the same as the 
$! operator. Could you clarify?

> %? aka Skip -- (New) This action will be executed instead of Fail when
> either the Optional operator or the Kleene Star operator is applied to
> the machine.

I'm not sure I understand this operator. If you write:

( expr %? skip_act )?

Is it the same as writing the following?

( expr | "" %skip_act )

Could you give us an example of the kind of problem that motivated these 
operators? Especially the part about setting and clearing external state 
flags to do proper resource acquisition and release. An example would 
really help me to understand the issue.

Regards,
  Adrian


From er... at atlasocean.com  Fri Feb  9 04:40:11 2007
From: er... at atlasocean.com (Erich Ocean)
Date: Thu, 8 Feb 2007 20:40:11 -0800
Subject: [ragel-users] Re: syntax improvement, new operators
In-Reply-To: <45CBEEF1.2060205@cs.queensu.ca>
References: <1170971086.967308.154390@p10g2000cwp.googlegroups.com> <45CBEEF1.2060205@cs.queensu.ca>
Message-ID: <E8234DE2-5DA3-48AD-9FDF-F978D48EC0BA@atlasocean.com>

Well, take the first User Action example in the Ragel manual on page  
28: 3.1.1 Entering Action:

action A {}
main := ( lower* >A ) .  ;

Let's modify it to add a Pending Out (Leaving) Action, and then make  
that machine optional:

action ENTER_TRANSITION {} # Entering Action
action LEAVE_TRANSITION {} # Pending Out (Leaving) Action

main := ( lower* >ENTER_TRANSITION %LEAVE_TRANSITION )? . ' ';

If the first character recognized by main happens to be a space, then  
LEAVE will be executed, but ENTER won't.

I think it's confusing to a user that a machine will execute its  
Leaving action (to use your terminology) without first executing its  
Entering.

The confusion goes away if you've learned that the > action will only  
be executed on the first character.

The % action isn't a character action, it's a machine action (to use  
my terminology). So a user would naturally reason that it could be  
executed even though no character was recognized, as is this case:

action FIRST_CHAR {} # Executed on recognition of the first character
action MACHINE_ACCEPT {} # Executed when the machine accepts a match

main := ( lower* >FIRST_CHAR %MACHINE_ACCEPT )? . ' ';

I use the Match/Accept terminology because any given machine can make  
a whole bunch of matches while it's recognizing characters, and the @  
action is executed every single time the machine recognizes a match.  
The % action, on the other hand, is only executed when the machine  
finally accepts one of those matches. The @ action (Match) is a  
character action because it is always and only triggered upon the  
recognition of a character, whereas the Accept action is a machine  
action because is only ever executed once, when the machine accepts a  
match, regardless of whether or not a character has been recognized.  
It's character-independent.

Hope this explains some of the reasoning behind the categorization  
and new terminology.

Best, Erich

On Feb 8, 2007, at 7:48 PM, Adrian Thurston wrote:

>
> Hi Erich,
>
> I'm glad to see you are still working with Ragel! By the way, I've
> updated your name in the CREDITS file and elsewhere.
>
>> Character Actions
>> =============
>>
>>> aka First -- This action will be executed on the first character  
>>> the machine recognizes.
>> $ aka Each -- This action will be executed on each character the
>> machine recognizes.
>> @ aka Match -- This action will be executed on characters the machine
>> recognizes that puts the machine into a match state.
>> < aka Continue -- (New) This action will be executed on the next
>> character the machine recognizes when the machine is in a match  
>> state.
>
> So it seems that you prefer to express these operators in terms of the
> characters of the input string that is processed. This is distinct  
> from
> my approach, where I talk about the transitions of a regular
> expression's corresponding state machine.
>
> I prefer to express the operators in terms of transitions because I  
> find
> it to be very precise. For example, with "entering transition actions"
> you can go and look at the graphviz drawing and find the transitions
> which take you into the machine. That's me though, and I would very  
> much
> like to hear what others think. Is it better to talk about the
> transitions that the actions are put into, or is better to talk about
> the characters that are moved over when the actions are executed?
>
> The < operator you have given I find interesting. As I understand it,
> this would embed the action on the transitions which leave final  
> states
> (but stay in the machine). Could you give an example of when it is  
> useful?
>
>
>> Machine Actions
>> ============
>>
>> % aka Accept -- This action will only be executed when the machine
>> accepts a match.
>
> The word "accept" I find to be somewhat ambiguous. It doesn't  
> strike me
> that it means only one of "on the last character" or "on the next
> character." It seems to me that it could easily be interpreted as  
> either
> of those. I chose the word "leaving" for this operator because it's
> clear to me that it means on the next character.
>
>> %\ aka Fail -- (New) This action will only be executed when the
>> machine fails to either: (a) recognize a character, or (b) accept a
>> match.
>
> I'm not quite sure what you mean with (b). I would assume you mean the
> same as above, what is currently known as the leaving (or pending out)
> operator. But then I believe this new operator would be the same as  
> the
> $! operator. Could you clarify?
>
>> %? aka Skip -- (New) This action will be executed instead of Fail  
>> when
>> either the Optional operator or the Kleene Star operator is  
>> applied to
>> the machine.
>
> I'm not sure I understand this operator. If you write:
>
> ( expr %? skip_act )?
>
> Is it the same as writing the following?
>
> ( expr | "" %skip_act )
>
> Could you give us an example of the kind of problem that motivated  
> these
> operators? Especially the part about setting and clearing external  
> state
> flags to do proper resource acquisition and release. An example would
> really help me to understand the issue.
>
> Regards,
>   Adrian
>
>
> >


From thurs... at cs.queensu.ca  Fri Feb  9 05:37:42 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Fri, 09 Feb 2007 00:37:42 -0500
Subject: [ragel-users] Re: syntax improvement, new operators
In-Reply-To: <E8234DE2-5DA3-48AD-9FDF-F978D48EC0BA@atlasocean.com>
References: <1170971086.967308.154390@p10g2000cwp.googlegroups.com> <45CBEEF1.2060205@cs.queensu.ca> <E8234DE2-5DA3-48AD-9FDF-F978D48EC0BA@atlasocean.com>
Message-ID: <45CC08A6.9080409@cs.queensu.ca>

Prior to version 4.0, the entering action operator actually did exactly 
what you describe. If the machine's start state was final, then it also 
embedded the action into the start state as a leaving action. Initially 
I thought this was very intuitive, however over time I gradually took 
the opinion that all operators should have a single purpose. This makes 
things more predictable. See the V4 release notes for more details.

If you would like to achieve the same effect from 3.X and prior you can 
do this:

main := ( "" %ENTER | lower* >ENTER %LEAVE ) . ' ';

Some point in the future I hope to add some kind of higher order 
notation which allows one to wrap these things up into user-defined 
functions.

> The % action, on the other hand, is only executed when the machine  
> finally accepts one of those matches. The @ action (Match) is a  
> character action because it is always and only triggered upon the  
> recognition of a character, whereas the Accept action is a machine  
> action because is only ever executed once, when the machine accepts a  
> match, regardless of whether or not a character has been recognized.  
> It's character-independent.

Note that the % operator requires a character to follow. If no character 
follows then nothing is executed.

Regards,
  Adrian

> 
> Hope this explains some of the reasoning behind the categorization  
> and new terminology.
> 
> Best, Erich
> 
> On Feb 8, 2007, at 7:48 PM, Adrian Thurston wrote:
> 
>> Hi Erich,
>>
>> I'm glad to see you are still working with Ragel! By the way, I've
>> updated your name in the CREDITS file and elsewhere.
>>
>>> Character Actions
>>> =============
>>>
>>>> aka First -- This action will be executed on the first character  
>>>> the machine recognizes.
>>> $ aka Each -- This action will be executed on each character the
>>> machine recognizes.
>>> @ aka Match -- This action will be executed on characters the machine
>>> recognizes that puts the machine into a match state.
>>> < aka Continue -- (New) This action will be executed on the next
>>> character the machine recognizes when the machine is in a match  
>>> state.
>> So it seems that you prefer to express these operators in terms of the
>> characters of the input string that is processed. This is distinct  
>> from
>> my approach, where I talk about the transitions of a regular
>> expression's corresponding state machine.
>>
>> I prefer to express the operators in terms of transitions because I  
>> find
>> it to be very precise. For example, with "entering transition actions"
>> you can go and look at the graphviz drawing and find the transitions
>> which take you into the machine. That's me though, and I would very  
>> much
>> like to hear what others think. Is it better to talk about the
>> transitions that the actions are put into, or is better to talk about
>> the characters that are moved over when the actions are executed?
>>
>> The < operator you have given I find interesting. As I understand it,
>> this would embed the action on the transitions which leave final  
>> states
>> (but stay in the machine). Could you give an example of when it is  
>> useful?
>>
>>
>>> Machine Actions
>>> ============
>>>
>>> % aka Accept -- This action will only be executed when the machine
>>> accepts a match.
>> The word "accept" I find to be somewhat ambiguous. It doesn't  
>> strike me
>> that it means only one of "on the last character" or "on the next
>> character." It seems to me that it could easily be interpreted as  
>> either
>> of those. I chose the word "leaving" for this operator because it's
>> clear to me that it means on the next character.
>>
>>> %\ aka Fail -- (New) This action will only be executed when the
>>> machine fails to either: (a) recognize a character, or (b) accept a
>>> match.
>> I'm not quite sure what you mean with (b). I would assume you mean the
>> same as above, what is currently known as the leaving (or pending out)
>> operator. But then I believe this new operator would be the same as  
>> the
>> $! operator. Could you clarify?
>>
>>> %? aka Skip -- (New) This action will be executed instead of Fail  
>>> when
>>> either the Optional operator or the Kleene Star operator is  
>>> applied to
>>> the machine.
>> I'm not sure I understand this operator. If you write:
>>
>> ( expr %? skip_act )?
>>
>> Is it the same as writing the following?
>>
>> ( expr | "" %skip_act )
>>
>> Could you give us an example of the kind of problem that motivated  
>> these
>> operators? Especially the part about setting and clearing external  
>> state
>> flags to do proper resource acquisition and release. An example would
>> really help me to understand the issue.
>>
>> Regards,
>>   Adrian
>>
>>
> 
> 
> 


From er... at atlasocean.com  Fri Feb  9 06:00:31 2007
From: er... at atlasocean.com (Erich Ocean)
Date: Thu, 8 Feb 2007 22:00:31 -0800
Subject: [ragel-users] Re: syntax improvement, new operators
In-Reply-To: <45CC08A6.9080409@cs.queensu.ca>
References: <1170971086.967308.154390@p10g2000cwp.googlegroups.com> <45CBEEF1.2060205@cs.queensu.ca> <E8234DE2-5DA3-48AD-9FDF-F978D48EC0BA@atlasocean.com> <45CC08A6.9080409@cs.queensu.ca>
Message-ID: <18CF6DD1-0A91-45CF-AD9A-968EB5EB9F40@atlasocean.com>

I find how the current action operators work intuitive, it's the  
*naming* that I find unintuitive. (Perhaps that should have been  
changed along with the behavior change in 4.0.)

It might be worthwhile to add a new machine-level action operator  
that was always executed before any other action was executed by the  
machine (we could call it Start), though I don't have any ready use  
for one.

Best, Erich


From thurs... at cs.queensu.ca  Sat Feb 10 18:09:54 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Sat, 10 Feb 2007 13:09:54 -0500
Subject: [ragel-users] Re: syntax improvement, new operators
In-Reply-To: <18CF6DD1-0A91-45CF-AD9A-968EB5EB9F40@atlasocean.com>
References: <1170971086.967308.154390@p10g2000cwp.googlegroups.com> <45CBEEF1.2060205@cs.queensu.ca> <E8234DE2-5DA3-48AD-9FDF-F978D48EC0BA@atlasocean.com> <45CC08A6.9080409@cs.queensu.ca> <18CF6DD1-0A91-45CF-AD9A-968EB5EB9F40@atlasocean.com>
Message-ID: <45CE0A72.9@cs.queensu.ca>

Hi Erich,

Entering actions are always executed before any other actions which have 
been previously embedded in the machine. In this example sub is 
evaluated and all its actions are embedded. Then the first action is 
embedded, but it goes to the front of any action list it is put in 
because it is a starting action.

action a1 {}
action a2 {}
action first {}

sub = ( 'a' 'b'* ) >a1 $a2;
main := sub >first;

Regards,
  Adrian

Erich Ocean wrote:
> I find how the current action operators work intuitive, it's the  
> *naming* that I find unintuitive. (Perhaps that should have been  
> changed along with the behavior change in 4.0.)
> 
> It might be worthwhile to add a new machine-level action operator  
> that was always executed before any other action was executed by the  
> machine (we could call it Start), though I don't have any ready use  
> for one.
> 
> Best, Erich
> 
> 


From er... at atlasocean.com  Sat Feb 10 18:29:31 2007
From: er... at atlasocean.com (Erich Ocean)
Date: Sat, 10 Feb 2007 10:29:31 -0800
Subject: [ragel-users] Re: syntax improvement, new operators
In-Reply-To: <45CE0A72.9@cs.queensu.ca>
References: <1170971086.967308.154390@p10g2000cwp.googlegroups.com> <45CBEEF1.2060205@cs.queensu.ca> <E8234DE2-5DA3-48AD-9FDF-F978D48EC0BA@atlasocean.com> <45CC08A6.9080409@cs.queensu.ca> <18CF6DD1-0A91-45CF-AD9A-968EB5EB9F40@atlasocean.com> <45CE0A72.9@cs.queensu.ca>
Message-ID: <63A8E26C-B473-4F59-8FCE-A2AE8B31107F@atlasocean.com>

action a1 {}
action a2 {}
action skippable {}
action not_skippable {}

sub = ( 'a' 'b'* ) >a1 $a2;
main := (sub? >skippable %not_skippable) . 'c';

If 'skippable' was a machine-level Start action, it would always be  
executed before %not_skippable, whereas the character-level > action  
is only executed if a character happens to be recognized by 'sub'  
prior to accepting.

A machine-level 'Start' action would be symmetric with % in all  
cases. > is not symmetric with %; it's closest symmetry is @ (at  
least it's always guaranteed to be executed before @ in the same  
machine).

Best, Erich

On Feb 10, 2007, at 10:09 AM, Adrian Thurston wrote:

>
> Hi Erich,
>
> Entering actions are always executed before any other actions which  
> have
> been previously embedded in the machine. In this example sub is
> evaluated and all its actions are embedded. Then the first action is
> embedded, but it goes to the front of any action list it is put in
> because it is a starting action.
>
> action a1 {}
> action a2 {}
> action first {}
>
> sub = ( 'a' 'b'* ) >a1 $a2;
> main := sub >first;
>
> Regards,
>   Adrian
>
> Erich Ocean wrote:
>> I find how the current action operators work intuitive, it's the
>> *naming* that I find unintuitive. (Perhaps that should have been
>> changed along with the behavior change in 4.0.)
>>
>> It might be worthwhile to add a new machine-level action operator
>> that was always executed before any other action was executed by the
>> machine (we could call it Start), though I don't have any ready use
>> for one.
>>
>> Best, Erich
>>
>>
>
> >


From stephenhorne... at aol.com  Tue Feb 13 09:48:12 2007
From: stephenhorne... at aol.com (Steve Horne)
Date: Tue, 13 Feb 2007 01:48:12 -0800
Subject: Some Ragel Ideas
Message-ID: <1171360092.851311.131520@p10g2000cwp.googlegroups.com>

Is this an appropriate place to discuss Kelbt?

Also, here's a few Ragel extension ideas - none are things I need ATM
(barring perhaps the third one), just nice ideas.

First off, could Ragel be extended to handle tail recursion? Direct
tail recursion would be sufficient. Indirect tail recursion even
better, but I imagine quite difficult.

For example, consider the following...

main := case1 main? | case2 main | case3 | case4;

This can be translated to a non-recursive form, of course, giving...

main := (case1 | case2)* (case1 | case3 | case4);

But depending on the context, the tail recursive form may be clearer
and better describe the intent, or may be closer to the way the
requirements are specified. Note, for example, that the recursive
spec. only references each 'case' once, whereas the non-recursive
version mentions 'case1' twice (in the loop, and as a possible
terminator).

Second, how about an equivalence assertion operator?

The idea here is that two different specifications of a machine could
represent two 'theories' of how it would work. If the two theories
give different results, display an error message.

In combination with the recursion support, for instance, this would
allow the same machine to be described both ways for readability and
validation purposes. Anyone trying to understand the machine could
read either specification.

Third, Ragel seems to have a lot of cryptic operators. For those of us
who will only be using it occasionally, it might be a bit more
friendly if the less standard/obvious ones were given explicitly named
equivalents. Perhaps something similar to...

  "{*" identifier args* "*}"

... could be treated as a kind of S-expression alternative form for
some operators (esp. action operators and guarded forms).

For actions, rather than nesting { and }, a separator might be
useful...

  {* on_enter action_name  *}
  {* on_enter : <action code>  *}

One idea I have in mind involves a kind of paranoid library, that
checks whether calls to it match the required protocol - a file
creation library that knows when the caller has misbehaved in such a
way that a corrupt file has been created.


From thurs... at cs.queensu.ca  Tue Feb 13 16:17:36 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Tue, 13 Feb 2007 11:17:36 -0500
Subject: [ragel-users] Some Ragel Ideas
In-Reply-To: <1171360092.851311.131520@p10g2000cwp.googlegroups.com>
References: <1171360092.851311.131520@p10g2000cwp.googlegroups.com>
Message-ID: <45D1E4A0.8010208@cs.queensu.ca>

Hi Steve,

> Is this an appropriate place to discuss Kelbt?

Perhaps email is better for now.

> First off, could Ragel be extended to handle tail recursion? Direct
> tail recursion would be sufficient. Indirect tail recursion even
> better, but I imagine quite difficult.

In terms of just purely regular languages .. yes, I would think it would 
be doable. I imagine rewriting of the parse trees would be the proper 
way to do it. However, there might be issues with regards to the 
extensions to the regular language model. The user currently relies on 
the parse tree structure to reason about the order of execution of 
multiple actions on a single transition. Also, the parse tree is very 
important when reasoning about ambiguities. Parse tree rewrites might 
make reasoning about these things harder.

> Second, how about an equivalence assertion operator?

Ragel deals strictly with constructing deterministic state machines 
(that sometimes backtrack). There are many advantages to adhering to 
this model. Generating logic that executes a machine more than once on 
an input or that prints messages is outside of the scope of ragel.

On the other hand, at the machine construction level you could use the 
intersection operator & in Ragel to check if two machines match the same 
set of strings. For example, if two machines are identical then

( m1 | m2 ) - ( m1 & m2 )

should be empty (anyone please correct me if I'm wrong). A person well 
versed in language theory results (not me) would probably point you in 
the right direction.

> Third, Ragel seems to have a lot of cryptic operators. For those of us
> who will only be using it occasionally, it might be a bit more
> friendly if the less standard/obvious ones were given explicitly named
> equivalents. Perhaps something similar to...

Agreed. The operators are cryptic. Over the years I've played with 
various verbose embedding forms. So far nothing promising has been found 
so I've left it out of the docs. My current idea might be the one though.

main := m1 <-embedding_name(action_name)

or

main := m1 <-embedding_name{code}

This would also support user-defined embedding types, which I think is a 
big win.

Regards,
  Adrian


From stephenhorne... at aol.com  Wed Feb 14 04:21:18 2007
From: stephenhorne... at aol.com (Steve Horne)
Date: Tue, 13 Feb 2007 20:21:18 -0800
Subject: Some Ragel Ideas
In-Reply-To: <45D1E4A0.8010208@cs.queensu.ca>
References: <1171360092.851311.131520@p10g2000cwp.googlegroups.com>
   <45D1E4A0.8010208@cs.queensu.ca>
Message-ID: <1171426878.995210.279310@k78g2000cwa.googlegroups.com>


> > First off, could Ragel be extended to handle tail recursion?

> The user currently relies on
> the parse tree structure to reason about the order of execution of
> multiple actions on a single transition. Also, the parse tree is very
> important when reasoning about ambiguities. Parse tree rewrites might
> make reasoning about these things harder.

Understood.

It should be possible to do this without a parse tree rewrite, though
- think of the recursion as a 'goto' rather than as a structured loop.

Any tail call results in a special annotation in the state model. When
this machine gets inserted into the appropriately named larger
machine, the annotations are detected and result in appropriate
epsilon -like transitions being added, linking back to the larger
machines start state. At least, I think that would work.

The most obvious problem is that you don't know whether a call is
indirectly tail-recursive or not at the point when you first compile
it. Resolving that would probably be a big problem, and in any case,
allowing it would make it difficult to detect and reject non-tail
recursion (raising the possibility of state model compilation failing
to terminate).

That's why I suggested that direct recursion (where legal tail
recursion can be accurately detected from the start) would be
sufficient.

An explicit 'this is recursive' operator might resolve these issues...

x := a b ~z;
y := c d x;
z := e f y;

In the definition of x, the '~' indicates both a forward reference to
'z', and that 'x' *must* be called from 'z' (the recursion is
compulsory). But that's yet another cryptic operator ;-)

The same thing could probably be done explicitly, using labels and
epsilon transitions, of course. Just not as neat.

It's still just an idea, though. I've probably been looking at Scheme
too much recently.

> > Second, how about an equivalence assertion operator?
>
> Ragel deals strictly with constructing deterministic state machines
> (that sometimes backtrack).

Equivalence would be tested as Ragel compiles the machine, and one of
the two equivalent models would then be discarded. The idea is
redundant definition with compile-time validation, not a run-time
mechanism.

Possibly pointless, though, and more difficult than I thought because
checking whether actions match would be a problem.

IOW it's a bit daft, on reflection.

> main := m1 <-embedding_name(action_name)
> main := m1 <-embedding_name{code}

This looks pretty good to me.

I'm a little confused about user-defined embedding types, though - how
would they be used?


From thurs... at cs.queensu.ca  Wed Feb 14 05:31:44 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Wed, 14 Feb 2007 00:31:44 -0500
Subject: [ragel-users] Re: Some Ragel Ideas
In-Reply-To: <1171426878.995210.279310@k78g2000cwa.googlegroups.com>
References: <1171360092.851311.131520@p10g2000cwp.googlegroups.com> <45D1E4A0.8010208@cs.queensu.ca> <1171426878.995210.279310@k78g2000cwa.googlegroups.com>
Message-ID: <45D29EC0.30002@cs.queensu.ca>

Hey Steve,

Steve Horne wrote:
> It should be possible to do this without a parse tree rewrite, though
> - think of the recursion as a 'goto' rather than as a structured loop.
> 
> Any tail call results in a special annotation in the state model. When
> this machine gets inserted into the appropriately named larger
> machine, the annotations are detected and result in appropriate
> epsilon -like transitions being added, linking back to the larger
> machines start state. At least, I think that would work.

Ah, I see. Yes I think that could work in Ragel. Indirect recursion 
could be made to work by traversing the machine definition stack upwards 
to search for currently active references "higher up" when the parse 
tree is interpreted.

> Equivalence would be tested as Ragel compiles the machine, and one of
> the two equivalent models would then be discarded. The idea is
> redundant definition with compile-time validation, not a run-time
> mechanism.

Yeah, that could also be made to work. Actions would pose an additional 
challenge, but I don't think they would prevent it from working. If 
you're serious about this talk to me off list and I can give you some 
pointers. The question is whether or not there would be enough of a 
benefit to justify working on it.

> I'm a little confused about user-defined embedding types, though - how
> would they be used?

I'm thinking like this;

embedding buffer_and_exec(m, a) { m >buf_clear $buf_append %a }

main = foo <-buffer_and_exec{ print buf; }

Regards,
  Adrian


From cpira... at gmail.com  Sun Feb 18 11:38:45 2007
From: cpira... at gmail.com (Chris Pirazzi)
Date: Sun, 18 Feb 2007 11:38:45 -0000
Subject: action ordering.  is this a bug?
Message-ID: <1171798725.471254.284590@k78g2000cwa.googlegroups.com>


Hi,

Ragel seems completely amazing and I am hoping I can use
it for my application.  I am just getting to understand Ragel
and in particular its rules about the order in which
actions are called, because this will be important for
my application.  I have ragel-5.18.

The PDF says:

"When it visits a parse tree node it assigns
timestamps to all starting action embeddings, recurses
on the parse tree, then assigns timestamps
to the remaining all, finishing, and leaving embeddings
in the order in which they appear."

However if I feed in this small (admittedly ambiguous) grammar:

%%{

machine small;
write data noerror;

bar = 'a' >{ printf(">bar\n"); } @{ printf("@bar\n"); }  $
{ printf("$bar\n"); }  %{ printf("%%bar\n"); };

barz = ( bar* ) >{ printf(">barz\n"); } @{ printf("@barz\n"); }  $
{ printf("$barz\n"); }  %{ printf("%%barz\n"); };

tbarz = barz . barz >{ printf(">tbarz\n"); } @{ printf("@tbarz\n"); }
${ printf("$tbarz\n"); }  %{ printf("%%tbarz\n"); };

main := ( tbarz 0 ) @{ fbreak; };

write init;
write exec noend;

}%%
}%%

and I execute this machine on the input "aaa<nul>", then I would
expect to see ">tbarz" first, but I don't.  The total output is:

>barz
>bar
@bar
$bar
@barz
$barz
%barz
>tbarz
@tbarz
$tbarz
%bar
>bar
@bar
$bar
@barz
$barz
%barz
>tbarz
>barz
@tbarz
$tbarz
%bar
>bar
@bar
$bar
@barz
$barz
%barz
>tbarz
>barz
@tbarz
$tbarz
%bar
%barz
%tbarz

The "problem" can also be seen from the compiled output of ragel
without producing any C code, in that the action table id=1
does not list action 8 first.

<ragel filename="small.rl" lang="C">
<ragel_def name="small">
  <alphtype>0</alphtype>
  <machine>
    <action_list length="13">
      <action id="0" line="7" col="12"><text> printf("&gt;bar\n"); </
text></action>
      <action id="1" line="7" col="35"><text> printf("@bar\n"); </
text></action>
      <action id="2" line="7" col="59"><text> printf("$bar\n"); </
text></action>
      <action id="3" line="7" col="83"><text> printf("%%bar\n"); </
text></action>
      <action id="4" line="9" col="18"><text> printf("&gt;barz\n"); </
text></action>
      <action id="5" line="9" col="42"><text> printf("@barz\n"); </
text></action>
      <action id="6" line="9" col="67"><text> printf("$barz\n"); </
text></action>
      <action id="7" line="9" col="92"><text> printf("%%barz\n"); </
text></action>
      <action id="8" line="11" col="22"><text> printf("&gt;tbarz\n");
</text></action>
      <action id="9" line="11" col="47"><text> printf("@tbarz\n"); </
text></action>
      <action id="10" line="11" col="73"><text> printf("$tbarz\n"); </
text></action>
      <action id="11" line="11" col="99"><text> printf("%%tbarz\n"); </
text></action>
      <action id="12" line="13" col="22"><text> </text><break></
break><text> </text></action>
    </action_list>
    <action_table_list length="4">
      <action_table id="0" length="3">7 11 12</action_table>
      <action_table id="1" length="10">4 0 1 2 5 6 7 8 9 10</
action_table>
      <action_table id="2" length="4">3 7 11 12</action_table>
      <action_table id="3" length="11">3 0 1 2 5 6 7 8 4 9 10</
action_table>
    </action_table_list>
    <start_state>1</start_state>
    <error_state>0</error_state>
    <state_list length="4">
      <state id="0">
      <trans_list length="0">
      </trans_list>
      </state>

      <state id="1">
      <trans_list length="2">
        <t>0 0 3 0</t>
        <t>97 97 2 1</t>
      </trans_list>
      </state>

      <state id="2">
      <trans_list length="2">
        <t>0 0 3 2</t>
        <t>97 97 2 3</t>
      </trans_list>
      </state>

      <state id="3" final="t">
      <trans_list length="0">
      </trans_list>
      </state>
    </state_list>
  </machine>
</ragel_def>
<host line="1" col="1">

</host>
<write def_name="small" line="5" col="1"><arg>data</arg><arg>noerror</
arg></write>
<write def_name="small" line="15" col="1"><arg>init</arg></write>
<write def_name="small" line="16" col="1"><arg>exec</arg><arg>noend</
arg></write>
<host line="18">

}</host>
<host line="20"></host>
</ragel>

Have I misunderstood the rules?

Is the behavior caused by the ambiguity of the grammar?

I will make a separate post on exactly what I'm hoping to do
with ragel, and why I am even showing an ambiguous grammar.

Thanks,

     - Chris Pirazzi


From stephenhorne... at aol.com  Sun Feb 18 23:29:53 2007
From: stephenhorne... at aol.com (Steve Horne)
Date: Sun, 18 Feb 2007 15:29:53 -0800
Subject: action ordering. is this a bug?
In-Reply-To: <1171798725.471254.284590@k78g2000cwa.googlegroups.com>
References: <1171798725.471254.284590@k78g2000cwa.googlegroups.com>
Message-ID: <1171841393.419705.12210@s48g2000cws.googlegroups.com>


I understand Adrian won't be around for a couple of weeks. I'm no
Ragel expert, but I'll make what I think is an educated guess and hope
someone sets both of us straight ;-)

> I would
> expect to see ">tbarz" first, but I don't.

>From what you are saying, I suspect you are confusing 'entering a
state' with 'entering a rule'.

Your 'tbarz' rule has a sequence of two instances of 'barz'. The first
'barz' will be recognised first. In a sense, this implies that the
recognition of the 'tbarz' rule has started - but the *state* where
'tbarz' has been fully recognised will not be entered until two
instances of 'barz' have been recognised.

Even entry actions aren't triggered at the start of a rule - they are
triggered on entry into the state where the rule has been fully
recognised. Basically, the recognition tends to find the smallest
building blocks first, progressing to larger building blocks later.

In general, entry actions *cannot* be triggered on (for instance) the
first character of a rule - you cannot know for sure which is the
right rule. Consider what happens when there are two alternatives, for
instance...

opt1 = a.b;
opt2 = a.c;
main = opt1 | opt2;

When the only input that has been examined is the 'a', you cannot tell
whether you have an opt1 or an opt2. Therefore you cannot choose the
correct entry action - this can only happen when you have also
examined the 'b' or 'c' and entered the state where either opt1 or
opt2 has been fully recognised.

> Is the behavior caused by the ambiguity of the grammar?

I don't think so. The finite state models generated by Ragel should be
fully deterministic unless the backtracking scanner syntax is used.
Ragel has disambiguating rules that it uses while compiling the state
model, using priority specifications and/or guarded operators, so you
will be getting the default (all priorities equal) disambiguations.


From cpira... at gmail.com  Mon Feb 19 07:31:18 2007
From: cpira... at gmail.com (Chris Pirazzi)
Date: Mon, 19 Feb 2007 07:31:18 -0000
Subject: action ordering. is this a bug?
In-Reply-To: <1171841393.419705.12210@s48g2000cws.googlegroups.com>
References: <1171798725.471254.284590@k78g2000cwa.googlegroups.com>
   <1171841393.419705.12210@s48g2000cws.googlegroups.com>
Message-ID: <1171870278.925001.61140@q2g2000cwa.googlegroups.com>


On Feb 18, 11:29 pm, "Steve Horne" <stephenhorne... at aol.com> wrote:
> I understand Adrian won't be around for a couple of weeks. I'm no
> Ragel expert, but I'll make what I think is an educated guess and hope
> someone sets both of us straight ;-)

Hi,

Thanks for your response....see below..

> Even entry actions aren't triggered at the start of a rule - they are
> triggered on entry into the state where the rule has been fully
> recognised. Basically, the recognition tends to find the smallest
> building blocks first, progressing to larger building blocks later.
>
> In general, entry actions *cannot* be triggered on (for instance) the
> first character of a rule - you cannot know for sure which is the
> right rule. Consider what happens when there are two alternatives, for
> instance...
>
> opt1 = a.b;
> opt2 = a.c;
> main = opt1 | opt2;
>
> When the only input that has been examined is the 'a', you cannot tell
> whether you have an opt1 or an opt2. Therefore you cannot choose the
> correct entry action - this can only happen when you have also
> examined the 'b' or 'c' and entered the state where either opt1 or
> opt2 has been fully recognised.

Interesting theory, but I tried your grammar:

%%{

machine smaller;
write data noerror;

opt1 = ('a' . 'b') >{ printf(">opt1\n"); } @{ printf("@opt1\n"); }  $
{ printf("$opt1\n"); }  %{ printf("%%opt1\n"); };
opt2 = ('a' . 'c') >{ printf(">opt2\n"); } @{ printf("@opt2\n"); }  $
{ printf("$opt2\n"); }  %{ printf("%%opt2\n"); };
main := (opt1 | opt2) >{ printf(">main\n"); } @{ printf("@main\n"); }
${ printf("$main\n"); }  %{ printf("%%main\n"); };

write init;
write exec noend;

}%%
}%%

and it doesn't seem to work that way.  when you view the state
diagram, you see that
as soon as we see the 'a', regel calls ">main", then ">opt1", and
">opt2" (in this
case, unlike my initial example, this is the order I would expect with
the
parents' ">" routine being called first):

<ragel filename="smaller.rl" lang="C">
<ragel_def name="smaller">
  <alphtype>0</alphtype>
  <machine>
    <action_list length="9">
      <action id="0" line="7" col="21"><text> printf("&gt;opt1\n"); </
text></action>
      <action id="1" line="7" col="45"><text> printf("@opt1\n"); </
text></action>
      <action id="2" line="7" col="70"><text> printf("$opt1\n"); </
text></action>
      <action id="3" line="8" col="21"><text> printf("&gt;opt2\n"); </
text></action>
      <action id="4" line="8" col="45"><text> printf("@opt2\n"); </
text></action>
      <action id="5" line="8" col="70"><text> printf("$opt2\n"); </
text></action>
      <action id="6" line="9" col="24"><text> printf("&gt;main\n"); </
text></action>
      <action id="7" line="9" col="48"><text> printf("@main\n"); </
text></action>
      <action id="8" line="9" col="73"><text> printf("$main\n"); </
text></action>
    </action_list>
    <action_table_list length="3">
      <action_table id="0" length="6">6 0 2 3 5 8</action_table>
      <action_table id="1" length="4">1 2 7 8</action_table>
      <action_table id="2" length="4">4 5 7 8</action_table>
    </action_table_list>
    <start_state>1</start_state>
    <error_state>0</error_state>
    <state_list length="5">
      <state id="0">
      <trans_list length="0">
      </trans_list>
      </state>

      <state id="1">
      <trans_list length="1">
        <t>97 97 2 0</t>
      </trans_list>
      </state>

      <state id="2">
      <trans_list length="2">
        <t>98 98 3 1</t>
        <t>99 99 4 2</t>
      </trans_list>
      </state>

      <state id="3" final="t">
      <trans_list length="0">
      </trans_list>
      </state>

      <state id="4" final="t">
      <trans_list length="0">
      </trans_list>
      </state>
    </state_list>
  </machine>
</ragel_def>
<host line="1" col="1">

</host>
<write def_name="smaller" line="5" col="1"><arg>data</
arg><arg>noerror</arg></write>
<write def_name="smaller" line="11" col="1"><arg>init</arg></write>
<write def_name="smaller" line="12" col="1"><arg>exec</arg><arg>noend</
arg></write>
<host line="14">

}</host>
<host line="16"></host>
</ragel>

it seems like if ragel waited to call the ">" routine until it found a
match, then
this would be the same as the "@" routine or the "$" routine.  the ">"
routine
is then useful for creating some state (e.g. allocating a memory
location)
which can later be filled in if the rule matches.

any other ideas?

     - Chris Pirazzi



From cpira... at gmail.com  Mon Feb 19 07:47:25 2007
From: cpira... at gmail.com (Chris Pirazzi)
Date: Mon, 19 Feb 2007 07:47:25 -0000
Subject: action ordering. is this a bug?
In-Reply-To: <1171870278.925001.61140@q2g2000cwa.googlegroups.com>
References: <1171798725.471254.284590@k78g2000cwa.googlegroups.com>
   <1171841393.419705.12210@s48g2000cws.googlegroups.com>
   <1171870278.925001.61140@q2g2000cwa.googlegroups.com>
Message-ID: <1171871245.681559.255900@v45g2000cwv.googlegroups.com>


Doh!  It was a simple operator precedence issue:

tbarz = barz . barz >{ printf(">tbarz\n"); } @{ printf("@tbarz\n"); } $
{ printf("$tbarz\n"); }  %{ printf("%%tbarz\n"); };

'>' binds more tightly than '.' so it should be

tbarz = (barz . barz) >{ printf(">tbarz\n"); } @{ printf("@tbarz
\n"); } ${ printf("$tbarz\n"); }  %{ printf("%%tbarz\n"); };

and I was printing the start (and other) transitions of the second
barz.

sorry for the noise,

    - Chris Pirazzi


From stephenhorne... at aol.com  Mon Feb 19 09:14:31 2007
From: stephenhorne... at aol.com (Steve Horne)
Date: Mon, 19 Feb 2007 01:14:31 -0800
Subject: action ordering. is this a bug?
In-Reply-To: <1171871245.681559.255900@v45g2000cwv.googlegroups.com>
References: <1171798725.471254.284590@k78g2000cwa.googlegroups.com>
   <1171841393.419705.12210@s48g2000cws.googlegroups.com>
   <1171870278.925001.61140@q2g2000cwa.googlegroups.com>
   <1171871245.681559.255900@v45g2000cwv.googlegroups.com>
Message-ID: <1171876471.470308.29700@v33g2000cwv.googlegroups.com>


On Feb 19, 7:47 am, "Chris Pirazzi" <cpira... at gmail.com> wrote:

> Doh!  It was a simple operator precedence issue:

Ah - sounds like I learned more from this than you did. I should have
done more checking before posting. Sorry about that.


From jason2... at jasonjobe.com  Mon Feb 19 21:59:58 2007
From: jason2... at jasonjobe.com (Jason)
Date: Mon, 19 Feb 2007 13:59:58 -0800
Subject: How can I capture a big block of data
Message-ID: <1171922398.940429.152690@t69g2000cwt.googlegroups.com>

Hello again.

Thanks to Adrian, my pull scanner is working great.

Now I'm wanting to grab a block of XML data but since the main focus
of my scan is not XML I'm wondering if it wouldn't be easier to
delimit any xml with some tags <xml> .... </xml>, and pass the whole
block of data off to some other code and simply return a TK_XML token.

I note in many examples, zipping through comments is pretty straight
forward. Could / Should I do the same (or similar) thing to grab my
XML?

thanks,
Jason


From stephenhorne... at aol.com  Wed Feb 21 17:03:43 2007
From: stephenhorne... at aol.com (Steve Horne)
Date: Wed, 21 Feb 2007 09:03:43 -0800
Subject: How can I capture a big block of data
In-Reply-To: <1171922398.940429.152690@t69g2000cwt.googlegroups.com>
References: <1171922398.940429.152690@t69g2000cwt.googlegroups.com>
Message-ID: <1172077423.920725.5230@j27g2000cwj.googlegroups.com>


On Feb 19, 9:59 pm, "Jason" <jason2... at jasonjobe.com> wrote:

> Now I'm wanting to grab a block of XML data but since the main focus
> of my scan is not XML I'm wondering if it wouldn't be easier to
> delimit any xml with some tags <xml> .... </xml>, and pass the whole
> block of data off to some other code and simply return a TK_XML token.
>
> I note in many examples, zipping through comments is pretty straight
> forward. Could / Should I do the same (or similar) thing to grab my
> XML?

My first thought is that this should be pretty easy. You need to
recognise it in three stages...

1.  The <xml> marker, allowing for whitespace etc.
2.  The content, using a regular expression that refuses to accept the
'</xml>' (use "any* -- [expression for </xml>]").
3.  The expression for </xml>.

The one possible problem is that this would stop early in any xml that
happened to have an 'xml' tag of its own.

There is the possibility of recognising all start and end tags, so you
can keep track of the nesting. Regular expression parsing cannot
handle recursive nesting, so handling this sounds like a job for a
context-free parsing tool such as Yacc, Bison or Kelbt, but in this
case, Ragel can probably cheat.

The trick is to use actions to maintain a counter that keeps track of
nesting depth, and to use semantic conditions to check the count. With
some care, this could even give some confidence that the XML is well
formed.

That said, this also means that badly formed embedded XML will
probably prevent you from finding the real end of the XML.

Different markers could be a good idea. For instance, you should never
see a strings of multiple "<<<<<" characters in well formed XML so
this could be exploited to give a safe end marker. It might be
necessary to exclude strings within quotes, but that's a relatively
simple thing to handle using the strong difference again.


From e.vanoos... at chello.nl  Tue Feb 13 10:54:20 2007
From: e.vanoos... at chello.nl (Erik van Oosten)
Date: Tue, 13 Feb 2007 02:54:20 -0800
Subject: Generating java source code
Message-ID: <1171364060.346711.151010@v45g2000cwv.googlegroups.com>

Hi,

I am examining the use of ragel for parsing Edifact messages to java
beans. So I came across a message about a 64K limit of java arrays.

Well, unless I am missing something, this is simply not true. I just
wrote a little program to test it. With -Xms1024M -Xmx1024M as JVM
argument, the limit is somewhere between 234881023 (224M) and
251658239 (240M) items (I aborted the program, it was swapping too
much).  With only 128M of memory, the limit is still a healthy
30955269 (29M) items.

Regards,
     Erik.


public class ArrayTest {
	private int getMaxArraySize(int minValue, int maxValue) {
		int min = minValue;
		int max = maxValue;
		while (min < max) {
			System.out.println(min + "\t\t" + max);
			int halfway = min + ((max - min) >> 1);
			try {
				Object[] arr = new Object[halfway];
				min = halfway;
			} catch (Error e) {
				max = halfway - 1;
			}
		}
		return min;
	}

	public static void main(String[] args) {
		ArrayTest at = new ArrayTest();
		System.out.println(at.getMaxArraySize(0, Integer.MAX_VALUE));
	}
}


From thurs... at cs.queensu.ca  Tue Feb 13 15:26:30 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Tue, 13 Feb 2007 10:26:30 -0500
Subject: [ragel-users] Re: Generating java source code
In-Reply-To: <1171364060.346711.151010@v45g2000cwv.googlegroups.com>
References: <1171364060.346711.151010@v45g2000cwv.googlegroups.com>
Message-ID: <45D1D8A6.1040308@cs.queensu.ca>

Hi Erik, the message you read probably neglected to mention that the 
problem is with array initialization.

private static byte[] array = [ 1, 2, 3, 4, ... ];

Java initializes arrays by creating a function.

init()
{
	array[0] = 1;
	array[1] = 2;
	...
}

If there are too many elements you get the "code too large" error. This 
issue has been fixed in trunk however. Ragel now generates the 
initialization functions directly, and splits them when they get big.

Adrian

Erik van Oosten wrote:
> Hi,
> 
> I am examining the use of ragel for parsing Edifact messages to java
> beans. So I came across a message about a 64K limit of java arrays.
> 
> Well, unless I am missing something, this is simply not true. I just
> wrote a little program to test it. With -Xms1024M -Xmx1024M as JVM
> argument, the limit is somewhere between 234881023 (224M) and
> 251658239 (240M) items (I aborted the program, it was swapping too
> much).  With only 128M of memory, the limit is still a healthy
> 30955269 (29M) items.
> 
> Regards,
>      Erik.
> 
> 
> public class ArrayTest {
> 	private int getMaxArraySize(int minValue, int maxValue) {
> 		int min = minValue;
> 		int max = maxValue;
> 		while (min < max) {
> 			System.out.println(min + "\t\t" + max);
> 			int halfway = min + ((max - min) >> 1);
> 			try {
> 				Object[] arr = new Object[halfway];
> 				min = halfway;
> 			} catch (Error e) {
> 				max = halfway - 1;
> 			}
> 		}
> 		return min;
> 	}
> 
> 	public static void main(String[] args) {
> 		ArrayTest at = new ArrayTest();
> 		System.out.println(at.getMaxArraySize(0, Integer.MAX_VALUE));
> 	}
> }
> 
> 
> 


From e.vanoos... at chello.nl  Tue Feb 13 16:12:29 2007
From: e.vanoos... at chello.nl (Erik van Oosten)
Date: Tue, 13 Feb 2007 08:12:29 -0800
Subject: Generating java source code
In-Reply-To: <45D1D8A6.1040308@cs.queensu.ca>
References: <1171364060.346711.151010@v45g2000cwv.googlegroups.com>
   <45D1D8A6.1040308@cs.queensu.ca>
Message-ID: <1171383149.884994.302110@l53g2000cwa.googlegroups.com>

Ah! That makes sense.

Thanks for the explanation.

Regards,
    Erik.


On 13 feb, 16:26, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
> Hi Erik, the message you read probably neglected to mention that the
> problem is with array initialization.
>
> private static byte[] array = [ 1, 2, 3, 4, ... ];
>
> Java initializes arrays by creating a function.
>
> init()
> {
>         array[0] = 1;
>         array[1] = 2;
>         ...
>
> }
>
> If there are too many elements you get the "code too large" error. This
> issue has been fixed in trunk however. Ragel now generates the
> initialization functions directly, and splits them when they get big.
>
> Adrian


From stephenhorne... at aol.com  Wed Feb 14 15:55:23 2007
From: stephenhorne... at aol.com (Steve Horne)
Date: Wed, 14 Feb 2007 07:55:23 -0800
Subject: Generating java source code
In-Reply-To: <45D1D8A6.1040308@cs.queensu.ca>
References: <1171364060.346711.151010@v45g2000cwv.googlegroups.com>
   <45D1D8A6.1040308@cs.queensu.ca>
Message-ID: <1171468523.177492.255590@m58g2000cwm.googlegroups.com>


On Feb 13, 3:26 pm, Adrian Thurston <thurs... at cs.queensu.ca> wrote:

> This
> issue has been fixed in trunk however. Ragel now generates the
> initialization functions directly, and splits them when they get big.

That seems a terrible way of initialising large arrays. You could
easily end up with more overhead (code to insert the items) than data,
depending on precisely how the VM bytecode works.

Couldn't the compiled data tables be stored in data files? I confess
I'm pretty ignorant of Java, beyond the basic language syntax, but
isn't there some way to embed application data files into those jar
files? Something intended to do a similar job to embedding resource
data into executables?

The file layout would have to be simple, though - there'd be no point
if you need another parser just to load it!


From colin.mailingl... at gmail.com  Mon Feb 26 19:20:47 2007
From: colin.mailingl... at gmail.com (Colin Fleming)
Date: Mon, 26 Feb 2007 20:20:47 +0100
Subject: [ragel-users] Re: Generating java source code
In-Reply-To: <1171468523.177492.255590@m58g2000cwm.googlegroups.com>
References: <1171364060.346711.151...@v45g2000cwv.googlegroups.com>
	 <45D1D8A6.1040...@cs.queensu.ca>
	 <1171468523.177492.255...@m58g2000cwm.googlegroups.com>
Message-ID: <7c6512110702261120s17edea41r469b14f7253f65b9@mail.gmail.com>

The issue, as Adrian pointed out, is that Java initialises arrays by
creating a huge list of assignments, and there's a JVM limit of 64k
per method, which is frequently a problem for generated code. There
are various hacks (encoding data in Strings etc), but none of them are
very elegant.

The problem with putting data in Jar files is that it then makes
building the Jar files more complicated. The data files have to exist
in a known location in the jar, and if there's a problem, you won't
know about it until runtime. Not much more complicated, but a bit -
AFAIK it's not easy to do with Maven, for example. As ugly as it is,
the array initialiser method means that you just compile your classes
and can do what you want with them afterwards, and it won't have
runtime dependencies. It might be worth providing this as an option,
though.

I was working on the Java generation a while back, but unfortunately I
got seriously sidetracked, and haven't been able to get back to it.

Cheers,
Colin


From thurs... at cs.queensu.ca  Wed Feb 14 01:07:31 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Tue, 13 Feb 2007 20:07:31 -0500
Subject: new backend executable names in 5.18
Message-ID: <45D260D3.6080508@cs.queensu.ca>

Hi,

In version 5.18 the backend program has been split into several 
executables grouped by similarity of the output language.

rlgen-cd       C and D code
rlgen-dot      Graphviz
rlgen-java     Java (experimental)
rlgen-ruby     Ruby (new, experimental)

Also remember that when generating code the correct frontend language 
option must be given. The dot file generator does not care what language 
you are using.

The release is out, enjoy!

-Adrian


From zeds... at zedshaw.com  Wed Feb 14 09:42:37 2007
From: zeds... at zedshaw.com (Zed A. Shaw)
Date: Wed, 14 Feb 2007 01:42:37 -0800
Subject: [ragel-users] new backend executable names in 5.18
In-Reply-To: <45D260D3.6080508@cs.queensu.ca>
References: <45D260D3.6080508@cs.queensu.ca>
Message-ID: <20070214014237.185fd8ec.zedshaw@zedshaw.com>

On Tue, 13 Feb 2007 20:07:31 -0500
Adrian Thurston <thurs... at cs.queensu.ca> wrote:

> 
> Hi,
> 
> In version 5.18 the backend program has been split into several 
> executables grouped by similarity of the output language.
<snip> 
> rlgen-ruby     Ruby (new, experimental)

Man, Ruby code to play with, but the docs are ultra thin on this.  Any
samples I can steal from?

Also, the rlgen-ruby binary calls itself rlgen-java, FYI.

Otherwise, dying to play with this in Mongrel and RFuzz.

-- 
Zed A. Shaw, MUDCRAP-CE Master Black Belt Sifu
http://www.zedshaw.com/
http://www.awprofessional.com/title/0321483502 -- The Mongrel Book
http://mongrel.rubyforge.org/
http://www.lingr.com/room/3yXhqKbfPy8 -- Come get help.


From michael.dai... at gmail.com  Thu Feb 22 05:08:50 2007
From: michael.dai... at gmail.com (mdaines)
Date: Wed, 21 Feb 2007 21:08:50 -0800
Subject: new backend executable names in 5.18
In-Reply-To: <45D260D3.6080508@cs.queensu.ca>
References: <45D260D3.6080508@cs.queensu.ca>
Message-ID: <1172120930.838688.120190@j27g2000cwj.googlegroups.com>

> rlgen-ruby     Ruby (new, experimental)

I too would like to see some samples.

When will we see rlgen-javascript? I'm only half kidding, though I
think I see parsing going on in JavaScript sometimes that seems like
maybe it could benefit? Plus, I am leaning toward thinking such a
thing could be useful to me, maybe. Maybe fiddling around with that is
a good leisure-time way to learn about this whole subject and about
how Ragel is implemented...


From jason2... at jasonjobe.com  Sat Feb 24 04:08:35 2007
From: jason2... at jasonjobe.com (Jason)
Date: Fri, 23 Feb 2007 20:08:35 -0800
Subject: selecting a starting state or how to serialize a machine
Message-ID: <1172290115.150566.229860@v33g2000cwv.googlegroups.com>

I am finding more uses for ragel all the time :-)
Now I am experimenting with using a ragel to model work flow logic.
For example, a document has an associated state, approved, rejected,
pending, etc. So I want to load the document and "post" events that
will drive the document status to new states, triggering actions
along
the way.

So the question is: How do I tell a ragel machine I want to start at
a
particular point (where it left off before)?

Do I just archive the entire machine variables (fixing up pointers of
course)?

thanks,
Jason


From skkib... at earthlink.net  Sun Feb 25 03:19:24 2007
From: skkib... at earthlink.net (skk)
Date: Sat, 24 Feb 2007 19:19:24 -0800
Subject: selecting a starting state or how to serialize a machine
In-Reply-To: <1172290115.150566.229860@v33g2000cwv.googlegroups.com>
References: <1172290115.150566.229860@v33g2000cwv.googlegroups.com>
Message-ID: <1172373564.738689.178450@v33g2000cwv.googlegroups.com>

What I have done with a text editor in a windows control is build the
initial state machine so things transition through the basic states as
required.  I validate this machine first.  Then I build in transitions
from the start state into the internal states with the input that
represents the current state.  In the text editor, build the machine
to handle the cursor movement, character insert, delete, insert/
overwright, skip mask characters and so on.  When entering the machine
I then create a transition from the initial state into the internal
states after computing the current state of the cursor.  The current
state of the cursor can be far left/right, insert/overwright, valid
character to the left/right/both, etc.  This is encoded into an
integer (all input is in integers, not characters) and is fed in as
the first character thus putting me exactly where I want to be for the
next keyboard input character (integer).  This is necessary because
the user may have moved the text cursor with the mouse and the last
state I was in is not valid any more.

On Feb 23, 9:08 pm, "Jason" <jason2... at jasonjobe.com> wrote:
> I am finding more uses for ragel all the time :-)
> Now I am experimenting with using a ragel to model work flow logic.
> For example, a document has an associated state, approved, rejected,
> pending, etc. So I want to load the document and "post" events that
> will drive the document status to new states, triggering actions
> along
> the way.
>
> So the question is: How do I tell a ragel machine I want to start at
> a
> particular point (where it left off before)?
>
> Do I just archive the entire machine variables (fixing up pointers of
> course)?
>
> thanks,
> Jason


From jason2... at jasonjobe.com  Tue Feb 27 19:40:42 2007
From: jason2... at jasonjobe.com (Jason)
Date: Tue, 27 Feb 2007 11:40:42 -0800
Subject: token buffer not correct
Message-ID: <1172605242.835835.194270@8g2000cwh.googlegroups.com>

BTW, this is pull scanner.

Essentially I see a possible problem / bug in 2 areas. One is the
return value of a single character. Specifically in the enclosed
example TK_Char should be return the int value of the char matched
(e.g. '{') but it isn't.

The second involves the *non* advancement of the token / data pointer
illustrated below. The digraph value, "<:" appears at the beginning of
the output of the following token TK_TEXT.

My input is this

(app MyApp

	New: (
		User.Submit.Application: (
			>> Submitted
			<: {#<xml> pre_action </xml>#}
			:>  { (one) }
		)
	)
)

The problem tokens are printed thusly

	parser: TK_PRE(271):6 "<:"
	parser: TK_TEXT(266):6 "<: {#<xml> pre_action </xml>#}"

The excerpted rule is

			# Consume text delimited by <xml> ... </xml>
			xml  := (any_count_line* -- "</xml>") :>> "</xml>"
			@{
				/* Save p and pe. fbreak does not advance p. */
				s->token = TK_XML;
				s->token_name = "TK_XML";

				s->p = p + 1;
				s->pe = pe;
				s->len = s->p - s->data;
				return TK_XML;
			};

I've tried a number of things with the grammar to no avail. So I don't
know if this a problem with ragel or my spec.

Any pointers would be most appreciated.

many thanks,
Jason

---------------------------- Full .rl
----------------------------------------------------------------------
#include "reader_s.h"

#ifndef SCOPE
#define SCOPE
#endif


%%{
	machine Scanner;
	write data;
}%%


SCOPE void scan_init_buf( Scanner *s, char *buf )
{
	memset (s, '\0', sizeof(Scanner));
	s->curline = 1;
	s->buf = buf;
	s->p = s->buf;
	%%{ write init; }%%
}

SCOPE void scan_finalize( Scanner *s )
{
}

#define ret_tok( _tok ) token = _tok; s->token = _tok; s->data = s-
>tokstart; s->token_name = #_tok
#define ret_char( _tok ) token = _tok; s->token = *s->tokstart; s-
>data = s->tokstart; s->token_name = "TK_Char"

SCOPE int scan( Scanner *s )
{
	char *p = s->p;
	char *pe = s->pe;
	int token = TK_NO_TOKEN;

	while ( 1 ) {

		%%{
			machine Scanner;
			access s->;

			newline = '\n' @{s->curline += 1;};
			any_count_line = any | newline;

			# Consume a C comment.
			c_comment := any_count_line* :>> '*/' @{fgoto main;};

			# Consume text delimited by <xml> ... </xml>
			xml  := (any_count_line* -- "</xml>") :>> "</xml>"
			@{
				/* Save p and pe. fbreak does not advance p. */
				s->token = TK_XML;
				s->token_name = "TK_XML";

				s->p = p + 1;
				s->pe = pe;
				s->len = s->p - s->data;
				return TK_XML;
			};

			text_block := (any_count_line* -- '#}') :>> '#}'
			@{
				/* Save p and pe. fbreak does not advance p. */
				s->token = TK_TEXT;
				s->token_name = "TK_TEXT";

				s->p = p + 1;
				s->pe = pe;
				s->len = s->p - s->data;
				return TK_XML;
			};

			main := |*

			newline;

			# Alpha numberic characters or underscore.
			alnum_u = alnum | '_';

			# Alpha charactres or underscore.
			alpha_u = alpha | '_';

			ident = alpha_u alnum_u*;

			# Identifiers
			ident =>
				{ ret_tok( TK_Identifier ); fbreak; };

			# Keypath
			keypath = ident ('.' ident)*;
			keypath => { ret_tok( TK_Keypath ); fbreak; };

			# Keywords
			ident ':' => {
				ret_tok (TK_Keyword); fbreak;
			};

			keypath ':' => {
				ret_tok (TK_Keyword); fbreak;
			};

			# Strings and Text
			"'" ( [^'\\] | /\\./ )* "'" => { ret_tok (TK_String); fbreak; };
			'"' ( [^"\\] | /\\./ )* '"' => { ret_tok (TK_String); fbreak; };

			"<xml>" { fgoto xml; };
			'{#' 	{ fgoto text_block; };

			# Special Digraphs
			">>" @ { ret_tok (TK_SHIFT_RT); fbreak; };
			"<<" @ { ret_tok (TK_SHIFT_LT); fbreak; };
			":>" @ { ret_tok (TK_POST); fbreak; };
			"<:" @ { ret_tok (TK_PRE); fbreak; };

			"<=" => { ret_tok (TK_LE); fbreak; };
			">=" => { ret_tok (TK_GE); fbreak; };
			"!=" => { ret_tok (TK_NE); fbreak; };

			"++" => { ret_tok (TK_Increment); fbreak; };
			"--" => { ret_tok (TK_Decrement); fbreak; };

			# Whitespace
			[ \t\n];

	# Numbers
	digit+ => {
		ret_tok (TK_Integer); fbreak;
	};

	digit+'.' digit+ => {
		ret_tok (TK_Real); fbreak;
	};

	digit{1,3} (',' digit{3})+ => { ret_tok (TK_Integer); fbreak; };

	digit{1,3} (',' digit{3})+ '.' digit+ => { ret_tok (TK_Real);
fbreak; };

	'0x' xdigit+ => { ret_tok (TK_Hex); fbreak; };

        # Describe both c style comments and c++ style comments. The
        # priority bump on tne terminator of the comments brings us
        # out of the extend* which matches everything.
        '//' [^\n]* newline;

	'/*' { fgoto c_comment; };


			# EOF
			0 =>
				{ ret_tok( TK_EOF ); fbreak; };

			# Anything else
			any =>
				{ ret_char( *p ); fbreak; };

			*|;

			write exec;
		}%%

		if ( s->cs == Scanner_error )
			return TK_ERR;

		if ( token != TK_NO_TOKEN ) {
			/* Save p and pe. fbreak does not advance p. */
			s->p = p + 1;
			s->pe = pe;
			s->len = s->p - s->data;
			s->token = token;
			return token;
		}
	}
}

#ifdef TEST

#include <stdlib.h>
#include <stdio.h>
#include <string.h>


void output(Scanner *ss)
{
	int tok;

	while ( 1 ) {
		tok = scan (ss);
		if ( tok == TK_EOF ) {
			printf ("parser: EOF\n");
			break;
		}
		else if ( tok == TK_ERR ) {
			printf ("parser: ERR\n");
			break;
		}
		else {
			printf ("parser: %s(%d):%d \"", ss->token_name, tok, ss->curline);
			fwrite ( ss->data, 1, ss->len, stdout );
			printf ("\"\n" );
		}
	}
}

#define BUFSIZE 4096

int main (int argc, char** argv)
{
	Scanner ss;
   	char buf[BUFSIZE];

	int len = fread ( buf, sizeof(char), BUFSIZE, stdin );
	buf[len] = '\0';
	scan_init_buf (&ss, buf);

//	char *input = "(do with:1,345.99 and: \"some string\")";
//	scan_init_buf(&ss, input);

	output (&ss);
	scan_finalize (&ss);

	return 0;
}

#endif


From jason2... at jasonjobe.com  Wed Feb 28 03:21:23 2007
From: jason2... at jasonjobe.com (Jason)
Date: Tue, 27 Feb 2007 19:21:23 -0800
Subject: reflection of the machine
Message-ID: <1172632883.572593.173920@s48g2000cws.googlegroups.com>

Is it possible to get a representation of the machine to enable the
following:

1) Get a string name or representation of a machine, labeled node, and
action.

2) Provide defined constants for named nodes.

Is it possible to initialize a machine to a state other than the
defined starting point?

-jason


From icib... at gmail.com  Fri Feb  2 22:07:05 2007
From: icib... at gmail.com (Ivan Cibiri)
Date: Fri, 02 Feb 2007 14:07:05 -0800
Subject: rlcodegen: parse error
Message-ID: <1170454025.547257.93190@a75g2000cwd.googlegroups.com>

I uploaded file Sample.rl
When I run following commands, I get error:

ragel -D -o Sample.xml Sample.rl
rlcodegen -o Sample.d Sample.xm
Sample.xml:145:30: parse error

Any idea what is going wrong?

Ivan


From thurs... at cs.queensu.ca  Fri Feb  2 23:41:54 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Fri, 02 Feb 2007 18:41:54 -0500
Subject: [ragel-users] rlcodegen: parse error
In-Reply-To: <1170454025.547257.93190@a75g2000cwd.googlegroups.com>
References: <1170454025.547257.93190@a75g2000cwd.googlegroups.com>
Message-ID: <45C3CC42.90703@cs.queensu.ca>

Hi Ivan,

Sample.rl fails for me at the frontend because it contains CR characters and
I am on linux. The new parser is not treating them as whitespace as it
should. So I fixed this, but then the XML file that is generated works okay
for me. I'm not sure if my fix to the frontend will fix your problem in the
backend though. Could you post the XML file that gives you trouble?

Regards,
 Adrian

Ivan Cibiri wrote:
> I uploaded file Sample.rl
> When I run following commands, I get error:
> 
> ragel -D -o Sample.xml Sample.rl
> rlcodegen -o Sample.d Sample.xm
> Sample.xml:145:30: parse error
> 
> Any idea what is going wrong?
> 
> Ivan
> 
> 
> 


From icib... at gmail.com  Sat Feb  3 06:27:13 2007
From: icib... at gmail.com (Ivan Cibiri)
Date: Sat, 03 Feb 2007 06:27:13 -0000
Subject: rlcodegen: parse error
In-Reply-To: <45C3CC42.90703@cs.queensu.ca>
References: <1170454025.547257.93190@a75g2000cwd.googlegroups.com>
   <45C3CC42.90703@cs.queensu.ca>
Message-ID: <1170484033.268822.319350@k78g2000cwa.googlegroups.com>

Hi Adrian,

sample.zip contains: Sample.rl Sample.xml and out.txt.

ragel -D -o Sample.xml Sample.rl

rlcodegen -o Sample.d Sample.xml
Sample.xml:139:2: parse error

Kind regards,
Ivan

> Could you post the XML file that gives you trouble?
>
> Regards,
>  Adrian
>


From thurs... at cs.queensu.ca  Sat Feb  3 16:49:06 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Sat, 03 Feb 2007 11:49:06 -0500
Subject: [ragel-users] Re: rlcodegen: parse error
In-Reply-To: <1170484033.268822.319350@k78g2000cwa.googlegroups.com>
References: <1170454025.547257.93190@a75g2000cwd.googlegroups.com> <45C3CC42.90703@cs.queensu.ca> <1170484033.268822.319350@k78g2000cwa.googlegroups.com>
Message-ID: <45C4BD02.2030109@cs.queensu.ca>

Hi,

I'm not able to reproduce the error. Can you confirm for me that
both executables are version 5.17. Also, what kind of system are you on 
and how was was Ragel compiled?

Thanks
  Adrian

Ivan Cibiri wrote:
> Hi Adrian,
> 
> sample.zip contains: Sample.rl Sample.xml and out.txt.
> 
> ragel -D -o Sample.xml Sample.rl
> 
> rlcodegen -o Sample.d Sample.xml
> Sample.xml:139:2: parse error
> 
> Kind regards,
> Ivan
> 
>> Could you post the XML file that gives you trouble?
>>
>> Regards,
>>  Adrian
>>
> 
> 
> 


From icib... at gmail.com  Sat Feb  3 17:54:14 2007
From: icib... at gmail.com (Ivan Cibiri)
Date: Sat, 3 Feb 2007 18:54:14 +0100
Subject: [ragel-users] Re: rlcodegen: parse error
In-Reply-To: <45C4BD02.2030109@cs.queensu.ca>
References: <1170454025.547257.93190@a75g2000cwd.googlegroups.com>
	 <45C3CC42.90703@cs.queensu.ca>
	 <1170484033.268822.319350@k78g2000cwa.googlegroups.com>
	 <45C4BD02.2030109@cs.queensu.ca>
Message-ID: <aed7ed7e0702030954m3c2c172dw59174d55802d2c3b@mail.gmail.com>

Hi,

Hi,

Both executables are from
http://www.cs.queensu.ca/~thurston/ragel/ragel-5.17-w32bin.zip , downloaded
2.2.2007.

I am running Windows XP Pro SP2 and all fixes.

Ivan.

On 2/3/07, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
>
>
> Hi,
>
> I'm not able to reproduce the error. Can you confirm for me that
> both executables are version 5.17. Also, what kind of system are you on
> and how was was Ragel compiled?
>
> Thanks
>   Adrian
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.colm.net/pipermail/ragel-users/attachments/20070203/fb41105d/attachment-0001.html>

From icib... at gmail.com  Sat Feb  3 19:54:03 2007
From: icib... at gmail.com (Ivan Cibiri)
Date: Sat, 03 Feb 2007 19:54:03 -0000
Subject: rlcodegen: parse error
In-Reply-To: <aed7ed7e0702030954m3c2c172dw59174d55802d2c3b@mail.gmail.com>
References: <1170454025.547257.93190@a75g2000cwd.googlegroups.com>
   <45C3CC42.90703@cs.queensu.ca>
   <1170484033.268822.319350@k78g2000cwa.googlegroups.com>
   <45C4BD02.2030109@cs.queensu.ca>
   <aed7ed7e0702030954m3c2c172dw59174d55802d2c3b@mail.gmail.com>
Message-ID: <1170532443.134840.265070@l53g2000cwa.googlegroups.com>

Hi,

When I use binaries from http://www.cs.queensu.ca/~thurston/ragel/ragel-5.17-w32ntv.zip
, everything seems fine. There is no syntax error.

Ivan.

On Feb 3, 6:54 pm, "Ivan Cibiri" <icib... at gmail.com> wrote:
> Hi,
>
> Hi,
>
> Both executables are fromhttp://www.cs.queensu.ca/~thurston/ragel/ragel-5.17-w32bin.zip, downloaded
> 2.2.2007.
>
> I am running Windows XP Pro SP2 and all fixes.
>
> Ivan.
>
> On 2/3/07, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
>
>
>
> > Hi,
>
> > I'm not able to reproduce the error. Can you confirm for me that
> > both executables are version 5.17. Also, what kind of system are you on
> > and how was was Ragel compiled?
>
> > Thanks
> >   Adrian


From thurs... at cs.queensu.ca  Sun Feb  4 17:46:40 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Sun, 04 Feb 2007 12:46:40 -0500
Subject: [ragel-users] Re: rlcodegen: parse error
In-Reply-To: <1170532443.134840.265070@l53g2000cwa.googlegroups.com>
References: <1170454025.547257.93190@a75g2000cwd.googlegroups.com> <45C3CC42.90703@cs.queensu.ca> <1170484033.268822.319350@k78g2000cwa.googlegroups.com> <45C4BD02.2030109@cs.queensu.ca> <aed7ed7e0702030954m3c2c172dw59174d55802d2c3b@mail.gmail.com> <1170532443.134840.265070@l53g2000cwa.googlegroups.com>
Message-ID: <45C61C00.4070709@cs.queensu.ca>

Hi Ivan,

Thanks for your information. I was able to reproduce the problem, but 
not debug it since I am using a cross compiler (MinGW). A sprinkling of 
print statements didn't seem to give me any insight. For now I will take 
down the binaries produced by MinGW. This is not the first time I've had 
trouble getting working Win32 binaries using it.

So for now, Win32 options are:

1. Native binaries contributed by Josef Goettgens
2. Compiling on Windows using Cygwin.

Thanks,
  Adrian

Ivan Cibiri wrote:
> Hi,
> 
> When I use binaries from http://www.cs.queensu.ca/~thurston/ragel/ragel-5.17-w32ntv.zip
> , everything seems fine. There is no syntax error.
> 
> Ivan.
> 
> On Feb 3, 6:54 pm, "Ivan Cibiri" <icib... at gmail.com> wrote:
>> Hi,
>>
>> Hi,
>>
>> Both executables are fromhttp://www.cs.queensu.ca/~thurston/ragel/ragel-5.17-w32bin.zip, downloaded
>> 2.2.2007.
>>
>> I am running Windows XP Pro SP2 and all fixes.
>>
>> Ivan.
>>
>> On 2/3/07, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
>>
>>
>>
>>> Hi,
>>> I'm not able to reproduce the error. Can you confirm for me that
>>> both executables are version 5.17. Also, what kind of system are you on
>>> and how was was Ragel compiled?
>>> Thanks
>>>   Adrian
> 
> 
> 


From jason2... at jasonjobe.com  Mon Feb  5 17:51:18 2007
From: jason2... at jasonjobe.com (Jason)
Date: Mon, 05 Feb 2007 09:51:18 -0800
Subject: can't pull parse strings - BUG?
Message-ID: <1170697878.145251.186030@a75g2000cwd.googlegroups.com>

I've finally gotten a little time to start working with the new
pullscan example.

Everything was going well until I tried to add string tokens. The rl
(below) works as is but un-comment the String rules and all hell
breaks loose.

Any pointers would be most welcome.

---      TEST input file -------
[target go: 124 with:(1..9) num:1,298,99 int:87 float:1,299.987]

(list "some string")
(list 'some other string')

-------------- mod_pullscan.rl ------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BUFSIZE 4096

typedef struct _Scanner {
	/* Scanner state. */
    int cs;
    int act;
    int have;
    int curline;
    char *tokstart;
    char *tokend;
    char *p;
    char *pe;
	FILE *file;
	int done;

	/* Token data */
	char *data;
	int len;
    int value;
	char *token_name;
	char buf[BUFSIZE];
} Scanner;


void scan_init( Scanner *s, FILE *file )
{
	memset (s, '\0', sizeof(Scanner));
	s->curline = 1;
	s->file = file;
}

#define TK_NO_TOKEN (-1)
#define TK_ERR 128
#define TK_EOF 129
#define TK_Identifier 130
#define TK_Number 131
#define TK_Keyword 132
#define TK_String 133


%%{
	machine Scanner;
	write data;
}%%

#define ret_tok( _tok ) token = _tok; s->data = s->tokstart; s-
>token_name = #_tok
#define ret_char( _tok ) token = _tok; s->data = s->tokstart; s-
>token_name = "TK_Char"

int scan( Scanner *s )
{
	char *p = s->p;
	char *pe = s->pe;
	int token = TK_NO_TOKEN;
	int space, readlen;

	while ( 1 ) {
		if ( p == pe ) {
			printf("scanner: need more data\n");

			if ( s->tokstart == 0 )
				s->have = 0;
			else {
				/* There is data that needs to be shifted over. */
				printf("scanner: buffer broken mid token\n");
				s->have = pe - s->tokstart;
				memmove( s->buf, s->tokstart, s->have );
				s->tokend -= (s->tokstart-s->buf);
				s->tokstart = s->buf;
			}

			p = s->buf + s->have;
			space = BUFSIZE - s->have;

			if ( space == 0 ) {
				/* We filled up the buffer trying to scan a token. */
				printf("scanner: out of buffer space\n");
				return TK_ERR;
			}

			if ( s->done ) {
				printf("scanner: end of file\n");
				p[0] = 0;
				readlen = 1;
			}
			else {
				readlen = fread( p, 1, space, s->file );
				if ( readlen < space )
					s->done = 1;
			}

			pe = p + readlen;
		}

		%%{
			machine Scanner;
			access s->;

			newline = '\n' @{s->curline += 1;};
			any_count_line = any | newline;

			main := |*

			# Alpha numberic characters or underscore.
			alnum_u = alnum | '_';

			# Alpha charactres or underscore.
			alpha_u = alpha | '_';

			ident = alpha_u alnum_u*;

			# Identifiers
			ident =>
				{ ret_tok( TK_Identifier ); fbreak; };

			# Keywords
			ident ':' => {
				ret_tok (TK_Keyword); fbreak;
			};

	# Strings
#			"'" ( [^'\\] | /\\./ )* "'" => { ret_tok (TK_String); };
#			'"' ( [^"\\] | /\\./ )* '"' => { ret_tok (TK_String); };

			# Whitespace
			[ \t\n];

			# Number
			digit+ =>
				{ ret_tok( TK_Number ); fbreak; };

			# EOF
			0 =>
				{ ret_tok( TK_EOF ); fbreak; };

			# Anything else
			any =>
				{ ret_char( *p ); fbreak; };

			*|;

			write exec;
		}%%

		if ( s->cs == Scanner_error )
			return TK_ERR;

		if ( token != TK_NO_TOKEN ) {
			/* Save p and pe. fbreak does not advance p. */
			s->p = p + 1;
			s->pe = pe;
			s->len = s->p - s->data;
			return token;
		}
	}
}


int main (int argc, char** argv)
{
	Scanner ss;
	int tok;

	scan_init(&ss, stdin);

	while ( 1 ) {
		tok = scan (&ss);
		if ( tok == TK_EOF ) {
			printf ("parser: EOF\n");
			break;
		}
		else if ( tok == TK_ERR ) {
			printf ("parser: ERR\n");
			break;
		}
		else {
			printf ("parser: %s(%d) \"", ss.token_name, tok);
			fwrite ( ss.data, 1, ss.len, stdout );
			printf ("\"\n" );
		}
	}

	return 0;
}


From thurs... at cs.queensu.ca  Mon Feb  5 18:25:54 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Mon, 05 Feb 2007 13:25:54 -0500
Subject: [ragel-users] can't pull parse strings - BUG?
In-Reply-To: <1170697878.145251.186030@a75g2000cwd.googlegroups.com>
References: <1170697878.145251.186030@a75g2000cwd.googlegroups.com>
Message-ID: <45C776B2.4010206@cs.queensu.ca>

Ahhh, sorry this example is broken. It's missing a %% write init; in the
init function. Move the write data up, add the init and also add fbreaks
after your ret_tok(TK_String) and your troubles should go away.

Note that it worked before adding in the strings because it was just chance
that the start state had id 0.

-Adrian

Jason wrote:
> I've finally gotten a little time to start working with the new
> pullscan example.
> 
> Everything was going well until I tried to add string tokens. The rl
> (below) works as is but un-comment the String rules and all hell
> breaks loose.
> 
> Any pointers would be most welcome.
> 
> ---      TEST input file -------
> [target go: 124 with:(1..9) num:1,298,99 int:87 float:1,299.987]
> 
> (list "some string")
> (list 'some other string')
> 
> -------------- mod_pullscan.rl ------------
> #include <stdio.h>
> #include <stdlib.h>
> #include <string.h>
> 
> #define BUFSIZE 4096
> 
> typedef struct _Scanner {
> 	/* Scanner state. */
>     int cs;
>     int act;
>     int have;
>     int curline;
>     char *tokstart;
>     char *tokend;
>     char *p;
>     char *pe;
> 	FILE *file;
> 	int done;
> 
> 	/* Token data */
> 	char *data;
> 	int len;
>     int value;
> 	char *token_name;
> 	char buf[BUFSIZE];
> } Scanner;
> 
> 
> void scan_init( Scanner *s, FILE *file )
> {
> 	memset (s, '\0', sizeof(Scanner));
> 	s->curline = 1;
> 	s->file = file;
> }
> 
> #define TK_NO_TOKEN (-1)
> #define TK_ERR 128
> #define TK_EOF 129
> #define TK_Identifier 130
> #define TK_Number 131
> #define TK_Keyword 132
> #define TK_String 133
> 
> 
> %%{
> 	machine Scanner;
> 	write data;
> }%%
> 
> #define ret_tok( _tok ) token = _tok; s->data = s->tokstart; s-
>> token_name = #_tok
> #define ret_char( _tok ) token = _tok; s->data = s->tokstart; s-
>> token_name = "TK_Char"
> 
> int scan( Scanner *s )
> {
> 	char *p = s->p;
> 	char *pe = s->pe;
> 	int token = TK_NO_TOKEN;
> 	int space, readlen;
> 
> 	while ( 1 ) {
> 		if ( p == pe ) {
> 			printf("scanner: need more data\n");
> 
> 			if ( s->tokstart == 0 )
> 				s->have = 0;
> 			else {
> 				/* There is data that needs to be shifted over. */
> 				printf("scanner: buffer broken mid token\n");
> 				s->have = pe - s->tokstart;
> 				memmove( s->buf, s->tokstart, s->have );
> 				s->tokend -= (s->tokstart-s->buf);
> 				s->tokstart = s->buf;
> 			}
> 
> 			p = s->buf + s->have;
> 			space = BUFSIZE - s->have;
> 
> 			if ( space == 0 ) {
> 				/* We filled up the buffer trying to scan a token. */
> 				printf("scanner: out of buffer space\n");
> 				return TK_ERR;
> 			}
> 
> 			if ( s->done ) {
> 				printf("scanner: end of file\n");
> 				p[0] = 0;
> 				readlen = 1;
> 			}
> 			else {
> 				readlen = fread( p, 1, space, s->file );
> 				if ( readlen < space )
> 					s->done = 1;
> 			}
> 
> 			pe = p + readlen;
> 		}
> 
> 		%%{
> 			machine Scanner;
> 			access s->;
> 
> 			newline = '\n' @{s->curline += 1;};
> 			any_count_line = any | newline;
> 
> 			main := |*
> 
> 			# Alpha numberic characters or underscore.
> 			alnum_u = alnum | '_';
> 
> 			# Alpha charactres or underscore.
> 			alpha_u = alpha | '_';
> 
> 			ident = alpha_u alnum_u*;
> 
> 			# Identifiers
> 			ident =>
> 				{ ret_tok( TK_Identifier ); fbreak; };
> 
> 			# Keywords
> 			ident ':' => {
> 				ret_tok (TK_Keyword); fbreak;
> 			};
> 
> 	# Strings
> #			"'" ( [^'\\] | /\\./ )* "'" => { ret_tok (TK_String); };
> #			'"' ( [^"\\] | /\\./ )* '"' => { ret_tok (TK_String); };
> 
> 			# Whitespace
> 			[ \t\n];
> 
> 			# Number
> 			digit+ =>
> 				{ ret_tok( TK_Number ); fbreak; };
> 
> 			# EOF
> 			0 =>
> 				{ ret_tok( TK_EOF ); fbreak; };
> 
> 			# Anything else
> 			any =>
> 				{ ret_char( *p ); fbreak; };
> 
> 			*|;
> 
> 			write exec;
> 		}%%
> 
> 		if ( s->cs == Scanner_error )
> 			return TK_ERR;
> 
> 		if ( token != TK_NO_TOKEN ) {
> 			/* Save p and pe. fbreak does not advance p. */
> 			s->p = p + 1;
> 			s->pe = pe;
> 			s->len = s->p - s->data;
> 			return token;
> 		}
> 	}
> }
> 
> 
> int main (int argc, char** argv)
> {
> 	Scanner ss;
> 	int tok;
> 
> 	scan_init(&ss, stdin);
> 
> 	while ( 1 ) {
> 		tok = scan (&ss);
> 		if ( tok == TK_EOF ) {
> 			printf ("parser: EOF\n");
> 			break;
> 		}
> 		else if ( tok == TK_ERR ) {
> 			printf ("parser: ERR\n");
> 			break;
> 		}
> 		else {
> 			printf ("parser: %s(%d) \"", ss.token_name, tok);
> 			fwrite ( ss.data, 1, ss.len, stdout );
> 			printf ("\"\n" );
> 		}
> 	}
> 
> 	return 0;
> }
> 
> 
> 


From jason2... at jasonjobe.com  Mon Feb  5 18:51:18 2007
From: jason2... at jasonjobe.com (Jason)
Date: Mon, 05 Feb 2007 10:51:18 -0800
Subject: can't pull parse strings - BUG?
In-Reply-To: <45C776B2.4010206@cs.queensu.ca>
References: <1170697878.145251.186030@a75g2000cwd.googlegroups.com>
   <45C776B2.4010206@cs.queensu.ca>
Message-ID: <1170701478.988422.11130@a75g2000cwd.googlegroups.com>

Great! Strings now work.

However :-(

I added in rules to distinguish between integers and floats (reals).

	# Numbers
	digit+ => {
		ret_tok (TK_Integer); fbreak;
	};

	digit+'.' digit+ => {
		ret_tok (TK_Real); fbreak;
	};

Those were OK but I also want to recognize numbers separated by commas
(e.g. 1,299 and 1,299.987).

So I added these rules

	digit{1,3} (',' digit{3})+ {
		ret_tok (TK_Integer); fbreak;
	};
and
	digit{1,3} (',' digit{3})+ '.' digit+ {
		ret_tok (TK_Real); fbreak;
	};

But this reports the following error:

ragel pullscan.rl | rlcodegen -G2 -o pullscan.c
gcc -pedantic -Wall -O3 -g -c -o pullscan.o pullscan.c
pullscan.rl: In function 'scan':
pullscan.rl:1: error: 'act' undeclared (first use in this function)
pullscan.rl:1: error: (Each undeclared identifier is reported only
once
pullscan.rl:1: error: for each function it appears in.)
make: *** [pullscan.o] Error 1

Any ideas?

thanks,
Jason


From thurs... at cs.queensu.ca  Mon Feb  5 19:24:27 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Mon, 05 Feb 2007 14:24:27 -0500
Subject: [ragel-users] Re: can't pull parse strings - BUG?
In-Reply-To: <1170701478.988422.11130@a75g2000cwd.googlegroups.com>
References: <1170697878.145251.186030@a75g2000cwd.googlegroups.com> <45C776B2.4010206@cs.queensu.ca> <1170701478.988422.11130@a75g2000cwd.googlegroups.com>
Message-ID: <45C7846B.8060207@cs.queensu.ca>

Hi,

The variable "act" is needed by scanners when they must backtrack to the
last matched rule and the rule cannot be determined statically. You can just
add "int act;" alongside tokstart et al. Section 2.7 of the manual will help
you out.

Cheers,
 Adrian

Jason wrote:
> Great! Strings now work.
> 
> However :-(
> 
> I added in rules to distinguish between integers and floats (reals).
> 
> 	# Numbers
> 	digit+ => {
> 		ret_tok (TK_Integer); fbreak;
> 	};
> 
> 	digit+'.' digit+ => {
> 		ret_tok (TK_Real); fbreak;
> 	};
> 
> Those were OK but I also want to recognize numbers separated by commas
> (e.g. 1,299 and 1,299.987).
> 
> So I added these rules
> 
> 	digit{1,3} (',' digit{3})+ {
> 		ret_tok (TK_Integer); fbreak;
> 	};
> and
> 	digit{1,3} (',' digit{3})+ '.' digit+ {
> 		ret_tok (TK_Real); fbreak;
> 	};
> 
> But this reports the following error:
> 
> ragel pullscan.rl | rlcodegen -G2 -o pullscan.c
> gcc -pedantic -Wall -O3 -g -c -o pullscan.o pullscan.c
> pullscan.rl: In function 'scan':
> pullscan.rl:1: error: 'act' undeclared (first use in this function)
> pullscan.rl:1: error: (Each undeclared identifier is reported only
> once
> pullscan.rl:1: error: for each function it appears in.)
> make: *** [pullscan.o] Error 1
> 
> Any ideas?
> 
> thanks,
> Jason
> 
> 
> 


From jason2... at jasonjobe.com  Mon Feb  5 19:43:50 2007
From: jason2... at jasonjobe.com (Jason)
Date: Mon, 05 Feb 2007 11:43:50 -0800
Subject: can't pull parse strings - BUG?
In-Reply-To: <45C7846B.8060207@cs.queensu.ca>
References: <1170697878.145251.186030@a75g2000cwd.googlegroups.com>
   <45C776B2.4010206@cs.queensu.ca>
   <1170701478.988422.11130@a75g2000cwd.googlegroups.com>
   <45C7846B.8060207@cs.queensu.ca>
Message-ID: <1170704630.316602.144290@a75g2000cwd.googlegroups.com>

Adrian,

I think I found a bug, then. Note that "int act" is already declared
in our example.

In looking through the generated code I found several uses of "s->act"
but I also found it missing in the switch.

I hope this helpful.

cheers,
Jason


#line 1 "pullscan.rl"
	{	switch( act ) {
	case 6:
	{
		ret_tok (TK_Integer); {{p = (( s->tokend))-1;}goto _out14;}
	}
	break;
	case 8:
	{ ret_tok (TK_Integer); {{p = (( s->tokend))-1;}goto _out14;} }
	break;
	default: break;
	}
	{p = (( s->tokend))-1;}}
	goto st14;
st14:


From thurs... at cs.queensu.ca  Mon Feb  5 20:46:27 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Mon, 5 Feb 2007 15:46:27 -0500 (EST)
Subject: [ragel-users] Re: can't pull parse strings - BUG?
In-Reply-To: <1170704630.316602.144290@a75g2000cwd.googlegroups.com>
References: <1170697878.145251.186030@a75g2000cwd.googlegroups.com>
    <45C776B2.4010206@cs.queensu.ca>
    <1170701478.988422.11130@a75g2000cwd.googlegroups.com>
    <45C7846B.8060207@cs.queensu.ca>
    <1170704630.316602.144290@a75g2000cwd.googlegroups.com>
Message-ID: <55079.130.15.15.124.1170708387.squirrel@mambo.cs.queensu.ca>

Indeed, that is a bug. The act variable should be referenced in the same
way througout the generated code. Thanks!

-Adrian


>
> Adrian,
>
> I think I found a bug, then. Note that "int act" is already declared
> in our example.
>
> In looking through the generated code I found several uses of "s->act"
> but I also found it missing in the switch.
>
> I hope this helpful.
>
> cheers,
> Jason
>
>
> #line 1 "pullscan.rl"
> 	{	switch( act ) {
> 	case 6:
> 	{
> 		ret_tok (TK_Integer); {{p = (( s->tokend))-1;}goto _out14;}
> 	}
> 	break;
> 	case 8:
> 	{ ret_tok (TK_Integer); {{p = (( s->tokend))-1;}goto _out14;} }
> 	break;
> 	default: break;
> 	}
> 	{p = (( s->tokend))-1;}}
> 	goto st14;
> st14:
>
>
> >



From la... at laramies.com  Wed Feb  7 21:41:09 2007
From: la... at laramies.com (Arne Goedeke)
Date: Wed, 07 Feb 2007 13:41:09 -0800
Subject: json parser in ragel
Message-ID: <1170884469.176493.125530@v45g2000cwv.googlegroups.com>

Hello!

i somewhat finished my json parser in ragel and would like to put it
here for public discussion ,). also, thanks to you adrian for the cool
software.
the source-code is a little hard to read because it is full of ifdefs
and glue to the pike api (i use the parser as a module in pike). in
the first one i wrote i build my own stack to do the recursive parsing
but found this solution much better due to its simplicity. here is the
link:

http://laramies.com/ragel/json/

arne


From thurs... at cs.queensu.ca  Wed Feb  7 23:23:34 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Wed, 07 Feb 2007 18:23:34 -0500
Subject: [ragel-users] json parser in ragel
In-Reply-To: <1170884469.176493.125530@v45g2000cwv.googlegroups.com>
References: <1170884469.176493.125530@v45g2000cwv.googlegroups.com>
Message-ID: <45CA5F76.4040904@cs.queensu.ca>

Hello Arne,

This style of parser, where you implement recursive structures by 
calling parsing functions, is something that I imagined you could with 
ragel, but I never actually tried it out. It's nice to see that it can 
work. Thanks for sharing it!

Question for you: If you had a dynamically-sized stack for fcall/fret 
would you have used that mechanism? Or would you still have prefered to 
separate the parser out into different functions?

Cheers,
  Adrian

Arne Goedeke wrote:
> Hello!
> 
> i somewhat finished my json parser in ragel and would like to put it
> here for public discussion ,). also, thanks to you adrian for the cool
> software.
> the source-code is a little hard to read because it is full of ifdefs
> and glue to the pike api (i use the parser as a module in pike). in
> the first one i wrote i build my own stack to do the recursive parsing
> but found this solution much better due to its simplicity. here is the
> link:
> 
> http://laramies.com/ragel/json/
> 
> arne
> 
> 
> 


From la... at laramies.com  Thu Feb  8 10:43:11 2007
From: la... at laramies.com (Arne Goedeke)
Date: Thu, 08 Feb 2007 02:43:11 -0800
Subject: json parser in ragel
In-Reply-To: <45CA5F76.4040904@cs.queensu.ca>
References: <1170884469.176493.125530@v45g2000cwv.googlegroups.com>
   <45CA5F76.4040904@cs.queensu.ca>
Message-ID: <1170931391.948687.70830@v45g2000cwv.googlegroups.com>


On Feb 8, 12:23 am, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
> Question for you: If you had a dynamically-sized stack for fcall/fret
> would you have used that mechanism? Or would you still have prefered to
> separate the parser out into different functions?

Well, I probably would in case I do not need to create recursive data
structures along the way to store all things I already parsed. Not
sure, maybe the dynamically sized stack could keep arbitrary data too.

arne


From la... at laramies.com  Thu Feb  8 22:48:24 2007
From: la... at laramies.com (Arne Goedeke)
Date: Thu, 08 Feb 2007 14:48:24 -0800
Subject: making \n, \t etc printable
Message-ID: <1170974904.959480.139950@s48g2000cws.googlegroups.com>

hey!

I thought it would be nice for most people to have \n, \t and such
being printed out by rlcodegen -Vp using backslash escapes. here is my
patch:

--- common/common.h	2007-01-21 23:58:22.000000000 +0100
+++ common/common.h	2007-02-08 23:24:29.000000000 +0100
@@ -60,7 +60,11 @@

 	bool isUpper() const { return ( 'A' <= key && key <= 'Z' ); }
 	bool isLower() const { return ( 'a' <= key && key <= 'z' ); }
-	bool isPrintable() const { return ( 32 <= key && key < 127 ); }
+	bool isPrintable() const
+	{
+	    return ( 32 <= key && key < 127 ) || key == '\b' || key == '\t'
+		    || key == '\n' || key == '\f' || key == '\r';
+	}

 	Key toUpper() const
 		{ return Key( 'A' + ( key - 'a' ) ); }
--- rlcodegen/gvdotgen.cpp	2007-01-21 23:58:22.000000000 +0100
+++ rlcodegen/gvdotgen.cpp	2007-02-08 23:24:36.000000000 +0100
@@ -47,6 +47,21 @@
 			case '"': case '\\':
 				out << "\\" << cVal;
 				break;
+			case '\n':
+				out << "\\\\n";
+				break;
+			case '\t':
+				out << "\\\\t";
+				break;
+			case '\r':
+				out << "\\\\r";
+				break;
+			case '\b':
+				out << "\\\\b";
+				break;
+			case '\f':
+				out << "\\\\f";
+				break;
 			default:
 				out << cVal;
 				break;


From thurs... at cs.queensu.ca  Fri Feb  9 04:39:24 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Thu, 08 Feb 2007 23:39:24 -0500
Subject: [ragel-users] making \n, \t etc printable
In-Reply-To: <1170974904.959480.139950@s48g2000cws.googlegroups.com>
References: <1170974904.959480.139950@s48g2000cws.googlegroups.com>
Message-ID: <45CBFAFC.7060909@cs.queensu.ca>

Thanks, I applied it and added \a and \v.

One other character I'd like to change is 32. Printing it as ' ' looks a 
little strange sometimes. I'm thinking of changing it to SP instead.

-Adrian

Arne Goedeke wrote:
> hey!
> 
> I thought it would be nice for most people to have \n, \t and such
> being printed out by rlcodegen -Vp using backslash escapes. here is my
> patch:
> 
> --- common/common.h	2007-01-21 23:58:22.000000000 +0100
> +++ common/common.h	2007-02-08 23:24:29.000000000 +0100
> @@ -60,7 +60,11 @@
> 
>  	bool isUpper() const { return ( 'A' <= key && key <= 'Z' ); }
>  	bool isLower() const { return ( 'a' <= key && key <= 'z' ); }
> -	bool isPrintable() const { return ( 32 <= key && key < 127 ); }
> +	bool isPrintable() const
> +	{
> +	    return ( 32 <= key && key < 127 ) || key == '\b' || key == '\t'
> +		    || key == '\n' || key == '\f' || key == '\r';
> +	}
> 
>  	Key toUpper() const
>  		{ return Key( 'A' + ( key - 'a' ) ); }
> --- rlcodegen/gvdotgen.cpp	2007-01-21 23:58:22.000000000 +0100
> +++ rlcodegen/gvdotgen.cpp	2007-02-08 23:24:36.000000000 +0100
> @@ -47,6 +47,21 @@
>  			case '"': case '\\':
>  				out << "\\" << cVal;
>  				break;
> +			case '\n':
> +				out << "\\\\n";
> +				break;
> +			case '\t':
> +				out << "\\\\t";
> +				break;
> +			case '\r':
> +				out << "\\\\r";
> +				break;
> +			case '\b':
> +				out << "\\\\b";
> +				break;
> +			case '\f':
> +				out << "\\\\f";
> +				break;
>  			default:
>  				out << cVal;
>  				break;
> 
> 
> 


From er... at atlasocean.com  Fri Feb  9 06:01:51 2007
From: er... at atlasocean.com (Erich Ocean)
Date: Thu, 8 Feb 2007 22:01:51 -0800
Subject: How to execute a % action only when a zero-length match/accept occurs.
Message-ID: <6711A787-4EFC-4DC8-AB38-3A16AAF5DE6B@atlasocean.com>

Suppose we had the following machine:

%%{
machine test;

action FIRST {}
# Executed on recognition of the first character

action MATCH {}
# Executed on each character that puts the machine in a match state

action ACCEPT {}
# Executed when the machine accepts a match

main:= ( lower* >FIRST @MATCH %ACCEPT )? . ' ';
}%%

and we wanted the exact same machine, but with the ACCEPT action  
split into two:
- ACCEPT_AFTER_ZERO_LENGTH_MATCH_ONLY
- ACCEPT_AFTER_CHAR_MATCH_ONLY

Here's one way to do that in Ragel:

%%{
machine test;

action FIRST {}
# Executed on recognition of the first character

action MATCH {}
# Executed on each character that put the original machine in a match  
state

action ACCEPT_AFTER_CHAR_MATCH_ONLY {}
# Executed when the machine above accepted a match without  
recognizing any character

action ACCEPT_AFTER_ZERO_LENGTH_MATCH_ONLY {}
# Executed when the machine above accepted a match after recognizing  
a character

main := ( ('' %ACCEPT_AFTER_ZERO_LENGTH_MATCH_ONLY) | (lower+ >FIRST  
@MATCH %ACCEPT_AFTER_CHAR_MATCH_ONLY) ) . ' ';
}%%

The generated finite state machines are identical; only the actions  
executed are different. Notice that the Kleene star operator on lower  
has been changed to the one-or-more (+) operator.


From gdani... at gmail.com  Sun Feb  4 19:59:05 2007
From: gdani... at gmail.com (Greg)
Date: Sun, 04 Feb 2007 19:59:05 -0000
Subject: Next project using Ragel
Message-ID: <1170619145.522704.60670@q2g2000cwa.googlegroups.com>

Hello,

First of all I would like to thank Adrian Thurston for his tool. I am
using Ragel in my FdAjax module implementation for Lighttpd web
server. Using Ragel for parameters parsing instead of pure C code
makes the module much more secure. Keep up a good work.

Grzegorz Daniluk


From thurs... at cs.queensu.ca  Tue Feb  6 01:37:17 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Mon, 05 Feb 2007 20:37:17 -0500
Subject: [ragel-users] Next project using Ragel
In-Reply-To: <1170619145.522704.60670@q2g2000cwa.googlegroups.com>
References: <1170619145.522704.60670@q2g2000cwa.googlegroups.com>
Message-ID: <45C7DBCD.5020508@cs.queensu.ca>

That's great to hear! Thanks for sharing your use of Ragel with us. Is 
there a homepage for this project?

Regards,
  Adrian

Greg wrote:
> Hello,
> 
> First of all I would like to thank Adrian Thurston for his tool. I am
> using Ragel in my FdAjax module implementation for Lighttpd web
> server. Using Ragel for parameters parsing instead of pure C code
> makes the module much more secure. Keep up a good work.
> 
> Grzegorz Daniluk
> 
> 
> 


From gdani... at gmail.com  Fri Feb  9 09:30:31 2007
From: gdani... at gmail.com (Greg)
Date: Fri, 09 Feb 2007 01:30:31 -0800
Subject: Next project using Ragel
In-Reply-To: <45C7DBCD.5020508@cs.queensu.ca>
References: <1170619145.522704.60670@q2g2000cwa.googlegroups.com>
   <45C7DBCD.5020508@cs.queensu.ca>
Message-ID: <1171013431.329785.222340@m58g2000cwm.googlegroups.com>

> That's great to hear! Thanks for sharing your use of Ragel with us. Is
> there a homepage for this project?

I've posted two messages about FdAjax module in company blog. But the
simple homepage for it will be ready in 2 or 3 weeks.

During my CS course I learned flex and bison but Ragel interface to a
C program is much more convenient. It seems that easy integration with
host program is the key to success.

Regards,
Grzegorz Daniluk


From s... at mattmower.com  Fri Feb  9 09:51:48 2007
From: s... at mattmower.com (Matt Mower)
Date: Fri, 9 Feb 2007 09:51:48 +0000
Subject: [ragel-users] Re: Next project using Ragel
In-Reply-To: <1171013431.329785.222340@m58g2000cwm.googlegroups.com>
References: <1170619145.522704.60670@q2g2000cwa.googlegroups.com>
	 <45C7DBCD.5020508@cs.queensu.ca>
	 <1171013431.329785.222340@m58g2000cwm.googlegroups.com>
Message-ID: <d56373190702090151r4973939btf5d8ffaf49a1f0e1@mail.gmail.com>

On 09/02/07, Greg <gdani... at gmail.com> wrote:
> During my CS course I learned flex and bison but Ragel interface to a
> C program is much more convenient. It seems that easy integration with
> host program is the key to success.
>

I would agree with that. Following Why's SuperRedCloth example I had a
Ragel based Ruby extension running in about 5 minutes. It doesn't *do*
much yet, but it works and what it does do works fast.

M

-- 
Matt Mower :: http://matt.blogs.it/


From er... at atlasocean.com  Thu Feb  8 21:44:46 2007
From: er... at atlasocean.com (onitunes)
Date: Thu, 08 Feb 2007 13:44:46 -0800
Subject: syntax improvement, new operators
Message-ID: <1170971086.967308.154390@p10g2000cwp.googlegroups.com>

Hi!

I've been working on an extensive Ragel tutorial for Ragel, RegEx, and
FSM newbies based on a full PDF parser I built with Ragel. Based on
that work, I believe that the current Ragel action embedding names can
be both improved conceptually by re-categorizing and re-naming them,
and that doing so exposes three other operators that are missing in
the re-categorization and that I personally would like to see added to
Ragel. I have suggested currently unused symbols for them.

I'm posting this to the group to get some discussion and feedaback on
the proposal. Here are the operators and their suggested names and
categories. The new operators are listed at the end of each group, and
should be obivous.

I've also included some notes on what the operators mean, and also
some usage notes. Developing this conceptual framework has greatly
aided my understanding of Ragel and hopefully will help others as
well. I have found that action embeddings are the most difficult
aspect of Ragel to learn, and believe this conceptual framework
improves the situation immensely.

Best, Erich

Character Actions
=============

> aka First -- This action will be executed on the first character the machine recognizes.
$ aka Each -- This action will be executed on each character the
machine recognizes.
@ aka Match -- This action will be executed on characters the machine
recognizes that puts the machine into a match state.
< aka Continue -- (New) This action will be executed on the next
character the machine recognizes when the machine is in a match state.

Multiple character actions can be executed on the recognition of a
single character. For example, both the First and Each action are
executed (in that order) after the machine recognizes the very first
character.

Ragel guarantees that character actions will always be executed in the
following sequence:

Character_Actions_Seq = First Each+ Match (Continue Each+ Match)*
Machine_Accept;

Machine Actions
============

% aka Accept -- This action will only be executed when the machine
accepts a match.
%\ aka Fail -- (New) This action will only be executed when the
machine fails to either: (a) recognize a character, or (b) accept a
match.
%? aka Skip -- (New) This action will be executed instead of Fail when
either the Optional operator or the Kleene Star operator is applied to
the machine.

A machine can execute its Fail or Skip action even if it has already
recognized one-or-more characters. Therefore, to avoid resource leaks
you should:
	(a) only acquire resources in your First and Each actions that will
be cleaned up by your Fail or Skip action, and/or
	(b) acquire and release resources in your Match and Continue actions,
respectively.
The latter is usually the best choice if its an option.


From er... at atlasocean.com  Thu Feb  8 21:59:09 2007
From: er... at atlasocean.com (onitunes)
Date: Thu, 08 Feb 2007 13:59:09 -0800
Subject: syntax improvement, new operators
In-Reply-To: <1170971086.967308.154390@p10g2000cwp.googlegroups.com>
References: <1170971086.967308.154390@p10g2000cwp.googlegroups.com>
Message-ID: <1170971949.680711.134500@j27g2000cwj.googlegroups.com>

I want to add that a major motivation for the new actions is to
eliminate bugs caused by a misunderstanding of the Optional and Kleene
Star operators. Without the new actions, it's difficult to write
properly write code with Ragel that handles resource acquisition and
release. You *can* do it without the new operators by setting and
clearing external state flags, but that is error prone and requires
complex explanations of why it is necessary in the first place. Since
Ragel already has the knowledge to execute the new actions at the
correct places, I believe Ragel should provide the actions to users
directly instead of forcing us to maintain our own state flags
externally.

Best, Erich Ocean


From thurs... at cs.queensu.ca  Fri Feb  9 03:48:01 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Thu, 08 Feb 2007 22:48:01 -0500
Subject: [ragel-users] syntax improvement, new operators
In-Reply-To: <1170971086.967308.154390@p10g2000cwp.googlegroups.com>
References: <1170971086.967308.154390@p10g2000cwp.googlegroups.com>
Message-ID: <45CBEEF1.2060205@cs.queensu.ca>

Hi Erich,

I'm glad to see you are still working with Ragel! By the way, I've 
updated your name in the CREDITS file and elsewhere.

> Character Actions
> =============
> 
> > aka First -- This action will be executed on the first character the machine recognizes.
> $ aka Each -- This action will be executed on each character the
> machine recognizes.
> @ aka Match -- This action will be executed on characters the machine
> recognizes that puts the machine into a match state.
> < aka Continue -- (New) This action will be executed on the next
> character the machine recognizes when the machine is in a match state.

So it seems that you prefer to express these operators in terms of the 
characters of the input string that is processed. This is distinct from 
my approach, where I talk about the transitions of a regular 
expression's corresponding state machine.

I prefer to express the operators in terms of transitions because I find 
it to be very precise. For example, with "entering transition actions" 
you can go and look at the graphviz drawing and find the transitions 
which take you into the machine. That's me though, and I would very much 
like to hear what others think. Is it better to talk about the 
transitions that the actions are put into, or is better to talk about 
the characters that are moved over when the actions are executed?

The < operator you have given I find interesting. As I understand it, 
this would embed the action on the transitions which leave final states 
(but stay in the machine). Could you give an example of when it is useful?


> Machine Actions
> ============
> 
> % aka Accept -- This action will only be executed when the machine
> accepts a match.

The word "accept" I find to be somewhat ambiguous. It doesn't strike me 
that it means only one of "on the last character" or "on the next 
character." It seems to me that it could easily be interpreted as either 
of those. I chose the word "leaving" for this operator because it's 
clear to me that it means on the next character.

> %\ aka Fail -- (New) This action will only be executed when the
> machine fails to either: (a) recognize a character, or (b) accept a
> match.

I'm not quite sure what you mean with (b). I would assume you mean the 
same as above, what is currently known as the leaving (or pending out) 
operator. But then I believe this new operator would be the same as the 
$! operator. Could you clarify?

> %? aka Skip -- (New) This action will be executed instead of Fail when
> either the Optional operator or the Kleene Star operator is applied to
> the machine.

I'm not sure I understand this operator. If you write:

( expr %? skip_act )?

Is it the same as writing the following?

( expr | "" %skip_act )

Could you give us an example of the kind of problem that motivated these 
operators? Especially the part about setting and clearing external state 
flags to do proper resource acquisition and release. An example would 
really help me to understand the issue.

Regards,
  Adrian


From er... at atlasocean.com  Fri Feb  9 04:40:11 2007
From: er... at atlasocean.com (Erich Ocean)
Date: Thu, 8 Feb 2007 20:40:11 -0800
Subject: [ragel-users] Re: syntax improvement, new operators
In-Reply-To: <45CBEEF1.2060205@cs.queensu.ca>
References: <1170971086.967308.154390@p10g2000cwp.googlegroups.com> <45CBEEF1.2060205@cs.queensu.ca>
Message-ID: <E8234DE2-5DA3-48AD-9FDF-F978D48EC0BA@atlasocean.com>

Well, take the first User Action example in the Ragel manual on page  
28: 3.1.1 Entering Action:

action A {}
main := ( lower* >A ) .  ;

Let's modify it to add a Pending Out (Leaving) Action, and then make  
that machine optional:

action ENTER_TRANSITION {} # Entering Action
action LEAVE_TRANSITION {} # Pending Out (Leaving) Action

main := ( lower* >ENTER_TRANSITION %LEAVE_TRANSITION )? . ' ';

If the first character recognized by main happens to be a space, then  
LEAVE will be executed, but ENTER won't.

I think it's confusing to a user that a machine will execute its  
Leaving action (to use your terminology) without first executing its  
Entering.

The confusion goes away if you've learned that the > action will only  
be executed on the first character.

The % action isn't a character action, it's a machine action (to use  
my terminology). So a user would naturally reason that it could be  
executed even though no character was recognized, as is this case:

action FIRST_CHAR {} # Executed on recognition of the first character
action MACHINE_ACCEPT {} # Executed when the machine accepts a match

main := ( lower* >FIRST_CHAR %MACHINE_ACCEPT )? . ' ';

I use the Match/Accept terminology because any given machine can make  
a whole bunch of matches while it's recognizing characters, and the @  
action is executed every single time the machine recognizes a match.  
The % action, on the other hand, is only executed when the machine  
finally accepts one of those matches. The @ action (Match) is a  
character action because it is always and only triggered upon the  
recognition of a character, whereas the Accept action is a machine  
action because is only ever executed once, when the machine accepts a  
match, regardless of whether or not a character has been recognized.  
It's character-independent.

Hope this explains some of the reasoning behind the categorization  
and new terminology.

Best, Erich

On Feb 8, 2007, at 7:48 PM, Adrian Thurston wrote:

>
> Hi Erich,
>
> I'm glad to see you are still working with Ragel! By the way, I've
> updated your name in the CREDITS file and elsewhere.
>
>> Character Actions
>> =============
>>
>>> aka First -- This action will be executed on the first character  
>>> the machine recognizes.
>> $ aka Each -- This action will be executed on each character the
>> machine recognizes.
>> @ aka Match -- This action will be executed on characters the machine
>> recognizes that puts the machine into a match state.
>> < aka Continue -- (New) This action will be executed on the next
>> character the machine recognizes when the machine is in a match  
>> state.
>
> So it seems that you prefer to express these operators in terms of the
> characters of the input string that is processed. This is distinct  
> from
> my approach, where I talk about the transitions of a regular
> expression's corresponding state machine.
>
> I prefer to express the operators in terms of transitions because I  
> find
> it to be very precise. For example, with "entering transition actions"
> you can go and look at the graphviz drawing and find the transitions
> which take you into the machine. That's me though, and I would very  
> much
> like to hear what others think. Is it better to talk about the
> transitions that the actions are put into, or is better to talk about
> the characters that are moved over when the actions are executed?
>
> The < operator you have given I find interesting. As I understand it,
> this would embed the action on the transitions which leave final  
> states
> (but stay in the machine). Could you give an example of when it is  
> useful?
>
>
>> Machine Actions
>> ============
>>
>> % aka Accept -- This action will only be executed when the machine
>> accepts a match.
>
> The word "accept" I find to be somewhat ambiguous. It doesn't  
> strike me
> that it means only one of "on the last character" or "on the next
> character." It seems to me that it could easily be interpreted as  
> either
> of those. I chose the word "leaving" for this operator because it's
> clear to me that it means on the next character.
>
>> %\ aka Fail -- (New) This action will only be executed when the
>> machine fails to either: (a) recognize a character, or (b) accept a
>> match.
>
> I'm not quite sure what you mean with (b). I would assume you mean the
> same as above, what is currently known as the leaving (or pending out)
> operator. But then I believe this new operator would be the same as  
> the
> $! operator. Could you clarify?
>
>> %? aka Skip -- (New) This action will be executed instead of Fail  
>> when
>> either the Optional operator or the Kleene Star operator is  
>> applied to
>> the machine.
>
> I'm not sure I understand this operator. If you write:
>
> ( expr %? skip_act )?
>
> Is it the same as writing the following?
>
> ( expr | "" %skip_act )
>
> Could you give us an example of the kind of problem that motivated  
> these
> operators? Especially the part about setting and clearing external  
> state
> flags to do proper resource acquisition and release. An example would
> really help me to understand the issue.
>
> Regards,
>   Adrian
>
>
> >


From thurs... at cs.queensu.ca  Fri Feb  9 05:37:42 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Fri, 09 Feb 2007 00:37:42 -0500
Subject: [ragel-users] Re: syntax improvement, new operators
In-Reply-To: <E8234DE2-5DA3-48AD-9FDF-F978D48EC0BA@atlasocean.com>
References: <1170971086.967308.154390@p10g2000cwp.googlegroups.com> <45CBEEF1.2060205@cs.queensu.ca> <E8234DE2-5DA3-48AD-9FDF-F978D48EC0BA@atlasocean.com>
Message-ID: <45CC08A6.9080409@cs.queensu.ca>

Prior to version 4.0, the entering action operator actually did exactly 
what you describe. If the machine's start state was final, then it also 
embedded the action into the start state as a leaving action. Initially 
I thought this was very intuitive, however over time I gradually took 
the opinion that all operators should have a single purpose. This makes 
things more predictable. See the V4 release notes for more details.

If you would like to achieve the same effect from 3.X and prior you can 
do this:

main := ( "" %ENTER | lower* >ENTER %LEAVE ) . ' ';

Some point in the future I hope to add some kind of higher order 
notation which allows one to wrap these things up into user-defined 
functions.

> The % action, on the other hand, is only executed when the machine  
> finally accepts one of those matches. The @ action (Match) is a  
> character action because it is always and only triggered upon the  
> recognition of a character, whereas the Accept action is a machine  
> action because is only ever executed once, when the machine accepts a  
> match, regardless of whether or not a character has been recognized.  
> It's character-independent.

Note that the % operator requires a character to follow. If no character 
follows then nothing is executed.

Regards,
  Adrian

> 
> Hope this explains some of the reasoning behind the categorization  
> and new terminology.
> 
> Best, Erich
> 
> On Feb 8, 2007, at 7:48 PM, Adrian Thurston wrote:
> 
>> Hi Erich,
>>
>> I'm glad to see you are still working with Ragel! By the way, I've
>> updated your name in the CREDITS file and elsewhere.
>>
>>> Character Actions
>>> =============
>>>
>>>> aka First -- This action will be executed on the first character  
>>>> the machine recognizes.
>>> $ aka Each -- This action will be executed on each character the
>>> machine recognizes.
>>> @ aka Match -- This action will be executed on characters the machine
>>> recognizes that puts the machine into a match state.
>>> < aka Continue -- (New) This action will be executed on the next
>>> character the machine recognizes when the machine is in a match  
>>> state.
>> So it seems that you prefer to express these operators in terms of the
>> characters of the input string that is processed. This is distinct  
>> from
>> my approach, where I talk about the transitions of a regular
>> expression's corresponding state machine.
>>
>> I prefer to express the operators in terms of transitions because I  
>> find
>> it to be very precise. For example, with "entering transition actions"
>> you can go and look at the graphviz drawing and find the transitions
>> which take you into the machine. That's me though, and I would very  
>> much
>> like to hear what others think. Is it better to talk about the
>> transitions that the actions are put into, or is better to talk about
>> the characters that are moved over when the actions are executed?
>>
>> The < operator you have given I find interesting. As I understand it,
>> this would embed the action on the transitions which leave final  
>> states
>> (but stay in the machine). Could you give an example of when it is  
>> useful?
>>
>>
>>> Machine Actions
>>> ============
>>>
>>> % aka Accept -- This action will only be executed when the machine
>>> accepts a match.
>> The word "accept" I find to be somewhat ambiguous. It doesn't  
>> strike me
>> that it means only one of "on the last character" or "on the next
>> character." It seems to me that it could easily be interpreted as  
>> either
>> of those. I chose the word "leaving" for this operator because it's
>> clear to me that it means on the next character.
>>
>>> %\ aka Fail -- (New) This action will only be executed when the
>>> machine fails to either: (a) recognize a character, or (b) accept a
>>> match.
>> I'm not quite sure what you mean with (b). I would assume you mean the
>> same as above, what is currently known as the leaving (or pending out)
>> operator. But then I believe this new operator would be the same as  
>> the
>> $! operator. Could you clarify?
>>
>>> %? aka Skip -- (New) This action will be executed instead of Fail  
>>> when
>>> either the Optional operator or the Kleene Star operator is  
>>> applied to
>>> the machine.
>> I'm not sure I understand this operator. If you write:
>>
>> ( expr %? skip_act )?
>>
>> Is it the same as writing the following?
>>
>> ( expr | "" %skip_act )
>>
>> Could you give us an example of the kind of problem that motivated  
>> these
>> operators? Especially the part about setting and clearing external  
>> state
>> flags to do proper resource acquisition and release. An example would
>> really help me to understand the issue.
>>
>> Regards,
>>   Adrian
>>
>>
> 
> 
> 


From er... at atlasocean.com  Fri Feb  9 06:00:31 2007
From: er... at atlasocean.com (Erich Ocean)
Date: Thu, 8 Feb 2007 22:00:31 -0800
Subject: [ragel-users] Re: syntax improvement, new operators
In-Reply-To: <45CC08A6.9080409@cs.queensu.ca>
References: <1170971086.967308.154390@p10g2000cwp.googlegroups.com> <45CBEEF1.2060205@cs.queensu.ca> <E8234DE2-5DA3-48AD-9FDF-F978D48EC0BA@atlasocean.com> <45CC08A6.9080409@cs.queensu.ca>
Message-ID: <18CF6DD1-0A91-45CF-AD9A-968EB5EB9F40@atlasocean.com>

I find how the current action operators work intuitive, it's the  
*naming* that I find unintuitive. (Perhaps that should have been  
changed along with the behavior change in 4.0.)

It might be worthwhile to add a new machine-level action operator  
that was always executed before any other action was executed by the  
machine (we could call it Start), though I don't have any ready use  
for one.

Best, Erich


From thurs... at cs.queensu.ca  Sat Feb 10 18:09:54 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Sat, 10 Feb 2007 13:09:54 -0500
Subject: [ragel-users] Re: syntax improvement, new operators
In-Reply-To: <18CF6DD1-0A91-45CF-AD9A-968EB5EB9F40@atlasocean.com>
References: <1170971086.967308.154390@p10g2000cwp.googlegroups.com> <45CBEEF1.2060205@cs.queensu.ca> <E8234DE2-5DA3-48AD-9FDF-F978D48EC0BA@atlasocean.com> <45CC08A6.9080409@cs.queensu.ca> <18CF6DD1-0A91-45CF-AD9A-968EB5EB9F40@atlasocean.com>
Message-ID: <45CE0A72.9@cs.queensu.ca>

Hi Erich,

Entering actions are always executed before any other actions which have 
been previously embedded in the machine. In this example sub is 
evaluated and all its actions are embedded. Then the first action is 
embedded, but it goes to the front of any action list it is put in 
because it is a starting action.

action a1 {}
action a2 {}
action first {}

sub = ( 'a' 'b'* ) >a1 $a2;
main := sub >first;

Regards,
  Adrian

Erich Ocean wrote:
> I find how the current action operators work intuitive, it's the  
> *naming* that I find unintuitive. (Perhaps that should have been  
> changed along with the behavior change in 4.0.)
> 
> It might be worthwhile to add a new machine-level action operator  
> that was always executed before any other action was executed by the  
> machine (we could call it Start), though I don't have any ready use  
> for one.
> 
> Best, Erich
> 
> 


From er... at atlasocean.com  Sat Feb 10 18:29:31 2007
From: er... at atlasocean.com (Erich Ocean)
Date: Sat, 10 Feb 2007 10:29:31 -0800
Subject: [ragel-users] Re: syntax improvement, new operators
In-Reply-To: <45CE0A72.9@cs.queensu.ca>
References: <1170971086.967308.154390@p10g2000cwp.googlegroups.com> <45CBEEF1.2060205@cs.queensu.ca> <E8234DE2-5DA3-48AD-9FDF-F978D48EC0BA@atlasocean.com> <45CC08A6.9080409@cs.queensu.ca> <18CF6DD1-0A91-45CF-AD9A-968EB5EB9F40@atlasocean.com> <45CE0A72.9@cs.queensu.ca>
Message-ID: <63A8E26C-B473-4F59-8FCE-A2AE8B31107F@atlasocean.com>

action a1 {}
action a2 {}
action skippable {}
action not_skippable {}

sub = ( 'a' 'b'* ) >a1 $a2;
main := (sub? >skippable %not_skippable) . 'c';

If 'skippable' was a machine-level Start action, it would always be  
executed before %not_skippable, whereas the character-level > action  
is only executed if a character happens to be recognized by 'sub'  
prior to accepting.

A machine-level 'Start' action would be symmetric with % in all  
cases. > is not symmetric with %; it's closest symmetry is @ (at  
least it's always guaranteed to be executed before @ in the same  
machine).

Best, Erich

On Feb 10, 2007, at 10:09 AM, Adrian Thurston wrote:

>
> Hi Erich,
>
> Entering actions are always executed before any other actions which  
> have
> been previously embedded in the machine. In this example sub is
> evaluated and all its actions are embedded. Then the first action is
> embedded, but it goes to the front of any action list it is put in
> because it is a starting action.
>
> action a1 {}
> action a2 {}
> action first {}
>
> sub = ( 'a' 'b'* ) >a1 $a2;
> main := sub >first;
>
> Regards,
>   Adrian
>
> Erich Ocean wrote:
>> I find how the current action operators work intuitive, it's the
>> *naming* that I find unintuitive. (Perhaps that should have been
>> changed along with the behavior change in 4.0.)
>>
>> It might be worthwhile to add a new machine-level action operator
>> that was always executed before any other action was executed by the
>> machine (we could call it Start), though I don't have any ready use
>> for one.
>>
>> Best, Erich
>>
>>
>
> >


From stephenhorne... at aol.com  Tue Feb 13 09:48:12 2007
From: stephenhorne... at aol.com (Steve Horne)
Date: Tue, 13 Feb 2007 01:48:12 -0800
Subject: Some Ragel Ideas
Message-ID: <1171360092.851311.131520@p10g2000cwp.googlegroups.com>

Is this an appropriate place to discuss Kelbt?

Also, here's a few Ragel extension ideas - none are things I need ATM
(barring perhaps the third one), just nice ideas.

First off, could Ragel be extended to handle tail recursion? Direct
tail recursion would be sufficient. Indirect tail recursion even
better, but I imagine quite difficult.

For example, consider the following...

main := case1 main? | case2 main | case3 | case4;

This can be translated to a non-recursive form, of course, giving...

main := (case1 | case2)* (case1 | case3 | case4);

But depending on the context, the tail recursive form may be clearer
and better describe the intent, or may be closer to the way the
requirements are specified. Note, for example, that the recursive
spec. only references each 'case' once, whereas the non-recursive
version mentions 'case1' twice (in the loop, and as a possible
terminator).

Second, how about an equivalence assertion operator?

The idea here is that two different specifications of a machine could
represent two 'theories' of how it would work. If the two theories
give different results, display an error message.

In combination with the recursion support, for instance, this would
allow the same machine to be described both ways for readability and
validation purposes. Anyone trying to understand the machine could
read either specification.

Third, Ragel seems to have a lot of cryptic operators. For those of us
who will only be using it occasionally, it might be a bit more
friendly if the less standard/obvious ones were given explicitly named
equivalents. Perhaps something similar to...

  "{*" identifier args* "*}"

... could be treated as a kind of S-expression alternative form for
some operators (esp. action operators and guarded forms).

For actions, rather than nesting { and }, a separator might be
useful...

  {* on_enter action_name  *}
  {* on_enter : <action code>  *}

One idea I have in mind involves a kind of paranoid library, that
checks whether calls to it match the required protocol - a file
creation library that knows when the caller has misbehaved in such a
way that a corrupt file has been created.


From thurs... at cs.queensu.ca  Tue Feb 13 16:17:36 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Tue, 13 Feb 2007 11:17:36 -0500
Subject: [ragel-users] Some Ragel Ideas
In-Reply-To: <1171360092.851311.131520@p10g2000cwp.googlegroups.com>
References: <1171360092.851311.131520@p10g2000cwp.googlegroups.com>
Message-ID: <45D1E4A0.8010208@cs.queensu.ca>

Hi Steve,

> Is this an appropriate place to discuss Kelbt?

Perhaps email is better for now.

> First off, could Ragel be extended to handle tail recursion? Direct
> tail recursion would be sufficient. Indirect tail recursion even
> better, but I imagine quite difficult.

In terms of just purely regular languages .. yes, I would think it would 
be doable. I imagine rewriting of the parse trees would be the proper 
way to do it. However, there might be issues with regards to the 
extensions to the regular language model. The user currently relies on 
the parse tree structure to reason about the order of execution of 
multiple actions on a single transition. Also, the parse tree is very 
important when reasoning about ambiguities. Parse tree rewrites might 
make reasoning about these things harder.

> Second, how about an equivalence assertion operator?

Ragel deals strictly with constructing deterministic state machines 
(that sometimes backtrack). There are many advantages to adhering to 
this model. Generating logic that executes a machine more than once on 
an input or that prints messages is outside of the scope of ragel.

On the other hand, at the machine construction level you could use the 
intersection operator & in Ragel to check if two machines match the same 
set of strings. For example, if two machines are identical then

( m1 | m2 ) - ( m1 & m2 )

should be empty (anyone please correct me if I'm wrong). A person well 
versed in language theory results (not me) would probably point you in 
the right direction.

> Third, Ragel seems to have a lot of cryptic operators. For those of us
> who will only be using it occasionally, it might be a bit more
> friendly if the less standard/obvious ones were given explicitly named
> equivalents. Perhaps something similar to...

Agreed. The operators are cryptic. Over the years I've played with 
various verbose embedding forms. So far nothing promising has been found 
so I've left it out of the docs. My current idea might be the one though.

main := m1 <-embedding_name(action_name)

or

main := m1 <-embedding_name{code}

This would also support user-defined embedding types, which I think is a 
big win.

Regards,
  Adrian


From stephenhorne... at aol.com  Wed Feb 14 04:21:18 2007
From: stephenhorne... at aol.com (Steve Horne)
Date: Tue, 13 Feb 2007 20:21:18 -0800
Subject: Some Ragel Ideas
In-Reply-To: <45D1E4A0.8010208@cs.queensu.ca>
References: <1171360092.851311.131520@p10g2000cwp.googlegroups.com>
   <45D1E4A0.8010208@cs.queensu.ca>
Message-ID: <1171426878.995210.279310@k78g2000cwa.googlegroups.com>


> > First off, could Ragel be extended to handle tail recursion?

> The user currently relies on
> the parse tree structure to reason about the order of execution of
> multiple actions on a single transition. Also, the parse tree is very
> important when reasoning about ambiguities. Parse tree rewrites might
> make reasoning about these things harder.

Understood.

It should be possible to do this without a parse tree rewrite, though
- think of the recursion as a 'goto' rather than as a structured loop.

Any tail call results in a special annotation in the state model. When
this machine gets inserted into the appropriately named larger
machine, the annotations are detected and result in appropriate
epsilon -like transitions being added, linking back to the larger
machines start state. At least, I think that would work.

The most obvious problem is that you don't know whether a call is
indirectly tail-recursive or not at the point when you first compile
it. Resolving that would probably be a big problem, and in any case,
allowing it would make it difficult to detect and reject non-tail
recursion (raising the possibility of state model compilation failing
to terminate).

That's why I suggested that direct recursion (where legal tail
recursion can be accurately detected from the start) would be
sufficient.

An explicit 'this is recursive' operator might resolve these issues...

x := a b ~z;
y := c d x;
z := e f y;

In the definition of x, the '~' indicates both a forward reference to
'z', and that 'x' *must* be called from 'z' (the recursion is
compulsory). But that's yet another cryptic operator ;-)

The same thing could probably be done explicitly, using labels and
epsilon transitions, of course. Just not as neat.

It's still just an idea, though. I've probably been looking at Scheme
too much recently.

> > Second, how about an equivalence assertion operator?
>
> Ragel deals strictly with constructing deterministic state machines
> (that sometimes backtrack).

Equivalence would be tested as Ragel compiles the machine, and one of
the two equivalent models would then be discarded. The idea is
redundant definition with compile-time validation, not a run-time
mechanism.

Possibly pointless, though, and more difficult than I thought because
checking whether actions match would be a problem.

IOW it's a bit daft, on reflection.

> main := m1 <-embedding_name(action_name)
> main := m1 <-embedding_name{code}

This looks pretty good to me.

I'm a little confused about user-defined embedding types, though - how
would they be used?


From thurs... at cs.queensu.ca  Wed Feb 14 05:31:44 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Wed, 14 Feb 2007 00:31:44 -0500
Subject: [ragel-users] Re: Some Ragel Ideas
In-Reply-To: <1171426878.995210.279310@k78g2000cwa.googlegroups.com>
References: <1171360092.851311.131520@p10g2000cwp.googlegroups.com> <45D1E4A0.8010208@cs.queensu.ca> <1171426878.995210.279310@k78g2000cwa.googlegroups.com>
Message-ID: <45D29EC0.30002@cs.queensu.ca>

Hey Steve,

Steve Horne wrote:
> It should be possible to do this without a parse tree rewrite, though
> - think of the recursion as a 'goto' rather than as a structured loop.
> 
> Any tail call results in a special annotation in the state model. When
> this machine gets inserted into the appropriately named larger
> machine, the annotations are detected and result in appropriate
> epsilon -like transitions being added, linking back to the larger
> machines start state. At least, I think that would work.

Ah, I see. Yes I think that could work in Ragel. Indirect recursion 
could be made to work by traversing the machine definition stack upwards 
to search for currently active references "higher up" when the parse 
tree is interpreted.

> Equivalence would be tested as Ragel compiles the machine, and one of
> the two equivalent models would then be discarded. The idea is
> redundant definition with compile-time validation, not a run-time
> mechanism.

Yeah, that could also be made to work. Actions would pose an additional 
challenge, but I don't think they would prevent it from working. If 
you're serious about this talk to me off list and I can give you some 
pointers. The question is whether or not there would be enough of a 
benefit to justify working on it.

> I'm a little confused about user-defined embedding types, though - how
> would they be used?

I'm thinking like this;

embedding buffer_and_exec(m, a) { m >buf_clear $buf_append %a }

main = foo <-buffer_and_exec{ print buf; }

Regards,
  Adrian


From cpira... at gmail.com  Sun Feb 18 11:38:45 2007
From: cpira... at gmail.com (Chris Pirazzi)
Date: Sun, 18 Feb 2007 11:38:45 -0000
Subject: action ordering.  is this a bug?
Message-ID: <1171798725.471254.284590@k78g2000cwa.googlegroups.com>


Hi,

Ragel seems completely amazing and I am hoping I can use
it for my application.  I am just getting to understand Ragel
and in particular its rules about the order in which
actions are called, because this will be important for
my application.  I have ragel-5.18.

The PDF says:

"When it visits a parse tree node it assigns
timestamps to all starting action embeddings, recurses
on the parse tree, then assigns timestamps
to the remaining all, finishing, and leaving embeddings
in the order in which they appear."

However if I feed in this small (admittedly ambiguous) grammar:

%%{

machine small;
write data noerror;

bar = 'a' >{ printf(">bar\n"); } @{ printf("@bar\n"); }  $
{ printf("$bar\n"); }  %{ printf("%%bar\n"); };

barz = ( bar* ) >{ printf(">barz\n"); } @{ printf("@barz\n"); }  $
{ printf("$barz\n"); }  %{ printf("%%barz\n"); };

tbarz = barz . barz >{ printf(">tbarz\n"); } @{ printf("@tbarz\n"); }
${ printf("$tbarz\n"); }  %{ printf("%%tbarz\n"); };

main := ( tbarz 0 ) @{ fbreak; };

write init;
write exec noend;

}%%
}%%

and I execute this machine on the input "aaa<nul>", then I would
expect to see ">tbarz" first, but I don't.  The total output is:

>barz
>bar
@bar
$bar
@barz
$barz
%barz
>tbarz
@tbarz
$tbarz
%bar
>bar
@bar
$bar
@barz
$barz
%barz
>tbarz
>barz
@tbarz
$tbarz
%bar
>bar
@bar
$bar
@barz
$barz
%barz
>tbarz
>barz
@tbarz
$tbarz
%bar
%barz
%tbarz

The "problem" can also be seen from the compiled output of ragel
without producing any C code, in that the action table id=1
does not list action 8 first.

<ragel filename="small.rl" lang="C">
<ragel_def name="small">
  <alphtype>0</alphtype>
  <machine>
    <action_list length="13">
      <action id="0" line="7" col="12"><text> printf("&gt;bar\n"); </
text></action>
      <action id="1" line="7" col="35"><text> printf("@bar\n"); </
text></action>
      <action id="2" line="7" col="59"><text> printf("$bar\n"); </
text></action>
      <action id="3" line="7" col="83"><text> printf("%%bar\n"); </
text></action>
      <action id="4" line="9" col="18"><text> printf("&gt;barz\n"); </
text></action>
      <action id="5" line="9" col="42"><text> printf("@barz\n"); </
text></action>
      <action id="6" line="9" col="67"><text> printf("$barz\n"); </
text></action>
      <action id="7" line="9" col="92"><text> printf("%%barz\n"); </
text></action>
      <action id="8" line="11" col="22"><text> printf("&gt;tbarz\n");
</text></action>
      <action id="9" line="11" col="47"><text> printf("@tbarz\n"); </
text></action>
      <action id="10" line="11" col="73"><text> printf("$tbarz\n"); </
text></action>
      <action id="11" line="11" col="99"><text> printf("%%tbarz\n"); </
text></action>
      <action id="12" line="13" col="22"><text> </text><break></
break><text> </text></action>
    </action_list>
    <action_table_list length="4">
      <action_table id="0" length="3">7 11 12</action_table>
      <action_table id="1" length="10">4 0 1 2 5 6 7 8 9 10</
action_table>
      <action_table id="2" length="4">3 7 11 12</action_table>
      <action_table id="3" length="11">3 0 1 2 5 6 7 8 4 9 10</
action_table>
    </action_table_list>
    <start_state>1</start_state>
    <error_state>0</error_state>
    <state_list length="4">
      <state id="0">
      <trans_list length="0">
      </trans_list>
      </state>

      <state id="1">
      <trans_list length="2">
        <t>0 0 3 0</t>
        <t>97 97 2 1</t>
      </trans_list>
      </state>

      <state id="2">
      <trans_list length="2">
        <t>0 0 3 2</t>
        <t>97 97 2 3</t>
      </trans_list>
      </state>

      <state id="3" final="t">
      <trans_list length="0">
      </trans_list>
      </state>
    </state_list>
  </machine>
</ragel_def>
<host line="1" col="1">

</host>
<write def_name="small" line="5" col="1"><arg>data</arg><arg>noerror</
arg></write>
<write def_name="small" line="15" col="1"><arg>init</arg></write>
<write def_name="small" line="16" col="1"><arg>exec</arg><arg>noend</
arg></write>
<host line="18">

}</host>
<host line="20"></host>
</ragel>

Have I misunderstood the rules?

Is the behavior caused by the ambiguity of the grammar?

I will make a separate post on exactly what I'm hoping to do
with ragel, and why I am even showing an ambiguous grammar.

Thanks,

     - Chris Pirazzi


From stephenhorne... at aol.com  Sun Feb 18 23:29:53 2007
From: stephenhorne... at aol.com (Steve Horne)
Date: Sun, 18 Feb 2007 15:29:53 -0800
Subject: action ordering. is this a bug?
In-Reply-To: <1171798725.471254.284590@k78g2000cwa.googlegroups.com>
References: <1171798725.471254.284590@k78g2000cwa.googlegroups.com>
Message-ID: <1171841393.419705.12210@s48g2000cws.googlegroups.com>


I understand Adrian won't be around for a couple of weeks. I'm no
Ragel expert, but I'll make what I think is an educated guess and hope
someone sets both of us straight ;-)

> I would
> expect to see ">tbarz" first, but I don't.

>From what you are saying, I suspect you are confusing 'entering a
state' with 'entering a rule'.

Your 'tbarz' rule has a sequence of two instances of 'barz'. The first
'barz' will be recognised first. In a sense, this implies that the
recognition of the 'tbarz' rule has started - but the *state* where
'tbarz' has been fully recognised will not be entered until two
instances of 'barz' have been recognised.

Even entry actions aren't triggered at the start of a rule - they are
triggered on entry into the state where the rule has been fully
recognised. Basically, the recognition tends to find the smallest
building blocks first, progressing to larger building blocks later.

In general, entry actions *cannot* be triggered on (for instance) the
first character of a rule - you cannot know for sure which is the
right rule. Consider what happens when there are two alternatives, for
instance...

opt1 = a.b;
opt2 = a.c;
main = opt1 | opt2;

When the only input that has been examined is the 'a', you cannot tell
whether you have an opt1 or an opt2. Therefore you cannot choose the
correct entry action - this can only happen when you have also
examined the 'b' or 'c' and entered the state where either opt1 or
opt2 has been fully recognised.

> Is the behavior caused by the ambiguity of the grammar?

I don't think so. The finite state models generated by Ragel should be
fully deterministic unless the backtracking scanner syntax is used.
Ragel has disambiguating rules that it uses while compiling the state
model, using priority specifications and/or guarded operators, so you
will be getting the default (all priorities equal) disambiguations.


From cpira... at gmail.com  Mon Feb 19 07:31:18 2007
From: cpira... at gmail.com (Chris Pirazzi)
Date: Mon, 19 Feb 2007 07:31:18 -0000
Subject: action ordering. is this a bug?
In-Reply-To: <1171841393.419705.12210@s48g2000cws.googlegroups.com>
References: <1171798725.471254.284590@k78g2000cwa.googlegroups.com>
   <1171841393.419705.12210@s48g2000cws.googlegroups.com>
Message-ID: <1171870278.925001.61140@q2g2000cwa.googlegroups.com>


On Feb 18, 11:29 pm, "Steve Horne" <stephenhorne... at aol.com> wrote:
> I understand Adrian won't be around for a couple of weeks. I'm no
> Ragel expert, but I'll make what I think is an educated guess and hope
> someone sets both of us straight ;-)

Hi,

Thanks for your response....see below..

> Even entry actions aren't triggered at the start of a rule - they are
> triggered on entry into the state where the rule has been fully
> recognised. Basically, the recognition tends to find the smallest
> building blocks first, progressing to larger building blocks later.
>
> In general, entry actions *cannot* be triggered on (for instance) the
> first character of a rule - you cannot know for sure which is the
> right rule. Consider what happens when there are two alternatives, for
> instance...
>
> opt1 = a.b;
> opt2 = a.c;
> main = opt1 | opt2;
>
> When the only input that has been examined is the 'a', you cannot tell
> whether you have an opt1 or an opt2. Therefore you cannot choose the
> correct entry action - this can only happen when you have also
> examined the 'b' or 'c' and entered the state where either opt1 or
> opt2 has been fully recognised.

Interesting theory, but I tried your grammar:

%%{

machine smaller;
write data noerror;

opt1 = ('a' . 'b') >{ printf(">opt1\n"); } @{ printf("@opt1\n"); }  $
{ printf("$opt1\n"); }  %{ printf("%%opt1\n"); };
opt2 = ('a' . 'c') >{ printf(">opt2\n"); } @{ printf("@opt2\n"); }  $
{ printf("$opt2\n"); }  %{ printf("%%opt2\n"); };
main := (opt1 | opt2) >{ printf(">main\n"); } @{ printf("@main\n"); }
${ printf("$main\n"); }  %{ printf("%%main\n"); };

write init;
write exec noend;

}%%
}%%

and it doesn't seem to work that way.  when you view the state
diagram, you see that
as soon as we see the 'a', regel calls ">main", then ">opt1", and
">opt2" (in this
case, unlike my initial example, this is the order I would expect with
the
parents' ">" routine being called first):

<ragel filename="smaller.rl" lang="C">
<ragel_def name="smaller">
  <alphtype>0</alphtype>
  <machine>
    <action_list length="9">
      <action id="0" line="7" col="21"><text> printf("&gt;opt1\n"); </
text></action>
      <action id="1" line="7" col="45"><text> printf("@opt1\n"); </
text></action>
      <action id="2" line="7" col="70"><text> printf("$opt1\n"); </
text></action>
      <action id="3" line="8" col="21"><text> printf("&gt;opt2\n"); </
text></action>
      <action id="4" line="8" col="45"><text> printf("@opt2\n"); </
text></action>
      <action id="5" line="8" col="70"><text> printf("$opt2\n"); </
text></action>
      <action id="6" line="9" col="24"><text> printf("&gt;main\n"); </
text></action>
      <action id="7" line="9" col="48"><text> printf("@main\n"); </
text></action>
      <action id="8" line="9" col="73"><text> printf("$main\n"); </
text></action>
    </action_list>
    <action_table_list length="3">
      <action_table id="0" length="6">6 0 2 3 5 8</action_table>
      <action_table id="1" length="4">1 2 7 8</action_table>
      <action_table id="2" length="4">4 5 7 8</action_table>
    </action_table_list>
    <start_state>1</start_state>
    <error_state>0</error_state>
    <state_list length="5">
      <state id="0">
      <trans_list length="0">
      </trans_list>
      </state>

      <state id="1">
      <trans_list length="1">
        <t>97 97 2 0</t>
      </trans_list>
      </state>

      <state id="2">
      <trans_list length="2">
        <t>98 98 3 1</t>
        <t>99 99 4 2</t>
      </trans_list>
      </state>

      <state id="3" final="t">
      <trans_list length="0">
      </trans_list>
      </state>

      <state id="4" final="t">
      <trans_list length="0">
      </trans_list>
      </state>
    </state_list>
  </machine>
</ragel_def>
<host line="1" col="1">

</host>
<write def_name="smaller" line="5" col="1"><arg>data</
arg><arg>noerror</arg></write>
<write def_name="smaller" line="11" col="1"><arg>init</arg></write>
<write def_name="smaller" line="12" col="1"><arg>exec</arg><arg>noend</
arg></write>
<host line="14">

}</host>
<host line="16"></host>
</ragel>

it seems like if ragel waited to call the ">" routine until it found a
match, then
this would be the same as the "@" routine or the "$" routine.  the ">"
routine
is then useful for creating some state (e.g. allocating a memory
location)
which can later be filled in if the rule matches.

any other ideas?

     - Chris Pirazzi



From cpira... at gmail.com  Mon Feb 19 07:47:25 2007
From: cpira... at gmail.com (Chris Pirazzi)
Date: Mon, 19 Feb 2007 07:47:25 -0000
Subject: action ordering. is this a bug?
In-Reply-To: <1171870278.925001.61140@q2g2000cwa.googlegroups.com>
References: <1171798725.471254.284590@k78g2000cwa.googlegroups.com>
   <1171841393.419705.12210@s48g2000cws.googlegroups.com>
   <1171870278.925001.61140@q2g2000cwa.googlegroups.com>
Message-ID: <1171871245.681559.255900@v45g2000cwv.googlegroups.com>


Doh!  It was a simple operator precedence issue:

tbarz = barz . barz >{ printf(">tbarz\n"); } @{ printf("@tbarz\n"); } $
{ printf("$tbarz\n"); }  %{ printf("%%tbarz\n"); };

'>' binds more tightly than '.' so it should be

tbarz = (barz . barz) >{ printf(">tbarz\n"); } @{ printf("@tbarz
\n"); } ${ printf("$tbarz\n"); }  %{ printf("%%tbarz\n"); };

and I was printing the start (and other) transitions of the second
barz.

sorry for the noise,

    - Chris Pirazzi


From stephenhorne... at aol.com  Mon Feb 19 09:14:31 2007
From: stephenhorne... at aol.com (Steve Horne)
Date: Mon, 19 Feb 2007 01:14:31 -0800
Subject: action ordering. is this a bug?
In-Reply-To: <1171871245.681559.255900@v45g2000cwv.googlegroups.com>
References: <1171798725.471254.284590@k78g2000cwa.googlegroups.com>
   <1171841393.419705.12210@s48g2000cws.googlegroups.com>
   <1171870278.925001.61140@q2g2000cwa.googlegroups.com>
   <1171871245.681559.255900@v45g2000cwv.googlegroups.com>
Message-ID: <1171876471.470308.29700@v33g2000cwv.googlegroups.com>


On Feb 19, 7:47 am, "Chris Pirazzi" <cpira... at gmail.com> wrote:

> Doh!  It was a simple operator precedence issue:

Ah - sounds like I learned more from this than you did. I should have
done more checking before posting. Sorry about that.


From jason2... at jasonjobe.com  Mon Feb 19 21:59:58 2007
From: jason2... at jasonjobe.com (Jason)
Date: Mon, 19 Feb 2007 13:59:58 -0800
Subject: How can I capture a big block of data
Message-ID: <1171922398.940429.152690@t69g2000cwt.googlegroups.com>

Hello again.

Thanks to Adrian, my pull scanner is working great.

Now I'm wanting to grab a block of XML data but since the main focus
of my scan is not XML I'm wondering if it wouldn't be easier to
delimit any xml with some tags <xml> .... </xml>, and pass the whole
block of data off to some other code and simply return a TK_XML token.

I note in many examples, zipping through comments is pretty straight
forward. Could / Should I do the same (or similar) thing to grab my
XML?

thanks,
Jason


From stephenhorne... at aol.com  Wed Feb 21 17:03:43 2007
From: stephenhorne... at aol.com (Steve Horne)
Date: Wed, 21 Feb 2007 09:03:43 -0800
Subject: How can I capture a big block of data
In-Reply-To: <1171922398.940429.152690@t69g2000cwt.googlegroups.com>
References: <1171922398.940429.152690@t69g2000cwt.googlegroups.com>
Message-ID: <1172077423.920725.5230@j27g2000cwj.googlegroups.com>


On Feb 19, 9:59 pm, "Jason" <jason2... at jasonjobe.com> wrote:

> Now I'm wanting to grab a block of XML data but since the main focus
> of my scan is not XML I'm wondering if it wouldn't be easier to
> delimit any xml with some tags <xml> .... </xml>, and pass the whole
> block of data off to some other code and simply return a TK_XML token.
>
> I note in many examples, zipping through comments is pretty straight
> forward. Could / Should I do the same (or similar) thing to grab my
> XML?

My first thought is that this should be pretty easy. You need to
recognise it in three stages...

1.  The <xml> marker, allowing for whitespace etc.
2.  The content, using a regular expression that refuses to accept the
'</xml>' (use "any* -- [expression for </xml>]").
3.  The expression for </xml>.

The one possible problem is that this would stop early in any xml that
happened to have an 'xml' tag of its own.

There is the possibility of recognising all start and end tags, so you
can keep track of the nesting. Regular expression parsing cannot
handle recursive nesting, so handling this sounds like a job for a
context-free parsing tool such as Yacc, Bison or Kelbt, but in this
case, Ragel can probably cheat.

The trick is to use actions to maintain a counter that keeps track of
nesting depth, and to use semantic conditions to check the count. With
some care, this could even give some confidence that the XML is well
formed.

That said, this also means that badly formed embedded XML will
probably prevent you from finding the real end of the XML.

Different markers could be a good idea. For instance, you should never
see a strings of multiple "<<<<<" characters in well formed XML so
this could be exploited to give a safe end marker. It might be
necessary to exclude strings within quotes, but that's a relatively
simple thing to handle using the strong difference again.


From e.vanoos... at chello.nl  Tue Feb 13 10:54:20 2007
From: e.vanoos... at chello.nl (Erik van Oosten)
Date: Tue, 13 Feb 2007 02:54:20 -0800
Subject: Generating java source code
Message-ID: <1171364060.346711.151010@v45g2000cwv.googlegroups.com>

Hi,

I am examining the use of ragel for parsing Edifact messages to java
beans. So I came across a message about a 64K limit of java arrays.

Well, unless I am missing something, this is simply not true. I just
wrote a little program to test it. With -Xms1024M -Xmx1024M as JVM
argument, the limit is somewhere between 234881023 (224M) and
251658239 (240M) items (I aborted the program, it was swapping too
much).  With only 128M of memory, the limit is still a healthy
30955269 (29M) items.

Regards,
     Erik.


public class ArrayTest {
	private int getMaxArraySize(int minValue, int maxValue) {
		int min = minValue;
		int max = maxValue;
		while (min < max) {
			System.out.println(min + "\t\t" + max);
			int halfway = min + ((max - min) >> 1);
			try {
				Object[] arr = new Object[halfway];
				min = halfway;
			} catch (Error e) {
				max = halfway - 1;
			}
		}
		return min;
	}

	public static void main(String[] args) {
		ArrayTest at = new ArrayTest();
		System.out.println(at.getMaxArraySize(0, Integer.MAX_VALUE));
	}
}


From thurs... at cs.queensu.ca  Tue Feb 13 15:26:30 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Tue, 13 Feb 2007 10:26:30 -0500
Subject: [ragel-users] Re: Generating java source code
In-Reply-To: <1171364060.346711.151010@v45g2000cwv.googlegroups.com>
References: <1171364060.346711.151010@v45g2000cwv.googlegroups.com>
Message-ID: <45D1D8A6.1040308@cs.queensu.ca>

Hi Erik, the message you read probably neglected to mention that the 
problem is with array initialization.

private static byte[] array = [ 1, 2, 3, 4, ... ];

Java initializes arrays by creating a function.

init()
{
	array[0] = 1;
	array[1] = 2;
	...
}

If there are too many elements you get the "code too large" error. This 
issue has been fixed in trunk however. Ragel now generates the 
initialization functions directly, and splits them when they get big.

Adrian

Erik van Oosten wrote:
> Hi,
> 
> I am examining the use of ragel for parsing Edifact messages to java
> beans. So I came across a message about a 64K limit of java arrays.
> 
> Well, unless I am missing something, this is simply not true. I just
> wrote a little program to test it. With -Xms1024M -Xmx1024M as JVM
> argument, the limit is somewhere between 234881023 (224M) and
> 251658239 (240M) items (I aborted the program, it was swapping too
> much).  With only 128M of memory, the limit is still a healthy
> 30955269 (29M) items.
> 
> Regards,
>      Erik.
> 
> 
> public class ArrayTest {
> 	private int getMaxArraySize(int minValue, int maxValue) {
> 		int min = minValue;
> 		int max = maxValue;
> 		while (min < max) {
> 			System.out.println(min + "\t\t" + max);
> 			int halfway = min + ((max - min) >> 1);
> 			try {
> 				Object[] arr = new Object[halfway];
> 				min = halfway;
> 			} catch (Error e) {
> 				max = halfway - 1;
> 			}
> 		}
> 		return min;
> 	}
> 
> 	public static void main(String[] args) {
> 		ArrayTest at = new ArrayTest();
> 		System.out.println(at.getMaxArraySize(0, Integer.MAX_VALUE));
> 	}
> }
> 
> 
> 


From e.vanoos... at chello.nl  Tue Feb 13 16:12:29 2007
From: e.vanoos... at chello.nl (Erik van Oosten)
Date: Tue, 13 Feb 2007 08:12:29 -0800
Subject: Generating java source code
In-Reply-To: <45D1D8A6.1040308@cs.queensu.ca>
References: <1171364060.346711.151010@v45g2000cwv.googlegroups.com>
   <45D1D8A6.1040308@cs.queensu.ca>
Message-ID: <1171383149.884994.302110@l53g2000cwa.googlegroups.com>

Ah! That makes sense.

Thanks for the explanation.

Regards,
    Erik.


On 13 feb, 16:26, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
> Hi Erik, the message you read probably neglected to mention that the
> problem is with array initialization.
>
> private static byte[] array = [ 1, 2, 3, 4, ... ];
>
> Java initializes arrays by creating a function.
>
> init()
> {
>         array[0] = 1;
>         array[1] = 2;
>         ...
>
> }
>
> If there are too many elements you get the "code too large" error. This
> issue has been fixed in trunk however. Ragel now generates the
> initialization functions directly, and splits them when they get big.
>
> Adrian


From stephenhorne... at aol.com  Wed Feb 14 15:55:23 2007
From: stephenhorne... at aol.com (Steve Horne)
Date: Wed, 14 Feb 2007 07:55:23 -0800
Subject: Generating java source code
In-Reply-To: <45D1D8A6.1040308@cs.queensu.ca>
References: <1171364060.346711.151010@v45g2000cwv.googlegroups.com>
   <45D1D8A6.1040308@cs.queensu.ca>
Message-ID: <1171468523.177492.255590@m58g2000cwm.googlegroups.com>


On Feb 13, 3:26 pm, Adrian Thurston <thurs... at cs.queensu.ca> wrote:

> This
> issue has been fixed in trunk however. Ragel now generates the
> initialization functions directly, and splits them when they get big.

That seems a terrible way of initialising large arrays. You could
easily end up with more overhead (code to insert the items) than data,
depending on precisely how the VM bytecode works.

Couldn't the compiled data tables be stored in data files? I confess
I'm pretty ignorant of Java, beyond the basic language syntax, but
isn't there some way to embed application data files into those jar
files? Something intended to do a similar job to embedding resource
data into executables?

The file layout would have to be simple, though - there'd be no point
if you need another parser just to load it!


From colin.mailingl... at gmail.com  Mon Feb 26 19:20:47 2007
From: colin.mailingl... at gmail.com (Colin Fleming)
Date: Mon, 26 Feb 2007 20:20:47 +0100
Subject: [ragel-users] Re: Generating java source code
In-Reply-To: <1171468523.177492.255590@m58g2000cwm.googlegroups.com>
References: <1171364060.346711.151...@v45g2000cwv.googlegroups.com>
	 <45D1D8A6.1040...@cs.queensu.ca>
	 <1171468523.177492.255...@m58g2000cwm.googlegroups.com>
Message-ID: <7c6512110702261120s17edea41r469b14f7253f65b9@mail.gmail.com>

The issue, as Adrian pointed out, is that Java initialises arrays by
creating a huge list of assignments, and there's a JVM limit of 64k
per method, which is frequently a problem for generated code. There
are various hacks (encoding data in Strings etc), but none of them are
very elegant.

The problem with putting data in Jar files is that it then makes
building the Jar files more complicated. The data files have to exist
in a known location in the jar, and if there's a problem, you won't
know about it until runtime. Not much more complicated, but a bit -
AFAIK it's not easy to do with Maven, for example. As ugly as it is,
the array initialiser method means that you just compile your classes
and can do what you want with them afterwards, and it won't have
runtime dependencies. It might be worth providing this as an option,
though.

I was working on the Java generation a while back, but unfortunately I
got seriously sidetracked, and haven't been able to get back to it.

Cheers,
Colin


From thurs... at cs.queensu.ca  Wed Feb 14 01:07:31 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Tue, 13 Feb 2007 20:07:31 -0500
Subject: new backend executable names in 5.18
Message-ID: <45D260D3.6080508@cs.queensu.ca>

Hi,

In version 5.18 the backend program has been split into several 
executables grouped by similarity of the output language.

rlgen-cd       C and D code
rlgen-dot      Graphviz
rlgen-java     Java (experimental)
rlgen-ruby     Ruby (new, experimental)

Also remember that when generating code the correct frontend language 
option must be given. The dot file generator does not care what language 
you are using.

The release is out, enjoy!

-Adrian


From zeds... at zedshaw.com  Wed Feb 14 09:42:37 2007
From: zeds... at zedshaw.com (Zed A. Shaw)
Date: Wed, 14 Feb 2007 01:42:37 -0800
Subject: [ragel-users] new backend executable names in 5.18
In-Reply-To: <45D260D3.6080508@cs.queensu.ca>
References: <45D260D3.6080508@cs.queensu.ca>
Message-ID: <20070214014237.185fd8ec.zedshaw@zedshaw.com>

On Tue, 13 Feb 2007 20:07:31 -0500
Adrian Thurston <thurs... at cs.queensu.ca> wrote:

> 
> Hi,
> 
> In version 5.18 the backend program has been split into several 
> executables grouped by similarity of the output language.
<snip> 
> rlgen-ruby     Ruby (new, experimental)

Man, Ruby code to play with, but the docs are ultra thin on this.  Any
samples I can steal from?

Also, the rlgen-ruby binary calls itself rlgen-java, FYI.

Otherwise, dying to play with this in Mongrel and RFuzz.

-- 
Zed A. Shaw, MUDCRAP-CE Master Black Belt Sifu
http://www.zedshaw.com/
http://www.awprofessional.com/title/0321483502 -- The Mongrel Book
http://mongrel.rubyforge.org/
http://www.lingr.com/room/3yXhqKbfPy8 -- Come get help.


From michael.dai... at gmail.com  Thu Feb 22 05:08:50 2007
From: michael.dai... at gmail.com (mdaines)
Date: Wed, 21 Feb 2007 21:08:50 -0800
Subject: new backend executable names in 5.18
In-Reply-To: <45D260D3.6080508@cs.queensu.ca>
References: <45D260D3.6080508@cs.queensu.ca>
Message-ID: <1172120930.838688.120190@j27g2000cwj.googlegroups.com>

> rlgen-ruby     Ruby (new, experimental)

I too would like to see some samples.

When will we see rlgen-javascript? I'm only half kidding, though I
think I see parsing going on in JavaScript sometimes that seems like
maybe it could benefit? Plus, I am leaning toward thinking such a
thing could be useful to me, maybe. Maybe fiddling around with that is
a good leisure-time way to learn about this whole subject and about
how Ragel is implemented...


From jason2... at jasonjobe.com  Sat Feb 24 04:08:35 2007
From: jason2... at jasonjobe.com (Jason)
Date: Fri, 23 Feb 2007 20:08:35 -0800
Subject: selecting a starting state or how to serialize a machine
Message-ID: <1172290115.150566.229860@v33g2000cwv.googlegroups.com>

I am finding more uses for ragel all the time :-)
Now I am experimenting with using a ragel to model work flow logic.
For example, a document has an associated state, approved, rejected,
pending, etc. So I want to load the document and "post" events that
will drive the document status to new states, triggering actions
along
the way.

So the question is: How do I tell a ragel machine I want to start at
a
particular point (where it left off before)?

Do I just archive the entire machine variables (fixing up pointers of
course)?

thanks,
Jason


From skkib... at earthlink.net  Sun Feb 25 03:19:24 2007
From: skkib... at earthlink.net (skk)
Date: Sat, 24 Feb 2007 19:19:24 -0800
Subject: selecting a starting state or how to serialize a machine
In-Reply-To: <1172290115.150566.229860@v33g2000cwv.googlegroups.com>
References: <1172290115.150566.229860@v33g2000cwv.googlegroups.com>
Message-ID: <1172373564.738689.178450@v33g2000cwv.googlegroups.com>

What I have done with a text editor in a windows control is build the
initial state machine so things transition through the basic states as
required.  I validate this machine first.  Then I build in transitions
from the start state into the internal states with the input that
represents the current state.  In the text editor, build the machine
to handle the cursor movement, character insert, delete, insert/
overwright, skip mask characters and so on.  When entering the machine
I then create a transition from the initial state into the internal
states after computing the current state of the cursor.  The current
state of the cursor can be far left/right, insert/overwright, valid
character to the left/right/both, etc.  This is encoded into an
integer (all input is in integers, not characters) and is fed in as
the first character thus putting me exactly where I want to be for the
next keyboard input character (integer).  This is necessary because
the user may have moved the text cursor with the mouse and the last
state I was in is not valid any more.

On Feb 23, 9:08 pm, "Jason" <jason2... at jasonjobe.com> wrote:
> I am finding more uses for ragel all the time :-)
> Now I am experimenting with using a ragel to model work flow logic.
> For example, a document has an associated state, approved, rejected,
> pending, etc. So I want to load the document and "post" events that
> will drive the document status to new states, triggering actions
> along
> the way.
>
> So the question is: How do I tell a ragel machine I want to start at
> a
> particular point (where it left off before)?
>
> Do I just archive the entire machine variables (fixing up pointers of
> course)?
>
> thanks,
> Jason


From jason2... at jasonjobe.com  Tue Feb 27 19:40:42 2007
From: jason2... at jasonjobe.com (Jason)
Date: Tue, 27 Feb 2007 11:40:42 -0800
Subject: token buffer not correct
Message-ID: <1172605242.835835.194270@8g2000cwh.googlegroups.com>

BTW, this is pull scanner.

Essentially I see a possible problem / bug in 2 areas. One is the
return value of a single character. Specifically in the enclosed
example TK_Char should be return the int value of the char matched
(e.g. '{') but it isn't.

The second involves the *non* advancement of the token / data pointer
illustrated below. The digraph value, "<:" appears at the beginning of
the output of the following token TK_TEXT.

My input is this

(app MyApp

	New: (
		User.Submit.Application: (
			>> Submitted
			<: {#<xml> pre_action </xml>#}
			:>  { (one) }
		)
	)
)

The problem tokens are printed thusly

	parser: TK_PRE(271):6 "<:"
	parser: TK_TEXT(266):6 "<: {#<xml> pre_action </xml>#}"

The excerpted rule is

			# Consume text delimited by <xml> ... </xml>
			xml  := (any_count_line* -- "</xml>") :>> "</xml>"
			@{
				/* Save p and pe. fbreak does not advance p. */
				s->token = TK_XML;
				s->token_name = "TK_XML";

				s->p = p + 1;
				s->pe = pe;
				s->len = s->p - s->data;
				return TK_XML;
			};

I've tried a number of things with the grammar to no avail. So I don't
know if this a problem with ragel or my spec.

Any pointers would be most appreciated.

many thanks,
Jason

---------------------------- Full .rl
----------------------------------------------------------------------
#include "reader_s.h"

#ifndef SCOPE
#define SCOPE
#endif


%%{
	machine Scanner;
	write data;
}%%


SCOPE void scan_init_buf( Scanner *s, char *buf )
{
	memset (s, '\0', sizeof(Scanner));
	s->curline = 1;
	s->buf = buf;
	s->p = s->buf;
	%%{ write init; }%%
}

SCOPE void scan_finalize( Scanner *s )
{
}

#define ret_tok( _tok ) token = _tok; s->token = _tok; s->data = s-
>tokstart; s->token_name = #_tok
#define ret_char( _tok ) token = _tok; s->token = *s->tokstart; s-
>data = s->tokstart; s->token_name = "TK_Char"

SCOPE int scan( Scanner *s )
{
	char *p = s->p;
	char *pe = s->pe;
	int token = TK_NO_TOKEN;

	while ( 1 ) {

		%%{
			machine Scanner;
			access s->;

			newline = '\n' @{s->curline += 1;};
			any_count_line = any | newline;

			# Consume a C comment.
			c_comment := any_count_line* :>> '*/' @{fgoto main;};

			# Consume text delimited by <xml> ... </xml>
			xml  := (any_count_line* -- "</xml>") :>> "</xml>"
			@{
				/* Save p and pe. fbreak does not advance p. */
				s->token = TK_XML;
				s->token_name = "TK_XML";

				s->p = p + 1;
				s->pe = pe;
				s->len = s->p - s->data;
				return TK_XML;
			};

			text_block := (any_count_line* -- '#}') :>> '#}'
			@{
				/* Save p and pe. fbreak does not advance p. */
				s->token = TK_TEXT;
				s->token_name = "TK_TEXT";

				s->p = p + 1;
				s->pe = pe;
				s->len = s->p - s->data;
				return TK_XML;
			};

			main := |*

			newline;

			# Alpha numberic characters or underscore.
			alnum_u = alnum | '_';

			# Alpha charactres or underscore.
			alpha_u = alpha | '_';

			ident = alpha_u alnum_u*;

			# Identifiers
			ident =>
				{ ret_tok( TK_Identifier ); fbreak; };

			# Keypath
			keypath = ident ('.' ident)*;
			keypath => { ret_tok( TK_Keypath ); fbreak; };

			# Keywords
			ident ':' => {
				ret_tok (TK_Keyword); fbreak;
			};

			keypath ':' => {
				ret_tok (TK_Keyword); fbreak;
			};

			# Strings and Text
			"'" ( [^'\\] | /\\./ )* "'" => { ret_tok (TK_String); fbreak; };
			'"' ( [^"\\] | /\\./ )* '"' => { ret_tok (TK_String); fbreak; };

			"<xml>" { fgoto xml; };
			'{#' 	{ fgoto text_block; };

			# Special Digraphs
			">>" @ { ret_tok (TK_SHIFT_RT); fbreak; };
			"<<" @ { ret_tok (TK_SHIFT_LT); fbreak; };
			":>" @ { ret_tok (TK_POST); fbreak; };
			"<:" @ { ret_tok (TK_PRE); fbreak; };

			"<=" => { ret_tok (TK_LE); fbreak; };
			">=" => { ret_tok (TK_GE); fbreak; };
			"!=" => { ret_tok (TK_NE); fbreak; };

			"++" => { ret_tok (TK_Increment); fbreak; };
			"--" => { ret_tok (TK_Decrement); fbreak; };

			# Whitespace
			[ \t\n];

	# Numbers
	digit+ => {
		ret_tok (TK_Integer); fbreak;
	};

	digit+'.' digit+ => {
		ret_tok (TK_Real); fbreak;
	};

	digit{1,3} (',' digit{3})+ => { ret_tok (TK_Integer); fbreak; };

	digit{1,3} (',' digit{3})+ '.' digit+ => { ret_tok (TK_Real);
fbreak; };

	'0x' xdigit+ => { ret_tok (TK_Hex); fbreak; };

        # Describe both c style comments and c++ style comments. The
        # priority bump on tne terminator of the comments brings us
        # out of the extend* which matches everything.
        '//' [^\n]* newline;

	'/*' { fgoto c_comment; };


			# EOF
			0 =>
				{ ret_tok( TK_EOF ); fbreak; };

			# Anything else
			any =>
				{ ret_char( *p ); fbreak; };

			*|;

			write exec;
		}%%

		if ( s->cs == Scanner_error )
			return TK_ERR;

		if ( token != TK_NO_TOKEN ) {
			/* Save p and pe. fbreak does not advance p. */
			s->p = p + 1;
			s->pe = pe;
			s->len = s->p - s->data;
			s->token = token;
			return token;
		}
	}
}

#ifdef TEST

#include <stdlib.h>
#include <stdio.h>
#include <string.h>


void output(Scanner *ss)
{
	int tok;

	while ( 1 ) {
		tok = scan (ss);
		if ( tok == TK_EOF ) {
			printf ("parser: EOF\n");
			break;
		}
		else if ( tok == TK_ERR ) {
			printf ("parser: ERR\n");
			break;
		}
		else {
			printf ("parser: %s(%d):%d \"", ss->token_name, tok, ss->curline);
			fwrite ( ss->data, 1, ss->len, stdout );
			printf ("\"\n" );
		}
	}
}

#define BUFSIZE 4096

int main (int argc, char** argv)
{
	Scanner ss;
   	char buf[BUFSIZE];

	int len = fread ( buf, sizeof(char), BUFSIZE, stdin );
	buf[len] = '\0';
	scan_init_buf (&ss, buf);

//	char *input = "(do with:1,345.99 and: \"some string\")";
//	scan_init_buf(&ss, input);

	output (&ss);
	scan_finalize (&ss);

	return 0;
}

#endif


From jason2... at jasonjobe.com  Wed Feb 28 03:21:23 2007
From: jason2... at jasonjobe.com (Jason)
Date: Tue, 27 Feb 2007 19:21:23 -0800
Subject: reflection of the machine
Message-ID: <1172632883.572593.173920@s48g2000cws.googlegroups.com>

Is it possible to get a representation of the machine to enable the
following:

1) Get a string name or representation of a machine, labeled node, and
action.

2) Provide defined constants for named nodes.

Is it possible to initialize a machine to a state other than the
defined starting point?

-jason


