From b at bvanderveen.com  Thu Jan 20 23:26:40 2011
From: b at bvanderveen.com (Benjamin van der Veen)
Date: Thu, 20 Jan 2011 15:26:40 -0800
Subject: [ragel-users] EOF actions and buffering
Message-ID: <7CC9944D-D646-42E4-8F5E-0DA96D4491F3@bvanderveen.com>

Hello,

I am using Ragel to make an HTTP parser. Feel free to tell me this is a terrible idea. ;)

It seems to me that a common problem faced by users of Ragel is that they do not know in advance where (with respect to the grammar being parsed) the boundaries of buffers that they feed the parser are going to be. For example, I can easily make a Ragel grammar which will parse the following using only entering and leaving actions:

"GET /foo HTTP/1.1\r\nBar: Baz\r\n\r\n"

However the parser breaks if I feed it the same data across multiple buffers (as would be the case when reading chunks of data from a network socket):

"GE"
"T /f"
"oo HTTP/1.1\r"
"\nBar: Baz\r\n\r\n"

I found that this can be mitigated against by using EOF-leaving actions (%/some_action) and always setting eof to pe to cause the EOF-leaving actions to occur. However I'm finding that it isn't consistent and leads to unexpected behavior in some cases. Note that I am using the regular expression syntax, not the state chart syntax.

What is the recommended approach to this problem? My intuition is that a properly-specified state machine should work regardless of how data is fed to it and Ragel should make this opaque to the user—it seems to me that processing data across multiple buffers would be a very common problem that Ragel would solve for the user, but I may be mistaken.

In general I'm rather confused about how EOF actions are handled and when entering or leaving actions are treated as EOF actions. I've pored over the manual but I feel like it's all predicated on some knowledge that I don't have and am unsure where to look to find. In particular the first two paragraphs of section 3.1.4 (Leaving Actions) are almost completely opaque to me.

Cheers!
Benjamin van der Veen
_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From ibc at aliax.net  Thu Jan 20 23:31:36 2011
From: ibc at aliax.net (=?UTF-8?Q?I=C3=B1aki_Baz_Castillo?=)
Date: Fri, 21 Jan 2011 00:31:36 +0100
Subject: [ragel-users] EOF actions and buffering
In-Reply-To: <7CC9944D-D646-42E4-8F5E-0DA96D4491F3@bvanderveen.com>
References: <7CC9944D-D646-42E4-8F5E-0DA96D4491F3@bvanderveen.com>
Message-ID: <AANLkTinphQSnNomNenO-nhpodxxUnvDvy5a-6CAJ8O3C@mail.gmail.com>

2011/1/21 Benjamin van der Veen <b at bvanderveen.com>:
> Hello,
>
> I am using Ragel to make an HTTP parser. Feel free to tell me this is a terrible idea. ;)

It's a very good idea :)


> It seems to me that a common problem faced by users of Ragel is that they do not know in advance where (with respect to the grammar being parsed) the boundaries of buffers that they feed the parser are going to be. For example, I can easily make a Ragel grammar which will parse the following using only entering and leaving actions:

I recommend you checking Mongrel HTTP parser, which is written in C
and it used to build a Ruby object containing parsed data. However the
parser is a separate file(s) you really can learn from.


-- 
Iñaki Baz Castillo
<ibc at aliax.net>

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users

From adrian.thurston at esentire.com  Thu Jan 20 23:43:47 2011
From: adrian.thurston at esentire.com (Adrian Thurston)
Date: Thu, 20 Jan 2011 15:43:47 -0800
Subject: [ragel-users] EOF actions and buffering
In-Reply-To: <7CC9944D-D646-42E4-8F5E-0DA96D4491F3@bvanderveen.com>
References: <7CC9944D-D646-42E4-8F5E-0DA96D4491F3@bvanderveen.com>
Message-ID: <4D38C8B3.8060506@esentire.com>

It is indeed a common problem. It is purposefully left in the hands of 
the programmer. This is due to a few factors.

-There is no general solution that doesn't involve memory allocation.
-There are many different ways to approach memory allocation
-There are many use cases that have always input in one buffer

When I need a general solution I use automatically growing buffers (to a 
limit). See the DSNPd source for an example. I don't think that buffer 
class is limited, but it should be.

http://svn.complang.org/choicesocial/trunk/dsnpd/parser.rl

There are other approaches though. See the Ragel manual (5.9) for a 
short discussion.

Regards,
  Adrian

On 11-01-20 03:26 PM, Benjamin van der Veen wrote:
> Hello,
>
> I am using Ragel to make an HTTP parser. Feel free to tell me this is a terrible idea. ;)
>
> It seems to me that a common problem faced by users of Ragel is that they do not know in advance where (with respect to the grammar being parsed) the boundaries of buffers that they feed the parser are going to be. For example, I can easily make a Ragel grammar which will parse the following using only entering and leaving actions:
>
> "GET /foo HTTP/1.1\r\nBar: Baz\r\n\r\n"
>
> However the parser breaks if I feed it the same data across multiple buffers (as would be the case when reading chunks of data from a network socket):
>
> "GE"
> "T /f"
> "oo HTTP/1.1\r"
> "\nBar: Baz\r\n\r\n"
>
> I found that this can be mitigated against by using EOF-leaving actions (%/some_action) and always setting eof to pe to cause the EOF-leaving actions to occur. However I'm finding that it isn't consistent and leads to unexpected behavior in some cases. Note that I am using the regular expression syntax, not the state chart syntax.
>
> What is the recommended approach to this problem? My intuition is that a properly-specified state machine should work regardless of how data is fed to it and Ragel should make this opaque to the user—it seems to me that processing data across multiple buffers would be a very common problem that Ragel would solve for the user, but I may be mistaken.
>
> In general I'm rather confused about how EOF actions are handled and when entering or leaving actions are treated as EOF actions. I've pored over the manual but I feel like it's all predicated on some knowledge that I don't have and am unsure where to look to find. In particular the first two paragraphs of section 3.1.4 (Leaving Actions) are almost completely opaque to me.
>
> Cheers!
> Benjamin van der Veen
> _______________________________________________
> ragel-users mailing list
> ragel-users at complang.org
> http://www.complang.org/mailman/listinfo/ragel-users
>

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From b at bvanderveen.com  Fri Jan 21 00:15:08 2011
From: b at bvanderveen.com (Benjamin van der Veen)
Date: Thu, 20 Jan 2011 16:15:08 -0800
Subject: [ragel-users] EOF actions and buffering
In-Reply-To: <AANLkTinphQSnNomNenO-nhpodxxUnvDvy5a-6CAJ8O3C@mail.gmail.com>
References: <7CC9944D-D646-42E4-8F5E-0DA96D4491F3@bvanderveen.com>
	<AANLkTinphQSnNomNenO-nhpodxxUnvDvy5a-6CAJ8O3C@mail.gmail.com>
Message-ID: <A31F9618-99EE-4F93-9E81-2205F8493C5B@bvanderveen.com>


On Jan 20, 2011, at 3:31 PM, Iñaki Baz Castillo wrote:

> 2011/1/21 Benjamin van der Veen <b at bvanderveen.com>:
> 
>> It seems to me that a common problem faced by users of Ragel is that they do not know in advance where (with respect to the grammar being parsed) the boundaries of buffers that they feed the parser are going to be. For example, I can easily make a Ragel grammar which will parse the following using only entering and leaving actions:
> 
> I recommend you checking Mongrel HTTP parser, which is written in C
> and it used to build a Ruby object containing parsed data. However the
> parser is a separate file(s) you really can learn from.

Mongrel is where I got the idea from, although it seems to buffer the entirety of the request headers to work around this problem. I would like to avoid this solution if possible.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.colm.net/pipermail/ragel/attachments/20110120/3b0fadfa/attachment.html>
-------------- next part --------------
_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users

From b at bvanderveen.com  Fri Jan 21 02:52:09 2011
From: b at bvanderveen.com (Benjamin van der Veen)
Date: Thu, 20 Jan 2011 18:52:09 -0800
Subject: [ragel-users] EOF actions and buffering
In-Reply-To: <4D38C8B3.8060506@esentire.com>
References: <7CC9944D-D646-42E4-8F5E-0DA96D4491F3@bvanderveen.com>
	<4D38C8B3.8060506@esentire.com>
Message-ID: <DD7FA35D-D1C6-4012-8164-0C5BE452B2D1@bvanderveen.com>

Thanks for the tips, Adrian.

I've poked through the material you referenced and gleaned a bit. Please check my understanding and let me know if something is missing.

On Jan 20, 2011, at 3:43 PM, Adrian Thurston wrote:
> http://svn.complang.org/choicesocial/trunk/dsnpd/parser.rl

The parser impl referenced above uses an intermediary buffer; it clears the intermediary buffer on the "enter" action of a token to be extracted, copies each character of the token into a buffer on the "any" action, and when the "leaving" action is executed, the contents of that intermediary buffer are then copied into the destination string. Will this approach will work regardless of buffer boundaries?

> There are other approaches though. See the Ragel manual (5.9) for a short discussion.

This approach requires the user to make sure the ts pointer remains valid in the buffer provided each time the machine is executed (which depending on how you're handing IO may mean some memory copying). It allows an action to have access to the a contiguous block of memory (given by ts and fpc) which defines the matched token. Does this approach only work with the state chart syntax?






_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From thurston at complang.org  Sat Jan 22 18:10:25 2011
From: thurston at complang.org (Adrian Thurston)
Date: Sat, 22 Jan 2011 10:10:25 -0800
Subject: [ragel-users] EOF actions and buffering
In-Reply-To: <DD7FA35D-D1C6-4012-8164-0C5BE452B2D1@bvanderveen.com>
References: <7CC9944D-D646-42E4-8F5E-0DA96D4491F3@bvanderveen.com>	<4D38C8B3.8060506@esentire.com>
	<DD7FA35D-D1C6-4012-8164-0C5BE452B2D1@bvanderveen.com>
Message-ID: <4D3B1D91.8050409@complang.org>

On 11-01-20 06:52 PM, Benjamin van der Veen wrote:
> The parser impl referenced above uses an intermediary buffer; it clears the intermediary buffer on the "enter" action of a token to be extracted, copies each character of the token into a buffer on the "any" action, and when the "leaving" action is executed, the contents of that intermediary buffer are then copied into the destination string. Will this approach will work regardless of buffer boundaries?

That is correct.

> This approach requires the user to make sure the ts pointer remains valid in the buffer provided each time the machine is executed (which depending on how you're handing IO may mean some memory copying). It allows an action to have access to the a contiguous block of memory (given by ts and fpc) which defines the matched token. Does this approach only work with the state chart syntax?

You can do it manually. The ts pointer is set with what is essentially 
an entering action. See cppscan2.rl for an example.

http://svn.complang.org/ragel/trunk/test/cppscan2.rl

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From pgervais at xplornet.com  Mon Jan 24 19:51:02 2011
From: pgervais at xplornet.com (Peter Gervais)
Date: Mon, 24 Jan 2011 14:51:02 -0500
Subject: [ragel-users] Detecting failure state
Message-ID: <38A0E247-F4BE-4BC1-8855-F419457B8848@xplornet.com>

Adrien,
   I need to know in which state of the state machine where a parsing error has occurred. Once an error has occurred, i need to be able to map the failure state number to the actual rule where the failure has occurred i.e. its not much use printing out failure in state X. It would much better if we could print out the text of the exact rule where the failure happened.  
1) Is there support for this at this time? 
2) What is the best way to do this ?
3) is there a place i can pick up the latest source for ragel which includes any patches you may have made without having to patch it myself? i.e. a complete tar bundle of the very latest work?

Peter Gervais
17621 Island Rd, 
RR#1 Martintown, Ontario
Bus: 1-613-938-6549
Cell: 1-613-864-7370
pgervais at xplornet.com




_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From joseph.stewart at gmail.com  Mon Jan 24 20:03:52 2011
From: joseph.stewart at gmail.com (Joseph Stewart)
Date: Mon, 24 Jan 2011 15:03:52 -0500
Subject: [ragel-users] Research on adding a new language...
Message-ID: <AANLkTik826Y50UuC74rH4b0Xkzs54942b9fkQWH-R5yT@mail.gmail.com>

Ragel-ers:

Has anyone on this list tinkered with creating a ragel mod to support the
Limbo programming language (
http://en.wikipedia.org/wiki/Limbo_(programming_language))?

It's relatively C-like.

Any advice on how much effort adding a new language takes?

Any pointers will be greatly appreciated!

-joe
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.colm.net/pipermail/ragel/attachments/20110124/2b4a27ca/attachment.html>
-------------- next part --------------
_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users

From thurston at complang.org  Tue Jan 25 02:34:39 2011
From: thurston at complang.org (thurston at complang.org)
Date: Tue, 25 Jan 2011 02:34:39 +0000
Subject: [ragel-users] Detecting failure state
Message-ID: <1640517278-1295922862-cardhu_decombobulator_blackberry.rim.net-167449441-@bda2250.bisx.prod.on.blackberry>

Hi Peter, there is no automatic method of obtaining this information. Search the mailing list for 'mapping' and 'state' to learn why. You have to use actions for this.

Adrian
------Original Message------
From: Peter Gervais
Sender: ragel-users-bounces at complang.org
To: ragel-users at complang.org
ReplyTo: ragel-users at complang.org
Subject: [ragel-users] Detecting failure state
Sent: Jan 24, 2011 11:51 AM

Adrien,
   I need to know in which state of the state machine where a parsing error has occurred. Once an error has occurred, i need to be able to map the failure state number to the actual rule where the failure has occurred i.e. its not much use printing out failure in state X. It would much better if we could print out the text of the exact rule where the failure happened.  
1) Is there support for this at this time? 
2) What is the best way to do this ?
3) is there a place i can pick up the latest source for ragel which includes any patches you may have made without having to patch it myself? i.e. a complete tar bundle of the very latest work?

Peter Gervais
17621 Island Rd, 
RR#1 Martintown, Ontario
Bus: 1-613-938-6549
Cell: 1-613-864-7370
pgervais at xplornet.com




_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From thurston at complang.org  Tue Jan 25 03:04:01 2011
From: thurston at complang.org (thurston at complang.org)
Date: Tue, 25 Jan 2011 03:04:01 +0000
Subject: [ragel-users] Research on adding a new language...
In-Reply-To: <AANLkTik826Y50UuC74rH4b0Xkzs54942b9fkQWH-R5yT@mail.gmail.com>
References: <AANLkTik826Y50UuC74rH4b0Xkzs54942b9fkQWH-R5yT@mail.gmail.com>
Message-ID: <226669571-1295924624-cardhu_decombobulator_blackberry.rim.net-1502481231-@bda2250.bisx.prod.on.blackberry>

Not that I'm aware of.

Basic rules for choosing a code generator to derive new ones from:

1. Had goto, use C
2. Has switch, use Java
3. Use Ruby.

-Adrian
-----Original Message-----
From: Joseph Stewart <joseph.stewart at gmail.com>
Sender: ragel-users-bounces at complang.org
Date: Mon, 24 Jan 2011 15:03:52 
To: <ragel-users at complang.org>
Reply-To: ragel-users at complang.org
Subject: [ragel-users] Research on adding a new language...

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users



_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From mail at murrayh.id.au  Thu Jan 27 04:08:31 2011
From: mail at murrayh.id.au (Murray Henderson)
Date: Thu, 27 Jan 2011 15:08:31 +1100
Subject: [ragel-users] Default actions that leave the machine
Message-ID: <AANLkTim_c7XNGqdpN9j=vMs3gTZuA-zLKgEhpyLvMPUr@mail.gmail.com>

Hello,

I want to embed a default action into a machine that leaves the
machine (without using manual a jump inside the action).

For simplicities sake, I will call this operator $^^ (since it is
similar to the Local Error operator).


Example:

action parse_error {}
helloworld = ('HELLO ' %^^parse_error) 'WORLD';

Non-error inputs include:
HELLO WORLD
HELLOWORLD (parse_error action occurs on 'O' -> 'W' transition)
HELLWORLD (parse_error action occurs on 'L' -> 'W' transition)
HELWORLD (parse_error action occurs on 'L' -> 'W' transition)
HEWORLD (parse_error action occurs on 'E' -> 'W' transition)
HWORLD (parse_error action occurs on 'H' -> 'W' transition)
WORLD (parse_error action occurs on -> 'W' transition)


I can simulate the above behavior with the '?' operator, but that is
laborious, and there are other ways of using $^^ that I suspect cannot
be simulated.


I want this operator because I am trying to make a liberal parser that
accepts all possible input. (Every state must have a default action)
.I am creating a html5 parser that uses regular machines for
tokenizing, and scanners built from the regular machines for parsing.
Yes, I am mad.

I cannot use manual jumps, because I don't want to jump out of the
scanners mid-token.


I am willing to try and add this operator into Ragel myself. I have
grabbed the source code and tracked my way to fsmap.cpp, where the new
operator would be added.

Before I continue...
Is there already a way to achieve my desired behavior that I am not aware of?
Would such an operator be worthwhile? Is it even possible?
Is there any knowledge that could be imparted that would help me make a patch?

If I do end up making a patch, for symmetry purposes I will make
global/local and start/any/final etc versions of the operator.

After a brief look through the source, it looks like I would need to
mod the FsmAp::fillGaps() function, passing in a (separate object for
each?) final state into the FsmAp::attachNewTrans() instead of NULL.

Ragel is a wonderful program by the way, thank you for creating it.

Cheers,
Murray

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From shatgeist at gmail.com  Fri Jan 28 07:38:55 2011
From: shatgeist at gmail.com (S.Geist)
Date: Fri, 28 Jan 2011 09:38:55 +0200
Subject: [ragel-users] Parser help
Message-ID: <AANLkTimmjdCYEJAT9tJz1ON_gEggaGODdJnH2Vai9AJ7@mail.gmail.com>

I'm trying to build a parser for text lines of the form:

=== line: {any chars here except \n} ===\n

I don't think I comprehend too well the way Ragel works, because I'm
failing miserably at my task.
Here's the code I've came up with: http://pastebin.com/rtp3dRSV

And the output:


$ echo "=== line: balpblap lapsl = klbokqe pblpel ===" | ./a.out
balpblap lapsl
balpblap lapsl = klbokqe pblpel
balpblap lapsl = klbokqe pblpel =
balpblap lapsl = klbokqe pblpel ==

What I need to do is extract the "{any chars here except \n}" part;
can anyone give me some hints on how to achieve this?

Thanks in advance!

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From adrian.thurston at esentire.com  Mon Jan 31 17:58:22 2011
From: adrian.thurston at esentire.com (Adrian Thurston)
Date: Mon, 31 Jan 2011 09:58:22 -0800
Subject: [ragel-users] Default actions that leave the machine
In-Reply-To: <AANLkTim_c7XNGqdpN9j=vMs3gTZuA-zLKgEhpyLvMPUr@mail.gmail.com>
References: <AANLkTim_c7XNGqdpN9j=vMs3gTZuA-zLKgEhpyLvMPUr@mail.gmail.com>
Message-ID: <4D46F83E.5040800@esentire.com>

Hi, have you looked at ragel's local and global error actions yet? These 
may do what you want.

-Adrian

On 11-01-26 08:08 PM, Murray Henderson wrote:
> Hello,
>
> I want to embed a default action into a machine that leaves the
> machine (without using manual a jump inside the action).
>
> For simplicities sake, I will call this operator $^^ (since it is
> similar to the Local Error operator).
>
>
> Example:
>
> action parse_error {}
> helloworld = ('HELLO ' %^^parse_error) 'WORLD';
>
> Non-error inputs include:
> HELLO WORLD
> HELLOWORLD (parse_error action occurs on 'O' ->  'W' transition)
> HELLWORLD (parse_error action occurs on 'L' ->  'W' transition)
> HELWORLD (parse_error action occurs on 'L' ->  'W' transition)
> HEWORLD (parse_error action occurs on 'E' ->  'W' transition)
> HWORLD (parse_error action occurs on 'H' ->  'W' transition)
> WORLD (parse_error action occurs on ->  'W' transition)
>
>
> I can simulate the above behavior with the '?' operator, but that is
> laborious, and there are other ways of using $^^ that I suspect cannot
> be simulated.
>
>
> I want this operator because I am trying to make a liberal parser that
> accepts all possible input. (Every state must have a default action)
> .I am creating a html5 parser that uses regular machines for
> tokenizing, and scanners built from the regular machines for parsing.
> Yes, I am mad.
>
> I cannot use manual jumps, because I don't want to jump out of the
> scanners mid-token.
>
>
> I am willing to try and add this operator into Ragel myself. I have
> grabbed the source code and tracked my way to fsmap.cpp, where the new
> operator would be added.
>
> Before I continue...
> Is there already a way to achieve my desired behavior that I am not aware of?
> Would such an operator be worthwhile? Is it even possible?
> Is there any knowledge that could be imparted that would help me make a patch?
>
> If I do end up making a patch, for symmetry purposes I will make
> global/local and start/any/final etc versions of the operator.
>
> After a brief look through the source, it looks like I would need to
> mod the FsmAp::fillGaps() function, passing in a (separate object for
> each?) final state into the FsmAp::attachNewTrans() instead of NULL.
>
> Ragel is a wonderful program by the way, thank you for creating it.
>
> Cheers,
> Murray
>
> _______________________________________________
> ragel-users mailing list
> ragel-users at complang.org
> http://www.complang.org/mailman/listinfo/ragel-users
>

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From adrian.thurston at esentire.com  Mon Jan 31 18:03:36 2011
From: adrian.thurston at esentire.com (Adrian Thurston)
Date: Mon, 31 Jan 2011 10:03:36 -0800
Subject: [ragel-users] Parser help
In-Reply-To: <AANLkTimmjdCYEJAT9tJz1ON_gEggaGODdJnH2Vai9AJ7@mail.gmail.com>
References: <AANLkTimmjdCYEJAT9tJz1ON_gEggaGODdJnH2Vai9AJ7@mail.gmail.com>
Message-ID: <4D46F978.8000700@esentire.com>

Hi,

The only way to do this is to either take a pointer to everything up to, 
but not including the newline, then chomp off the trailing '==='. This 
is because the state machine is capable of the representing the notion 
of being in more than one state at once, but the data collection 
mechanism is not. You can ask the pioneers of computer science why that 
is ;)

-Adrian

On 11-01-27 11:38 PM, S.Geist wrote:
> I'm trying to build a parser for text lines of the form:
>
> === line: {any chars here except \n} ===\n
>
> I don't think I comprehend too well the way Ragel works, because I'm
> failing miserably at my task.
> Here's the code I've came up with: http://pastebin.com/rtp3dRSV
>
> And the output:
>
>
> $ echo "=== line: balpblap lapsl = klbokqe pblpel ===" | ./a.out
> balpblap lapsl
> balpblap lapsl = klbokqe pblpel
> balpblap lapsl = klbokqe pblpel =
> balpblap lapsl = klbokqe pblpel ==
>
> What I need to do is extract the "{any chars here except \n}" part;
> can anyone give me some hints on how to achieve this?
>
> Thanks in advance!
>
> _______________________________________________
> ragel-users mailing list
> ragel-users at complang.org
> http://www.complang.org/mailman/listinfo/ragel-users
>

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From mail at murrayh.id.au  Mon Jan 31 22:58:56 2011
From: mail at murrayh.id.au (Murray Henderson)
Date: Tue, 1 Feb 2011 09:58:56 +1100
Subject: [ragel-users] Default actions that leave the machine
In-Reply-To: <4D46F83E.5040800@esentire.com>
References: <AANLkTim_c7XNGqdpN9j=vMs3gTZuA-zLKgEhpyLvMPUr@mail.gmail.com>
	<4D46F83E.5040800@esentire.com>
Message-ID: <AANLkTim4Wn2tAnjSYnPOpbJ55PJ5Xt+GHx9=t7i5uuca@mail.gmail.com>

Hello,

Local and global error actions transition to the error state.

I want DEF to transition to the next machine (ie. behave like a final
state), not the error state.

The parser I am writing is permissive, all input must be accepted (I
never want to goto the error state).

I do not wish to use manual goto recovery, because the parser is large
and complex, such manual tracking is a lot of work and error prone.

Cheers,
Murray



On Tue, Feb 1, 2011 at 4:58 AM, Adrian Thurston
<adrian.thurston at esentire.com> wrote:
> Hi, have you looked at ragel's local and global error actions yet? These may
> do what you want.
>
> -Adrian
>
> On 11-01-26 08:08 PM, Murray Henderson wrote:
>>
>> Hello,
>>
>> I want to embed a default action into a machine that leaves the
>> machine (without using manual a jump inside the action).
>>
>> For simplicities sake, I will call this operator $^^ (since it is
>> similar to the Local Error operator).
>>
>>
>> Example:
>>
>> action parse_error {}
>> helloworld = ('HELLO ' %^^parse_error) 'WORLD';
>>
>> Non-error inputs include:
>> HELLO WORLD
>> HELLOWORLD (parse_error action occurs on 'O' ->  'W' transition)
>> HELLWORLD (parse_error action occurs on 'L' ->  'W' transition)
>> HELWORLD (parse_error action occurs on 'L' ->  'W' transition)
>> HEWORLD (parse_error action occurs on 'E' ->  'W' transition)
>> HWORLD (parse_error action occurs on 'H' ->  'W' transition)
>> WORLD (parse_error action occurs on ->  'W' transition)
>>
>>
>> I can simulate the above behavior with the '?' operator, but that is
>> laborious, and there are other ways of using $^^ that I suspect cannot
>> be simulated.
>>
>>
>> I want this operator because I am trying to make a liberal parser that
>> accepts all possible input. (Every state must have a default action)
>> .I am creating a html5 parser that uses regular machines for
>> tokenizing, and scanners built from the regular machines for parsing.
>> Yes, I am mad.
>>
>> I cannot use manual jumps, because I don't want to jump out of the
>> scanners mid-token.
>>
>>
>> I am willing to try and add this operator into Ragel myself. I have
>> grabbed the source code and tracked my way to fsmap.cpp, where the new
>> operator would be added.
>>
>> Before I continue...
>> Is there already a way to achieve my desired behavior that I am not aware
>> of?
>> Would such an operator be worthwhile? Is it even possible?
>> Is there any knowledge that could be imparted that would help me make a
>> patch?
>>
>> If I do end up making a patch, for symmetry purposes I will make
>> global/local and start/any/final etc versions of the operator.
>>
>> After a brief look through the source, it looks like I would need to
>> mod the FsmAp::fillGaps() function, passing in a (separate object for
>> each?) final state into the FsmAp::attachNewTrans() instead of NULL.
>>
>> Ragel is a wonderful program by the way, thank you for creating it.
>>
>> Cheers,
>> Murray
>>
>> _______________________________________________
>> ragel-users mailing list
>> ragel-users at complang.org
>> http://www.complang.org/mailman/listinfo/ragel-users
>>
>
> _______________________________________________
> ragel-users mailing list
> ragel-users at complang.org
> http://www.complang.org/mailman/listinfo/ragel-users
>

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From thurston at complang.org  Mon Jan 31 23:02:47 2011
From: thurston at complang.org (Adrian Thurston)
Date: Mon, 31 Jan 2011 15:02:47 -0800
Subject: [ragel-users] Default actions that leave the machine
In-Reply-To: <AANLkTim4Wn2tAnjSYnPOpbJ55PJ5Xt+GHx9=t7i5uuca@mail.gmail.com>
References: <AANLkTim_c7XNGqdpN9j=vMs3gTZuA-zLKgEhpyLvMPUr@mail.gmail.com>	<4D46F83E.5040800@esentire.com>
	<AANLkTim4Wn2tAnjSYnPOpbJ55PJ5Xt+GHx9=t7i5uuca@mail.gmail.com>
Message-ID: <4D473F97.1000509@complang.org>

Local error actions don't. Sorry I should have suggested just those.

On 11-01-31 02:58 PM, Murray Henderson wrote:
> Hello,
>
> Local and global error actions transition to the error state.
>
> I want DEF to transition to the next machine (ie. behave like a final
> state), not the error state.
>
> The parser I am writing is permissive, all input must be accepted (I
> never want to goto the error state).
>
> I do not wish to use manual goto recovery, because the parser is large
> and complex, such manual tracking is a lot of work and error prone.
>
> Cheers,
> Murray
>
>
>
> On Tue, Feb 1, 2011 at 4:58 AM, Adrian Thurston
> <adrian.thurston at esentire.com>  wrote:
>> Hi, have you looked at ragel's local and global error actions yet? These may
>> do what you want.
>>
>> -Adrian
>>
>> On 11-01-26 08:08 PM, Murray Henderson wrote:
>>>
>>> Hello,
>>>
>>> I want to embed a default action into a machine that leaves the
>>> machine (without using manual a jump inside the action).
>>>
>>> For simplicities sake, I will call this operator $^^ (since it is
>>> similar to the Local Error operator).
>>>
>>>
>>> Example:
>>>
>>> action parse_error {}
>>> helloworld = ('HELLO ' %^^parse_error) 'WORLD';
>>>
>>> Non-error inputs include:
>>> HELLO WORLD
>>> HELLOWORLD (parse_error action occurs on 'O' ->    'W' transition)
>>> HELLWORLD (parse_error action occurs on 'L' ->    'W' transition)
>>> HELWORLD (parse_error action occurs on 'L' ->    'W' transition)
>>> HEWORLD (parse_error action occurs on 'E' ->    'W' transition)
>>> HWORLD (parse_error action occurs on 'H' ->    'W' transition)
>>> WORLD (parse_error action occurs on ->    'W' transition)
>>>
>>>
>>> I can simulate the above behavior with the '?' operator, but that is
>>> laborious, and there are other ways of using $^^ that I suspect cannot
>>> be simulated.
>>>
>>>
>>> I want this operator because I am trying to make a liberal parser that
>>> accepts all possible input. (Every state must have a default action)
>>> .I am creating a html5 parser that uses regular machines for
>>> tokenizing, and scanners built from the regular machines for parsing.
>>> Yes, I am mad.
>>>
>>> I cannot use manual jumps, because I don't want to jump out of the
>>> scanners mid-token.
>>>
>>>
>>> I am willing to try and add this operator into Ragel myself. I have
>>> grabbed the source code and tracked my way to fsmap.cpp, where the new
>>> operator would be added.
>>>
>>> Before I continue...
>>> Is there already a way to achieve my desired behavior that I am not aware
>>> of?
>>> Would such an operator be worthwhile? Is it even possible?
>>> Is there any knowledge that could be imparted that would help me make a
>>> patch?
>>>
>>> If I do end up making a patch, for symmetry purposes I will make
>>> global/local and start/any/final etc versions of the operator.
>>>
>>> After a brief look through the source, it looks like I would need to
>>> mod the FsmAp::fillGaps() function, passing in a (separate object for
>>> each?) final state into the FsmAp::attachNewTrans() instead of NULL.
>>>
>>> Ragel is a wonderful program by the way, thank you for creating it.
>>>
>>> Cheers,
>>> Murray
>>>
>>> _______________________________________________
>>> ragel-users mailing list
>>> ragel-users at complang.org
>>> http://www.complang.org/mailman/listinfo/ragel-users
>>>
>>
>> _______________________________________________
>> ragel-users mailing list
>> ragel-users at complang.org
>> http://www.complang.org/mailman/listinfo/ragel-users
>>
>
> _______________________________________________
> ragel-users mailing list
> ragel-users at complang.org
> http://www.complang.org/mailman/listinfo/ragel-users

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From mail at murrayh.id.au  Mon Jan 31 23:50:32 2011
From: mail at murrayh.id.au (Murray Henderson)
Date: Tue, 1 Feb 2011 10:50:32 +1100
Subject: [ragel-users] Default actions that leave the machine
In-Reply-To: <4D473F97.1000509@complang.org>
References: <AANLkTim_c7XNGqdpN9j=vMs3gTZuA-zLKgEhpyLvMPUr@mail.gmail.com>
	<4D46F83E.5040800@esentire.com>
	<AANLkTim4Wn2tAnjSYnPOpbJ55PJ5Xt+GHx9=t7i5uuca@mail.gmail.com>
	<4D473F97.1000509@complang.org>
Message-ID: <AANLkTimHVYZjY1ju_RzMRHkOK6_64kXA1ENc7nXY73G8@mail.gmail.com>

Hello,

Both local and global error actions transition to the error state. I
am using Ragel 6.5. I can try with 6.6 when I get home.

I made a quick example (based off S. Geist's example):

http://pastebin.com/06ihRxQg

Example output:

HELLO WORLD
read: HELLO WORLD
len: 12, state: 12
HELWORLD
parse error
read: HEL
len: 3, state: 0


Cheers,
Murray


On Tue, Feb 1, 2011 at 10:02 AM, Adrian Thurston <thurston at complang.org> wrote:
> Local error actions don't. Sorry I should have suggested just those.
>
> On 11-01-31 02:58 PM, Murray Henderson wrote:
>>
>> Hello,
>>
>> Local and global error actions transition to the error state.
>>
>> I want DEF to transition to the next machine (ie. behave like a final
>> state), not the error state.
>>
>> The parser I am writing is permissive, all input must be accepted (I
>> never want to goto the error state).
>>
>> I do not wish to use manual goto recovery, because the parser is large
>> and complex, such manual tracking is a lot of work and error prone.
>>
>> Cheers,
>> Murray
>>
>>
>>
>> On Tue, Feb 1, 2011 at 4:58 AM, Adrian Thurston
>> <adrian.thurston at esentire.com>  wrote:
>>>
>>> Hi, have you looked at ragel's local and global error actions yet? These
>>> may
>>> do what you want.
>>>
>>> -Adrian
>>>
>>> On 11-01-26 08:08 PM, Murray Henderson wrote:
>>>>
>>>> Hello,
>>>>
>>>> I want to embed a default action into a machine that leaves the
>>>> machine (without using manual a jump inside the action).
>>>>
>>>> For simplicities sake, I will call this operator $^^ (since it is
>>>> similar to the Local Error operator).
>>>>
>>>>
>>>> Example:
>>>>
>>>> action parse_error {}
>>>> helloworld = ('HELLO ' %^^parse_error) 'WORLD';
>>>>
>>>> Non-error inputs include:
>>>> HELLO WORLD
>>>> HELLOWORLD (parse_error action occurs on 'O' ->    'W' transition)
>>>> HELLWORLD (parse_error action occurs on 'L' ->    'W' transition)
>>>> HELWORLD (parse_error action occurs on 'L' ->    'W' transition)
>>>> HEWORLD (parse_error action occurs on 'E' ->    'W' transition)
>>>> HWORLD (parse_error action occurs on 'H' ->    'W' transition)
>>>> WORLD (parse_error action occurs on ->    'W' transition)
>>>>
>>>>
>>>> I can simulate the above behavior with the '?' operator, but that is
>>>> laborious, and there are other ways of using $^^ that I suspect cannot
>>>> be simulated.
>>>>
>>>>
>>>> I want this operator because I am trying to make a liberal parser that
>>>> accepts all possible input. (Every state must have a default action)
>>>> .I am creating a html5 parser that uses regular machines for
>>>> tokenizing, and scanners built from the regular machines for parsing.
>>>> Yes, I am mad.
>>>>
>>>> I cannot use manual jumps, because I don't want to jump out of the
>>>> scanners mid-token.
>>>>
>>>>
>>>> I am willing to try and add this operator into Ragel myself. I have
>>>> grabbed the source code and tracked my way to fsmap.cpp, where the new
>>>> operator would be added.
>>>>
>>>> Before I continue...
>>>> Is there already a way to achieve my desired behavior that I am not
>>>> aware
>>>> of?
>>>> Would such an operator be worthwhile? Is it even possible?
>>>> Is there any knowledge that could be imparted that would help me make a
>>>> patch?
>>>>
>>>> If I do end up making a patch, for symmetry purposes I will make
>>>> global/local and start/any/final etc versions of the operator.
>>>>
>>>> After a brief look through the source, it looks like I would need to
>>>> mod the FsmAp::fillGaps() function, passing in a (separate object for
>>>> each?) final state into the FsmAp::attachNewTrans() instead of NULL.
>>>>
>>>> Ragel is a wonderful program by the way, thank you for creating it.
>>>>
>>>> Cheers,
>>>> Murray
>>>>
>>>> _______________________________________________
>>>> ragel-users mailing list
>>>> ragel-users at complang.org
>>>> http://www.complang.org/mailman/listinfo/ragel-users
>>>>
>>>
>>> _______________________________________________
>>> ragel-users mailing list
>>> ragel-users at complang.org
>>> http://www.complang.org/mailman/listinfo/ragel-users
>>>
>>
>> _______________________________________________
>> ragel-users mailing list
>> ragel-users at complang.org
>> http://www.complang.org/mailman/listinfo/ragel-users
>
> _______________________________________________
> ragel-users mailing list
> ragel-users at complang.org
> http://www.complang.org/mailman/listinfo/ragel-users
>

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From b at bvanderveen.com  Thu Jan 20 23:26:40 2011
From: b at bvanderveen.com (Benjamin van der Veen)
Date: Thu, 20 Jan 2011 15:26:40 -0800
Subject: [ragel-users] EOF actions and buffering
Message-ID: <7CC9944D-D646-42E4-8F5E-0DA96D4491F3@bvanderveen.com>

Hello,

I am using Ragel to make an HTTP parser. Feel free to tell me this is a terrible idea. ;)

It seems to me that a common problem faced by users of Ragel is that they do not know in advance where (with respect to the grammar being parsed) the boundaries of buffers that they feed the parser are going to be. For example, I can easily make a Ragel grammar which will parse the following using only entering and leaving actions:

"GET /foo HTTP/1.1\r\nBar: Baz\r\n\r\n"

However the parser breaks if I feed it the same data across multiple buffers (as would be the case when reading chunks of data from a network socket):

"GE"
"T /f"
"oo HTTP/1.1\r"
"\nBar: Baz\r\n\r\n"

I found that this can be mitigated against by using EOF-leaving actions (%/some_action) and always setting eof to pe to cause the EOF-leaving actions to occur. However I'm finding that it isn't consistent and leads to unexpected behavior in some cases. Note that I am using the regular expression syntax, not the state chart syntax.

What is the recommended approach to this problem? My intuition is that a properly-specified state machine should work regardless of how data is fed to it and Ragel should make this opaque to the user—it seems to me that processing data across multiple buffers would be a very common problem that Ragel would solve for the user, but I may be mistaken.

In general I'm rather confused about how EOF actions are handled and when entering or leaving actions are treated as EOF actions. I've pored over the manual but I feel like it's all predicated on some knowledge that I don't have and am unsure where to look to find. In particular the first two paragraphs of section 3.1.4 (Leaving Actions) are almost completely opaque to me.

Cheers!
Benjamin van der Veen
_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From ibc at aliax.net  Thu Jan 20 23:31:36 2011
From: ibc at aliax.net (=?UTF-8?Q?I=C3=B1aki_Baz_Castillo?=)
Date: Fri, 21 Jan 2011 00:31:36 +0100
Subject: [ragel-users] EOF actions and buffering
In-Reply-To: <7CC9944D-D646-42E4-8F5E-0DA96D4491F3@bvanderveen.com>
References: <7CC9944D-D646-42E4-8F5E-0DA96D4491F3@bvanderveen.com>
Message-ID: <AANLkTinphQSnNomNenO-nhpodxxUnvDvy5a-6CAJ8O3C@mail.gmail.com>

2011/1/21 Benjamin van der Veen <b at bvanderveen.com>:
> Hello,
>
> I am using Ragel to make an HTTP parser. Feel free to tell me this is a terrible idea. ;)

It's a very good idea :)


> It seems to me that a common problem faced by users of Ragel is that they do not know in advance where (with respect to the grammar being parsed) the boundaries of buffers that they feed the parser are going to be. For example, I can easily make a Ragel grammar which will parse the following using only entering and leaving actions:

I recommend you checking Mongrel HTTP parser, which is written in C
and it used to build a Ruby object containing parsed data. However the
parser is a separate file(s) you really can learn from.


-- 
Iñaki Baz Castillo
<ibc at aliax.net>

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users

From adrian.thurston at esentire.com  Thu Jan 20 23:43:47 2011
From: adrian.thurston at esentire.com (Adrian Thurston)
Date: Thu, 20 Jan 2011 15:43:47 -0800
Subject: [ragel-users] EOF actions and buffering
In-Reply-To: <7CC9944D-D646-42E4-8F5E-0DA96D4491F3@bvanderveen.com>
References: <7CC9944D-D646-42E4-8F5E-0DA96D4491F3@bvanderveen.com>
Message-ID: <4D38C8B3.8060506@esentire.com>

It is indeed a common problem. It is purposefully left in the hands of 
the programmer. This is due to a few factors.

-There is no general solution that doesn't involve memory allocation.
-There are many different ways to approach memory allocation
-There are many use cases that have always input in one buffer

When I need a general solution I use automatically growing buffers (to a 
limit). See the DSNPd source for an example. I don't think that buffer 
class is limited, but it should be.

http://svn.complang.org/choicesocial/trunk/dsnpd/parser.rl

There are other approaches though. See the Ragel manual (5.9) for a 
short discussion.

Regards,
  Adrian

On 11-01-20 03:26 PM, Benjamin van der Veen wrote:
> Hello,
>
> I am using Ragel to make an HTTP parser. Feel free to tell me this is a terrible idea. ;)
>
> It seems to me that a common problem faced by users of Ragel is that they do not know in advance where (with respect to the grammar being parsed) the boundaries of buffers that they feed the parser are going to be. For example, I can easily make a Ragel grammar which will parse the following using only entering and leaving actions:
>
> "GET /foo HTTP/1.1\r\nBar: Baz\r\n\r\n"
>
> However the parser breaks if I feed it the same data across multiple buffers (as would be the case when reading chunks of data from a network socket):
>
> "GE"
> "T /f"
> "oo HTTP/1.1\r"
> "\nBar: Baz\r\n\r\n"
>
> I found that this can be mitigated against by using EOF-leaving actions (%/some_action) and always setting eof to pe to cause the EOF-leaving actions to occur. However I'm finding that it isn't consistent and leads to unexpected behavior in some cases. Note that I am using the regular expression syntax, not the state chart syntax.
>
> What is the recommended approach to this problem? My intuition is that a properly-specified state machine should work regardless of how data is fed to it and Ragel should make this opaque to the user—it seems to me that processing data across multiple buffers would be a very common problem that Ragel would solve for the user, but I may be mistaken.
>
> In general I'm rather confused about how EOF actions are handled and when entering or leaving actions are treated as EOF actions. I've pored over the manual but I feel like it's all predicated on some knowledge that I don't have and am unsure where to look to find. In particular the first two paragraphs of section 3.1.4 (Leaving Actions) are almost completely opaque to me.
>
> Cheers!
> Benjamin van der Veen
> _______________________________________________
> ragel-users mailing list
> ragel-users at complang.org
> http://www.complang.org/mailman/listinfo/ragel-users
>

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From b at bvanderveen.com  Fri Jan 21 00:15:08 2011
From: b at bvanderveen.com (Benjamin van der Veen)
Date: Thu, 20 Jan 2011 16:15:08 -0800
Subject: [ragel-users] EOF actions and buffering
In-Reply-To: <AANLkTinphQSnNomNenO-nhpodxxUnvDvy5a-6CAJ8O3C@mail.gmail.com>
References: <7CC9944D-D646-42E4-8F5E-0DA96D4491F3@bvanderveen.com>
	<AANLkTinphQSnNomNenO-nhpodxxUnvDvy5a-6CAJ8O3C@mail.gmail.com>
Message-ID: <A31F9618-99EE-4F93-9E81-2205F8493C5B@bvanderveen.com>


On Jan 20, 2011, at 3:31 PM, Iñaki Baz Castillo wrote:

> 2011/1/21 Benjamin van der Veen <b at bvanderveen.com>:
> 
>> It seems to me that a common problem faced by users of Ragel is that they do not know in advance where (with respect to the grammar being parsed) the boundaries of buffers that they feed the parser are going to be. For example, I can easily make a Ragel grammar which will parse the following using only entering and leaving actions:
> 
> I recommend you checking Mongrel HTTP parser, which is written in C
> and it used to build a Ruby object containing parsed data. However the
> parser is a separate file(s) you really can learn from.

Mongrel is where I got the idea from, although it seems to buffer the entirety of the request headers to work around this problem. I would like to avoid this solution if possible.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.colm.net/pipermail/ragel-users/attachments/20110120/3b0fadfa/attachment-0001.html>
-------------- next part --------------
_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users

From b at bvanderveen.com  Fri Jan 21 02:52:09 2011
From: b at bvanderveen.com (Benjamin van der Veen)
Date: Thu, 20 Jan 2011 18:52:09 -0800
Subject: [ragel-users] EOF actions and buffering
In-Reply-To: <4D38C8B3.8060506@esentire.com>
References: <7CC9944D-D646-42E4-8F5E-0DA96D4491F3@bvanderveen.com>
	<4D38C8B3.8060506@esentire.com>
Message-ID: <DD7FA35D-D1C6-4012-8164-0C5BE452B2D1@bvanderveen.com>

Thanks for the tips, Adrian.

I've poked through the material you referenced and gleaned a bit. Please check my understanding and let me know if something is missing.

On Jan 20, 2011, at 3:43 PM, Adrian Thurston wrote:
> http://svn.complang.org/choicesocial/trunk/dsnpd/parser.rl

The parser impl referenced above uses an intermediary buffer; it clears the intermediary buffer on the "enter" action of a token to be extracted, copies each character of the token into a buffer on the "any" action, and when the "leaving" action is executed, the contents of that intermediary buffer are then copied into the destination string. Will this approach will work regardless of buffer boundaries?

> There are other approaches though. See the Ragel manual (5.9) for a short discussion.

This approach requires the user to make sure the ts pointer remains valid in the buffer provided each time the machine is executed (which depending on how you're handing IO may mean some memory copying). It allows an action to have access to the a contiguous block of memory (given by ts and fpc) which defines the matched token. Does this approach only work with the state chart syntax?






_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From thurston at complang.org  Sat Jan 22 18:10:25 2011
From: thurston at complang.org (Adrian Thurston)
Date: Sat, 22 Jan 2011 10:10:25 -0800
Subject: [ragel-users] EOF actions and buffering
In-Reply-To: <DD7FA35D-D1C6-4012-8164-0C5BE452B2D1@bvanderveen.com>
References: <7CC9944D-D646-42E4-8F5E-0DA96D4491F3@bvanderveen.com>	<4D38C8B3.8060506@esentire.com>
	<DD7FA35D-D1C6-4012-8164-0C5BE452B2D1@bvanderveen.com>
Message-ID: <4D3B1D91.8050409@complang.org>

On 11-01-20 06:52 PM, Benjamin van der Veen wrote:
> The parser impl referenced above uses an intermediary buffer; it clears the intermediary buffer on the "enter" action of a token to be extracted, copies each character of the token into a buffer on the "any" action, and when the "leaving" action is executed, the contents of that intermediary buffer are then copied into the destination string. Will this approach will work regardless of buffer boundaries?

That is correct.

> This approach requires the user to make sure the ts pointer remains valid in the buffer provided each time the machine is executed (which depending on how you're handing IO may mean some memory copying). It allows an action to have access to the a contiguous block of memory (given by ts and fpc) which defines the matched token. Does this approach only work with the state chart syntax?

You can do it manually. The ts pointer is set with what is essentially 
an entering action. See cppscan2.rl for an example.

http://svn.complang.org/ragel/trunk/test/cppscan2.rl

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From pgervais at xplornet.com  Mon Jan 24 19:51:02 2011
From: pgervais at xplornet.com (Peter Gervais)
Date: Mon, 24 Jan 2011 14:51:02 -0500
Subject: [ragel-users] Detecting failure state
Message-ID: <38A0E247-F4BE-4BC1-8855-F419457B8848@xplornet.com>

Adrien,
   I need to know in which state of the state machine where a parsing error has occurred. Once an error has occurred, i need to be able to map the failure state number to the actual rule where the failure has occurred i.e. its not much use printing out failure in state X. It would much better if we could print out the text of the exact rule where the failure happened.  
1) Is there support for this at this time? 
2) What is the best way to do this ?
3) is there a place i can pick up the latest source for ragel which includes any patches you may have made without having to patch it myself? i.e. a complete tar bundle of the very latest work?

Peter Gervais
17621 Island Rd, 
RR#1 Martintown, Ontario
Bus: 1-613-938-6549
Cell: 1-613-864-7370
pgervais at xplornet.com




_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From joseph.stewart at gmail.com  Mon Jan 24 20:03:52 2011
From: joseph.stewart at gmail.com (Joseph Stewart)
Date: Mon, 24 Jan 2011 15:03:52 -0500
Subject: [ragel-users] Research on adding a new language...
Message-ID: <AANLkTik826Y50UuC74rH4b0Xkzs54942b9fkQWH-R5yT@mail.gmail.com>

Ragel-ers:

Has anyone on this list tinkered with creating a ragel mod to support the
Limbo programming language (
http://en.wikipedia.org/wiki/Limbo_(programming_language))?

It's relatively C-like.

Any advice on how much effort adding a new language takes?

Any pointers will be greatly appreciated!

-joe
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.colm.net/pipermail/ragel-users/attachments/20110124/2b4a27ca/attachment-0001.html>
-------------- next part --------------
_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users

From thurston at complang.org  Tue Jan 25 02:34:39 2011
From: thurston at complang.org (thurston at complang.org)
Date: Tue, 25 Jan 2011 02:34:39 +0000
Subject: [ragel-users] Detecting failure state
Message-ID: <1640517278-1295922862-cardhu_decombobulator_blackberry.rim.net-167449441-@bda2250.bisx.prod.on.blackberry>

Hi Peter, there is no automatic method of obtaining this information. Search the mailing list for 'mapping' and 'state' to learn why. You have to use actions for this.

Adrian
------Original Message------
From: Peter Gervais
Sender: ragel-users-bounces at complang.org
To: ragel-users at complang.org
ReplyTo: ragel-users at complang.org
Subject: [ragel-users] Detecting failure state
Sent: Jan 24, 2011 11:51 AM

Adrien,
   I need to know in which state of the state machine where a parsing error has occurred. Once an error has occurred, i need to be able to map the failure state number to the actual rule where the failure has occurred i.e. its not much use printing out failure in state X. It would much better if we could print out the text of the exact rule where the failure happened.  
1) Is there support for this at this time? 
2) What is the best way to do this ?
3) is there a place i can pick up the latest source for ragel which includes any patches you may have made without having to patch it myself? i.e. a complete tar bundle of the very latest work?

Peter Gervais
17621 Island Rd, 
RR#1 Martintown, Ontario
Bus: 1-613-938-6549
Cell: 1-613-864-7370
pgervais at xplornet.com




_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From thurston at complang.org  Tue Jan 25 03:04:01 2011
From: thurston at complang.org (thurston at complang.org)
Date: Tue, 25 Jan 2011 03:04:01 +0000
Subject: [ragel-users] Research on adding a new language...
In-Reply-To: <AANLkTik826Y50UuC74rH4b0Xkzs54942b9fkQWH-R5yT@mail.gmail.com>
References: <AANLkTik826Y50UuC74rH4b0Xkzs54942b9fkQWH-R5yT@mail.gmail.com>
Message-ID: <226669571-1295924624-cardhu_decombobulator_blackberry.rim.net-1502481231-@bda2250.bisx.prod.on.blackberry>

Not that I'm aware of.

Basic rules for choosing a code generator to derive new ones from:

1. Had goto, use C
2. Has switch, use Java
3. Use Ruby.

-Adrian
-----Original Message-----
From: Joseph Stewart <joseph.stewart at gmail.com>
Sender: ragel-users-bounces at complang.org
Date: Mon, 24 Jan 2011 15:03:52 
To: <ragel-users at complang.org>
Reply-To: ragel-users at complang.org
Subject: [ragel-users] Research on adding a new language...

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users



_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From mail at murrayh.id.au  Thu Jan 27 04:08:31 2011
From: mail at murrayh.id.au (Murray Henderson)
Date: Thu, 27 Jan 2011 15:08:31 +1100
Subject: [ragel-users] Default actions that leave the machine
Message-ID: <AANLkTim_c7XNGqdpN9j=vMs3gTZuA-zLKgEhpyLvMPUr@mail.gmail.com>

Hello,

I want to embed a default action into a machine that leaves the
machine (without using manual a jump inside the action).

For simplicities sake, I will call this operator $^^ (since it is
similar to the Local Error operator).


Example:

action parse_error {}
helloworld = ('HELLO ' %^^parse_error) 'WORLD';

Non-error inputs include:
HELLO WORLD
HELLOWORLD (parse_error action occurs on 'O' -> 'W' transition)
HELLWORLD (parse_error action occurs on 'L' -> 'W' transition)
HELWORLD (parse_error action occurs on 'L' -> 'W' transition)
HEWORLD (parse_error action occurs on 'E' -> 'W' transition)
HWORLD (parse_error action occurs on 'H' -> 'W' transition)
WORLD (parse_error action occurs on -> 'W' transition)


I can simulate the above behavior with the '?' operator, but that is
laborious, and there are other ways of using $^^ that I suspect cannot
be simulated.


I want this operator because I am trying to make a liberal parser that
accepts all possible input. (Every state must have a default action)
.I am creating a html5 parser that uses regular machines for
tokenizing, and scanners built from the regular machines for parsing.
Yes, I am mad.

I cannot use manual jumps, because I don't want to jump out of the
scanners mid-token.


I am willing to try and add this operator into Ragel myself. I have
grabbed the source code and tracked my way to fsmap.cpp, where the new
operator would be added.

Before I continue...
Is there already a way to achieve my desired behavior that I am not aware of?
Would such an operator be worthwhile? Is it even possible?
Is there any knowledge that could be imparted that would help me make a patch?

If I do end up making a patch, for symmetry purposes I will make
global/local and start/any/final etc versions of the operator.

After a brief look through the source, it looks like I would need to
mod the FsmAp::fillGaps() function, passing in a (separate object for
each?) final state into the FsmAp::attachNewTrans() instead of NULL.

Ragel is a wonderful program by the way, thank you for creating it.

Cheers,
Murray

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From shatgeist at gmail.com  Fri Jan 28 07:38:55 2011
From: shatgeist at gmail.com (S.Geist)
Date: Fri, 28 Jan 2011 09:38:55 +0200
Subject: [ragel-users] Parser help
Message-ID: <AANLkTimmjdCYEJAT9tJz1ON_gEggaGODdJnH2Vai9AJ7@mail.gmail.com>

I'm trying to build a parser for text lines of the form:

=== line: {any chars here except \n} ===\n

I don't think I comprehend too well the way Ragel works, because I'm
failing miserably at my task.
Here's the code I've came up with: http://pastebin.com/rtp3dRSV

And the output:


$ echo "=== line: balpblap lapsl = klbokqe pblpel ===" | ./a.out
balpblap lapsl
balpblap lapsl = klbokqe pblpel
balpblap lapsl = klbokqe pblpel =
balpblap lapsl = klbokqe pblpel ==

What I need to do is extract the "{any chars here except \n}" part;
can anyone give me some hints on how to achieve this?

Thanks in advance!

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From adrian.thurston at esentire.com  Mon Jan 31 17:58:22 2011
From: adrian.thurston at esentire.com (Adrian Thurston)
Date: Mon, 31 Jan 2011 09:58:22 -0800
Subject: [ragel-users] Default actions that leave the machine
In-Reply-To: <AANLkTim_c7XNGqdpN9j=vMs3gTZuA-zLKgEhpyLvMPUr@mail.gmail.com>
References: <AANLkTim_c7XNGqdpN9j=vMs3gTZuA-zLKgEhpyLvMPUr@mail.gmail.com>
Message-ID: <4D46F83E.5040800@esentire.com>

Hi, have you looked at ragel's local and global error actions yet? These 
may do what you want.

-Adrian

On 11-01-26 08:08 PM, Murray Henderson wrote:
> Hello,
>
> I want to embed a default action into a machine that leaves the
> machine (without using manual a jump inside the action).
>
> For simplicities sake, I will call this operator $^^ (since it is
> similar to the Local Error operator).
>
>
> Example:
>
> action parse_error {}
> helloworld = ('HELLO ' %^^parse_error) 'WORLD';
>
> Non-error inputs include:
> HELLO WORLD
> HELLOWORLD (parse_error action occurs on 'O' ->  'W' transition)
> HELLWORLD (parse_error action occurs on 'L' ->  'W' transition)
> HELWORLD (parse_error action occurs on 'L' ->  'W' transition)
> HEWORLD (parse_error action occurs on 'E' ->  'W' transition)
> HWORLD (parse_error action occurs on 'H' ->  'W' transition)
> WORLD (parse_error action occurs on ->  'W' transition)
>
>
> I can simulate the above behavior with the '?' operator, but that is
> laborious, and there are other ways of using $^^ that I suspect cannot
> be simulated.
>
>
> I want this operator because I am trying to make a liberal parser that
> accepts all possible input. (Every state must have a default action)
> .I am creating a html5 parser that uses regular machines for
> tokenizing, and scanners built from the regular machines for parsing.
> Yes, I am mad.
>
> I cannot use manual jumps, because I don't want to jump out of the
> scanners mid-token.
>
>
> I am willing to try and add this operator into Ragel myself. I have
> grabbed the source code and tracked my way to fsmap.cpp, where the new
> operator would be added.
>
> Before I continue...
> Is there already a way to achieve my desired behavior that I am not aware of?
> Would such an operator be worthwhile? Is it even possible?
> Is there any knowledge that could be imparted that would help me make a patch?
>
> If I do end up making a patch, for symmetry purposes I will make
> global/local and start/any/final etc versions of the operator.
>
> After a brief look through the source, it looks like I would need to
> mod the FsmAp::fillGaps() function, passing in a (separate object for
> each?) final state into the FsmAp::attachNewTrans() instead of NULL.
>
> Ragel is a wonderful program by the way, thank you for creating it.
>
> Cheers,
> Murray
>
> _______________________________________________
> ragel-users mailing list
> ragel-users at complang.org
> http://www.complang.org/mailman/listinfo/ragel-users
>

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From adrian.thurston at esentire.com  Mon Jan 31 18:03:36 2011
From: adrian.thurston at esentire.com (Adrian Thurston)
Date: Mon, 31 Jan 2011 10:03:36 -0800
Subject: [ragel-users] Parser help
In-Reply-To: <AANLkTimmjdCYEJAT9tJz1ON_gEggaGODdJnH2Vai9AJ7@mail.gmail.com>
References: <AANLkTimmjdCYEJAT9tJz1ON_gEggaGODdJnH2Vai9AJ7@mail.gmail.com>
Message-ID: <4D46F978.8000700@esentire.com>

Hi,

The only way to do this is to either take a pointer to everything up to, 
but not including the newline, then chomp off the trailing '==='. This 
is because the state machine is capable of the representing the notion 
of being in more than one state at once, but the data collection 
mechanism is not. You can ask the pioneers of computer science why that 
is ;)

-Adrian

On 11-01-27 11:38 PM, S.Geist wrote:
> I'm trying to build a parser for text lines of the form:
>
> === line: {any chars here except \n} ===\n
>
> I don't think I comprehend too well the way Ragel works, because I'm
> failing miserably at my task.
> Here's the code I've came up with: http://pastebin.com/rtp3dRSV
>
> And the output:
>
>
> $ echo "=== line: balpblap lapsl = klbokqe pblpel ===" | ./a.out
> balpblap lapsl
> balpblap lapsl = klbokqe pblpel
> balpblap lapsl = klbokqe pblpel =
> balpblap lapsl = klbokqe pblpel ==
>
> What I need to do is extract the "{any chars here except \n}" part;
> can anyone give me some hints on how to achieve this?
>
> Thanks in advance!
>
> _______________________________________________
> ragel-users mailing list
> ragel-users at complang.org
> http://www.complang.org/mailman/listinfo/ragel-users
>

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From mail at murrayh.id.au  Mon Jan 31 22:58:56 2011
From: mail at murrayh.id.au (Murray Henderson)
Date: Tue, 1 Feb 2011 09:58:56 +1100
Subject: [ragel-users] Default actions that leave the machine
In-Reply-To: <4D46F83E.5040800@esentire.com>
References: <AANLkTim_c7XNGqdpN9j=vMs3gTZuA-zLKgEhpyLvMPUr@mail.gmail.com>
	<4D46F83E.5040800@esentire.com>
Message-ID: <AANLkTim4Wn2tAnjSYnPOpbJ55PJ5Xt+GHx9=t7i5uuca@mail.gmail.com>

Hello,

Local and global error actions transition to the error state.

I want DEF to transition to the next machine (ie. behave like a final
state), not the error state.

The parser I am writing is permissive, all input must be accepted (I
never want to goto the error state).

I do not wish to use manual goto recovery, because the parser is large
and complex, such manual tracking is a lot of work and error prone.

Cheers,
Murray



On Tue, Feb 1, 2011 at 4:58 AM, Adrian Thurston
<adrian.thurston at esentire.com> wrote:
> Hi, have you looked at ragel's local and global error actions yet? These may
> do what you want.
>
> -Adrian
>
> On 11-01-26 08:08 PM, Murray Henderson wrote:
>>
>> Hello,
>>
>> I want to embed a default action into a machine that leaves the
>> machine (without using manual a jump inside the action).
>>
>> For simplicities sake, I will call this operator $^^ (since it is
>> similar to the Local Error operator).
>>
>>
>> Example:
>>
>> action parse_error {}
>> helloworld = ('HELLO ' %^^parse_error) 'WORLD';
>>
>> Non-error inputs include:
>> HELLO WORLD
>> HELLOWORLD (parse_error action occurs on 'O' ->  'W' transition)
>> HELLWORLD (parse_error action occurs on 'L' ->  'W' transition)
>> HELWORLD (parse_error action occurs on 'L' ->  'W' transition)
>> HEWORLD (parse_error action occurs on 'E' ->  'W' transition)
>> HWORLD (parse_error action occurs on 'H' ->  'W' transition)
>> WORLD (parse_error action occurs on ->  'W' transition)
>>
>>
>> I can simulate the above behavior with the '?' operator, but that is
>> laborious, and there are other ways of using $^^ that I suspect cannot
>> be simulated.
>>
>>
>> I want this operator because I am trying to make a liberal parser that
>> accepts all possible input. (Every state must have a default action)
>> .I am creating a html5 parser that uses regular machines for
>> tokenizing, and scanners built from the regular machines for parsing.
>> Yes, I am mad.
>>
>> I cannot use manual jumps, because I don't want to jump out of the
>> scanners mid-token.
>>
>>
>> I am willing to try and add this operator into Ragel myself. I have
>> grabbed the source code and tracked my way to fsmap.cpp, where the new
>> operator would be added.
>>
>> Before I continue...
>> Is there already a way to achieve my desired behavior that I am not aware
>> of?
>> Would such an operator be worthwhile? Is it even possible?
>> Is there any knowledge that could be imparted that would help me make a
>> patch?
>>
>> If I do end up making a patch, for symmetry purposes I will make
>> global/local and start/any/final etc versions of the operator.
>>
>> After a brief look through the source, it looks like I would need to
>> mod the FsmAp::fillGaps() function, passing in a (separate object for
>> each?) final state into the FsmAp::attachNewTrans() instead of NULL.
>>
>> Ragel is a wonderful program by the way, thank you for creating it.
>>
>> Cheers,
>> Murray
>>
>> _______________________________________________
>> ragel-users mailing list
>> ragel-users at complang.org
>> http://www.complang.org/mailman/listinfo/ragel-users
>>
>
> _______________________________________________
> ragel-users mailing list
> ragel-users at complang.org
> http://www.complang.org/mailman/listinfo/ragel-users
>

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From thurston at complang.org  Mon Jan 31 23:02:47 2011
From: thurston at complang.org (Adrian Thurston)
Date: Mon, 31 Jan 2011 15:02:47 -0800
Subject: [ragel-users] Default actions that leave the machine
In-Reply-To: <AANLkTim4Wn2tAnjSYnPOpbJ55PJ5Xt+GHx9=t7i5uuca@mail.gmail.com>
References: <AANLkTim_c7XNGqdpN9j=vMs3gTZuA-zLKgEhpyLvMPUr@mail.gmail.com>	<4D46F83E.5040800@esentire.com>
	<AANLkTim4Wn2tAnjSYnPOpbJ55PJ5Xt+GHx9=t7i5uuca@mail.gmail.com>
Message-ID: <4D473F97.1000509@complang.org>

Local error actions don't. Sorry I should have suggested just those.

On 11-01-31 02:58 PM, Murray Henderson wrote:
> Hello,
>
> Local and global error actions transition to the error state.
>
> I want DEF to transition to the next machine (ie. behave like a final
> state), not the error state.
>
> The parser I am writing is permissive, all input must be accepted (I
> never want to goto the error state).
>
> I do not wish to use manual goto recovery, because the parser is large
> and complex, such manual tracking is a lot of work and error prone.
>
> Cheers,
> Murray
>
>
>
> On Tue, Feb 1, 2011 at 4:58 AM, Adrian Thurston
> <adrian.thurston at esentire.com>  wrote:
>> Hi, have you looked at ragel's local and global error actions yet? These may
>> do what you want.
>>
>> -Adrian
>>
>> On 11-01-26 08:08 PM, Murray Henderson wrote:
>>>
>>> Hello,
>>>
>>> I want to embed a default action into a machine that leaves the
>>> machine (without using manual a jump inside the action).
>>>
>>> For simplicities sake, I will call this operator $^^ (since it is
>>> similar to the Local Error operator).
>>>
>>>
>>> Example:
>>>
>>> action parse_error {}
>>> helloworld = ('HELLO ' %^^parse_error) 'WORLD';
>>>
>>> Non-error inputs include:
>>> HELLO WORLD
>>> HELLOWORLD (parse_error action occurs on 'O' ->    'W' transition)
>>> HELLWORLD (parse_error action occurs on 'L' ->    'W' transition)
>>> HELWORLD (parse_error action occurs on 'L' ->    'W' transition)
>>> HEWORLD (parse_error action occurs on 'E' ->    'W' transition)
>>> HWORLD (parse_error action occurs on 'H' ->    'W' transition)
>>> WORLD (parse_error action occurs on ->    'W' transition)
>>>
>>>
>>> I can simulate the above behavior with the '?' operator, but that is
>>> laborious, and there are other ways of using $^^ that I suspect cannot
>>> be simulated.
>>>
>>>
>>> I want this operator because I am trying to make a liberal parser that
>>> accepts all possible input. (Every state must have a default action)
>>> .I am creating a html5 parser that uses regular machines for
>>> tokenizing, and scanners built from the regular machines for parsing.
>>> Yes, I am mad.
>>>
>>> I cannot use manual jumps, because I don't want to jump out of the
>>> scanners mid-token.
>>>
>>>
>>> I am willing to try and add this operator into Ragel myself. I have
>>> grabbed the source code and tracked my way to fsmap.cpp, where the new
>>> operator would be added.
>>>
>>> Before I continue...
>>> Is there already a way to achieve my desired behavior that I am not aware
>>> of?
>>> Would such an operator be worthwhile? Is it even possible?
>>> Is there any knowledge that could be imparted that would help me make a
>>> patch?
>>>
>>> If I do end up making a patch, for symmetry purposes I will make
>>> global/local and start/any/final etc versions of the operator.
>>>
>>> After a brief look through the source, it looks like I would need to
>>> mod the FsmAp::fillGaps() function, passing in a (separate object for
>>> each?) final state into the FsmAp::attachNewTrans() instead of NULL.
>>>
>>> Ragel is a wonderful program by the way, thank you for creating it.
>>>
>>> Cheers,
>>> Murray
>>>
>>> _______________________________________________
>>> ragel-users mailing list
>>> ragel-users at complang.org
>>> http://www.complang.org/mailman/listinfo/ragel-users
>>>
>>
>> _______________________________________________
>> ragel-users mailing list
>> ragel-users at complang.org
>> http://www.complang.org/mailman/listinfo/ragel-users
>>
>
> _______________________________________________
> ragel-users mailing list
> ragel-users at complang.org
> http://www.complang.org/mailman/listinfo/ragel-users

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From mail at murrayh.id.au  Mon Jan 31 23:50:32 2011
From: mail at murrayh.id.au (Murray Henderson)
Date: Tue, 1 Feb 2011 10:50:32 +1100
Subject: [ragel-users] Default actions that leave the machine
In-Reply-To: <4D473F97.1000509@complang.org>
References: <AANLkTim_c7XNGqdpN9j=vMs3gTZuA-zLKgEhpyLvMPUr@mail.gmail.com>
	<4D46F83E.5040800@esentire.com>
	<AANLkTim4Wn2tAnjSYnPOpbJ55PJ5Xt+GHx9=t7i5uuca@mail.gmail.com>
	<4D473F97.1000509@complang.org>
Message-ID: <AANLkTimHVYZjY1ju_RzMRHkOK6_64kXA1ENc7nXY73G8@mail.gmail.com>

Hello,

Both local and global error actions transition to the error state. I
am using Ragel 6.5. I can try with 6.6 when I get home.

I made a quick example (based off S. Geist's example):

http://pastebin.com/06ihRxQg

Example output:

HELLO WORLD
read: HELLO WORLD
len: 12, state: 12
HELWORLD
parse error
read: HEL
len: 3, state: 0


Cheers,
Murray


On Tue, Feb 1, 2011 at 10:02 AM, Adrian Thurston <thurston at complang.org> wrote:
> Local error actions don't. Sorry I should have suggested just those.
>
> On 11-01-31 02:58 PM, Murray Henderson wrote:
>>
>> Hello,
>>
>> Local and global error actions transition to the error state.
>>
>> I want DEF to transition to the next machine (ie. behave like a final
>> state), not the error state.
>>
>> The parser I am writing is permissive, all input must be accepted (I
>> never want to goto the error state).
>>
>> I do not wish to use manual goto recovery, because the parser is large
>> and complex, such manual tracking is a lot of work and error prone.
>>
>> Cheers,
>> Murray
>>
>>
>>
>> On Tue, Feb 1, 2011 at 4:58 AM, Adrian Thurston
>> <adrian.thurston at esentire.com>  wrote:
>>>
>>> Hi, have you looked at ragel's local and global error actions yet? These
>>> may
>>> do what you want.
>>>
>>> -Adrian
>>>
>>> On 11-01-26 08:08 PM, Murray Henderson wrote:
>>>>
>>>> Hello,
>>>>
>>>> I want to embed a default action into a machine that leaves the
>>>> machine (without using manual a jump inside the action).
>>>>
>>>> For simplicities sake, I will call this operator $^^ (since it is
>>>> similar to the Local Error operator).
>>>>
>>>>
>>>> Example:
>>>>
>>>> action parse_error {}
>>>> helloworld = ('HELLO ' %^^parse_error) 'WORLD';
>>>>
>>>> Non-error inputs include:
>>>> HELLO WORLD
>>>> HELLOWORLD (parse_error action occurs on 'O' ->    'W' transition)
>>>> HELLWORLD (parse_error action occurs on 'L' ->    'W' transition)
>>>> HELWORLD (parse_error action occurs on 'L' ->    'W' transition)
>>>> HEWORLD (parse_error action occurs on 'E' ->    'W' transition)
>>>> HWORLD (parse_error action occurs on 'H' ->    'W' transition)
>>>> WORLD (parse_error action occurs on ->    'W' transition)
>>>>
>>>>
>>>> I can simulate the above behavior with the '?' operator, but that is
>>>> laborious, and there are other ways of using $^^ that I suspect cannot
>>>> be simulated.
>>>>
>>>>
>>>> I want this operator because I am trying to make a liberal parser that
>>>> accepts all possible input. (Every state must have a default action)
>>>> .I am creating a html5 parser that uses regular machines for
>>>> tokenizing, and scanners built from the regular machines for parsing.
>>>> Yes, I am mad.
>>>>
>>>> I cannot use manual jumps, because I don't want to jump out of the
>>>> scanners mid-token.
>>>>
>>>>
>>>> I am willing to try and add this operator into Ragel myself. I have
>>>> grabbed the source code and tracked my way to fsmap.cpp, where the new
>>>> operator would be added.
>>>>
>>>> Before I continue...
>>>> Is there already a way to achieve my desired behavior that I am not
>>>> aware
>>>> of?
>>>> Would such an operator be worthwhile? Is it even possible?
>>>> Is there any knowledge that could be imparted that would help me make a
>>>> patch?
>>>>
>>>> If I do end up making a patch, for symmetry purposes I will make
>>>> global/local and start/any/final etc versions of the operator.
>>>>
>>>> After a brief look through the source, it looks like I would need to
>>>> mod the FsmAp::fillGaps() function, passing in a (separate object for
>>>> each?) final state into the FsmAp::attachNewTrans() instead of NULL.
>>>>
>>>> Ragel is a wonderful program by the way, thank you for creating it.
>>>>
>>>> Cheers,
>>>> Murray
>>>>
>>>> _______________________________________________
>>>> ragel-users mailing list
>>>> ragel-users at complang.org
>>>> http://www.complang.org/mailman/listinfo/ragel-users
>>>>
>>>
>>> _______________________________________________
>>> ragel-users mailing list
>>> ragel-users at complang.org
>>> http://www.complang.org/mailman/listinfo/ragel-users
>>>
>>
>> _______________________________________________
>> ragel-users mailing list
>> ragel-users at complang.org
>> http://www.complang.org/mailman/listinfo/ragel-users
>
> _______________________________________________
> ragel-users mailing list
> ragel-users at complang.org
> http://www.complang.org/mailman/listinfo/ragel-users
>

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


