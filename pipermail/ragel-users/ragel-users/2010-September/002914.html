<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [ragel-users] parser getting gigantic ?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:ragel-users%40colm.net?Subject=Re%3A%20%5Bragel-users%5D%20parser%20getting%20gigantic%20%3F&In-Reply-To=%3CAANLkTimCsQ4KhrQ9zbW9N09KP%2BHQnxaSY2CiPpBsK9r-%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002913.html">
   <LINK REL="Next"  HREF="002915.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[ragel-users] parser getting gigantic ?</H1>
    <B>M P</B> 
    <A HREF="mailto:ragel-users%40colm.net?Subject=Re%3A%20%5Bragel-users%5D%20parser%20getting%20gigantic%20%3F&In-Reply-To=%3CAANLkTimCsQ4KhrQ9zbW9N09KP%2BHQnxaSY2CiPpBsK9r-%40mail.gmail.com%3E"
       TITLE="[ragel-users] parser getting gigantic ?">buserror at gmail.com
       </A><BR>
    <I>Thu Sep  2 17:14:02 UTC 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="002913.html">[ragel-users] parser getting gigantic ?
</A></li>
        <LI>Next message: <A HREF="002915.html">[ragel-users] Writing a Telnet parser
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2914">[ date ]</a>
              <a href="thread.html#2914">[ thread ]</a>
              <a href="subject.html#2914">[ subject ]</a>
              <a href="author.html#2914">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I found one problem already,
&gt;<i>                string = '&quot;' ((([^&quot;] | '\&quot;')*) &gt;str_init %str_done)  '&quot;';
</I>Needs a '**'. That reduces the size considerably...

It's still &gt;100KB tho. I've been digging a bit, and there are a LOT of
instances of that &quot;W&quot; rule that gets inlined, even tho the output (and
the value) is just discarded.

I attempted to factor that a bit by doing :
eatme := space** @{ fret; }
W = '' @{ fcall eatme; }

But that didn't work... I wish we could mark a rule as &quot;discard,
factor&quot; or something...

Michael

On Thu, Sep 2, 2010 at 3:41 PM, M P &lt;<A HREF="http://www.colm.net/cgi-bin/mailman/listinfo/ragel-users">buserror at gmail.com</A>&gt; wrote:
&gt;<i> I decided to play with Ragel by making a parser for an extended
</I>&gt;<i> version of JSON.
</I>&gt;<i>
</I>&gt;<i> After falling into every single pitfall possible, I managed to get the
</I>&gt;<i> whole thing working pretty well, but I just had a look at the
</I>&gt;<i> generated code and it reached 600KB total, using -G1 (!)
</I>&gt;<i>
</I>&gt;<i> So, what am I doing wrong ? I'm certain there's probably a lot of
</I>&gt;<i> stuff wrong with the way I made the parser, but really, I'm not sure
</I>&gt;<i> what so having experts eyeballing this would be very nice...
</I>&gt;<i>
</I>&gt;<i> There are 2 different json parsers in the file; one is for the string
</I>&gt;<i> constants, one (the main one) is for the language proper...
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> /*
</I>&gt;<i>  * IF YOU ARE LOOKING AT A .c FILE, YOUR ARE LOOKING AT THE WRONG ONE
</I>&gt;<i>  *
</I>&gt;<i>  * This file is autogenerated from a .rl source file for 'ragel'
</I>&gt;<i> parser generator.
</I>&gt;<i>  */
</I>&gt;<i> #include &lt;stdlib.h&gt;
</I>&gt;<i> #include &lt;string.h&gt;
</I>&gt;<i> #include &lt;stdio.h&gt;
</I>&gt;<i>
</I>&gt;<i> #include &quot;json.h&quot;
</I>&gt;<i>
</I>&gt;<i> %%{
</I>&gt;<i>        machine json_str;
</I>&gt;<i>        write data;
</I>&gt;<i> }%%
</I>&gt;<i>
</I>&gt;<i> static char * json_append_utf8_glyph(
</I>&gt;<i>        char * dst,
</I>&gt;<i>        unsigned long inUnicode )
</I>&gt;<i> {
</I>&gt;<i>        if (!(inUnicode &amp; ~0x7f)) {
</I>&gt;<i>                *dst++ = ((char)inUnicode);
</I>&gt;<i>                return dst;     // that was easy
</I>&gt;<i>        }
</I>&gt;<i>        unsigned char *cur = dst;
</I>&gt;<i>
</I>&gt;<i>        unsigned long currentMask = ~0x7ff;
</I>&gt;<i>        int bits = 6;
</I>&gt;<i>        int header = 5;
</I>&gt;<i>
</I>&gt;<i>        while ((inUnicode &amp; currentMask) &amp;&amp; bits &lt;= 24) {
</I>&gt;<i>                currentMask = currentMask &lt;&lt; 6;
</I>&gt;<i>                bits += 6; header--;
</I>&gt;<i>        }
</I>&gt;<i>        *cur++ = (0xfe &lt;&lt; header) | (unsigned char)(inUnicode &gt;&gt; (bits));
</I>&gt;<i>        bits -= 6;
</I>&gt;<i>        while (bits &gt;= 0) {
</I>&gt;<i>                *cur++ = 0x80 | ((unsigned char)(inUnicode &gt;&gt; bits) &amp; 0x3f);
</I>&gt;<i>                bits -= 6;
</I>&gt;<i>        }
</I>&gt;<i>        return cur;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> int json_parse_string(char * str, char *end, char * out)
</I>&gt;<i> {
</I>&gt;<i>        char *p = str, *pe = end ? end : str + strlen( str ), *eof = pe;
</I>&gt;<i>        int cs;
</I>&gt;<i>        out = out ? out : str;
</I>&gt;<i>        uint16_t u;
</I>&gt;<i>        %%{
</I>&gt;<i>                machine json_str;
</I>&gt;<i>
</I>&gt;<i>                xxdigit = (
</I>&gt;<i>                        ([0-9] @{ u = (u &lt;&lt; 4) | fc - '0'; }) |
</I>&gt;<i>                        ([a-f] @{ u = (u &lt;&lt; 4) | fc - 'a' + 0xa; }) |
</I>&gt;<i>                        ([A-F] @{ u = (u &lt;&lt; 4) | fc - 'A' + 0xa; })
</I>&gt;<i>                );
</I>&gt;<i>                utf16 = ( xxdigit{4} ) &gt;{ u = 0; } @{ out = json_append_utf8_glyph(out, u); };
</I>&gt;<i>
</I>&gt;<i>                normal = any @{*out++ = fc;};
</I>&gt;<i>                escape =
</I>&gt;<i>                                ('\\' %{ *out++ = '\\'; } ) |
</I>&gt;<i>                                ('t' %{ *out++ = '\t'; } )  |
</I>&gt;<i>                                ('b' %{ *out++ = '\b'; } )  |
</I>&gt;<i>                                ('f' %{ *out++ = '\f'; } )  |
</I>&gt;<i>                                ('n' %{ *out++ = '\n'; } )  |
</I>&gt;<i>                                ('r' %{ *out++ = '\r'; } )  |
</I>&gt;<i>                                ('u' utf16 ) |
</I>&gt;<i>                                ( normal -- [\\tbfntu] )
</I>&gt;<i>                        ;
</I>&gt;<i>                main := (
</I>&gt;<i>                        ('\\' escape) |
</I>&gt;<i>                        ( normal -- '\\' )
</I>&gt;<i>                )*;
</I>&gt;<i>
</I>&gt;<i>                # Initialize and execute.
</I>&gt;<i>                write init;
</I>&gt;<i>                write exec;
</I>&gt;<i>        }%%
</I>&gt;<i>        *out = 0;
</I>&gt;<i>
</I>&gt;<i>        return 0;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> %%{
</I>&gt;<i>        machine json;
</I>&gt;<i>        write data;
</I>&gt;<i> }%%
</I>&gt;<i>
</I>&gt;<i> int json_parse( json_driver_t *d, char * str )
</I>&gt;<i> {
</I>&gt;<i>        char *p = str, *pe = str + strlen( str ), *eof = pe;
</I>&gt;<i>        int cs;
</I>&gt;<i>        int stack[32], top = 0;
</I>&gt;<i>        int integer_sign;       // for integer decode
</I>&gt;<i>        char * float_start;
</I>&gt;<i>        json_driver_value_t v;
</I>&gt;<i>        uint32_t b64;
</I>&gt;<i>        int b64_cnt;
</I>&gt;<i>
</I>&gt;<i>        %%{
</I>&gt;<i>                machine json;
</I>&gt;<i>                action obj_field_list_start { d-&gt;open_object(d); }
</I>&gt;<i>                action obj_field_list_done { d-&gt;close_object(d); }
</I>&gt;<i>                action obj_value_list_start { d-&gt;open_array(d); }
</I>&gt;<i>                action obj_value_list_done { d-&gt;close_array(d); }
</I>&gt;<i>                action obj_create_name { d-&gt;set_name(d, &amp;v); }
</I>&gt;<i>                action obj_set_flag { if (d-&gt;add_flag) d-&gt;add_flag(d, &amp;v); }
</I>&gt;<i>                action obj_set_string { d-&gt;set_value(d, json_driver_type_string, &amp;v); }
</I>&gt;<i>                action obj_set_integer { d-&gt;set_value(d, json_driver_type_integer, &amp;v); }
</I>&gt;<i>                action obj_set_float { d-&gt;set_value(d, json_driver_type_float, &amp;v); }
</I>&gt;<i>                action obj_set_hex { d-&gt;set_value(d, json_driver_type_hex, &amp;v); }
</I>&gt;<i>                action obj_set_true { v.u.v_bool = 1; d-&gt;set_value(d,
</I>&gt;<i> json_driver_type_bool, &amp;v); }
</I>&gt;<i>                action obj_set_false { v.u.v_bool = 0; d-&gt;set_value(d,
</I>&gt;<i> json_driver_type_bool, &amp;v); }
</I>&gt;<i>                action obj_set_null { d-&gt;set_value(d, json_driver_type_null, NULL); }
</I>&gt;<i>
</I>&gt;<i>                action obj_start_data { if (d-&gt;open_data) d-&gt;open_data(d); }
</I>&gt;<i>                action obj_flush_data { if (d-&gt;add_data) for (int s=16,i = 0;
</I>&gt;<i> i&lt;b64_cnt; i++,s-=8) d-&gt;add_data(d, (b64 &gt;&gt; s) &amp; 0xff); }
</I>&gt;<i>                action obj_end_data { if (d-&gt;close_data) d-&gt;close_data(d); }
</I>&gt;<i>
</I>&gt;<i>                W = [ \t\n]**;
</I>&gt;<i>
</I>&gt;<i>                #
</I>&gt;<i>                # quoted or unquoted string
</I>&gt;<i>                #
</I>&gt;<i>                action str_init { v.u.v_str.start = v.u.v_str.end = fpc; }
</I>&gt;<i>                action str_done { v.u.v_str.end = fpc; }
</I>&gt;<i>
</I>&gt;<i>                string = '&quot;' ((([^&quot;] | '\&quot;')*) &gt;str_init %str_done)  '&quot;';
</I>&gt;<i>                ident = ((alpha | '_') (alnum | '_')*) &gt;str_init %str_done;
</I>&gt;<i>
</I>&gt;<i>                #
</I>&gt;<i>                #       negative/positive Integer
</I>&gt;<i>                #
</I>&gt;<i>                action integer_init { v.u.v_int = 0; integer_sign = 1; }
</I>&gt;<i>                action integer_minus { integer_sign = -1; }
</I>&gt;<i>                action integer_digit { v.u.v_int = (v.u.v_int * 10) + (fc - '0'); }
</I>&gt;<i>                action integer_done {  v.u.v_int *= integer_sign; }
</I>&gt;<i>
</I>&gt;<i>                integer = (('-' @integer_minus | '+')? (digit+ @integer_digit))
</I>&gt;<i>                        &gt;integer_init %integer_done;
</I>&gt;<i>
</I>&gt;<i>                #
</I>&gt;<i>                # hex integer
</I>&gt;<i>                #
</I>&gt;<i>                xxdigit = (
</I>&gt;<i>                        ([0-9] @{ v.u.v_int = (v.u.v_int &lt;&lt; 4) | fc - '0'; }) |
</I>&gt;<i>                        ([a-f] @{ v.u.v_int = (v.u.v_int &lt;&lt; 4) | fc - 'a' + 0xa; }) |
</I>&gt;<i>                        ([A-F] @{ v.u.v_int = (v.u.v_int &lt;&lt; 4) | fc - 'A' + 0xa; })
</I>&gt;<i>                );
</I>&gt;<i>                hex = (('-' @integer_minus | '+')?( '0x' xxdigit+))
</I>&gt;<i>                        &gt;integer_init %integer_done;
</I>&gt;<i>
</I>&gt;<i>                #
</I>&gt;<i>                # float/double value
</I>&gt;<i>                #
</I>&gt;<i>                action float_init { float_start = fpc; }
</I>&gt;<i>                action float_done { sscanf(float_start, &quot;%lf&quot;, &amp;v.u.v_float); }
</I>&gt;<i>                #
</I>&gt;<i>                # float values
</I>&gt;<i>                #
</I>&gt;<i>                float = (
</I>&gt;<i>                        ('-' | '+')? digit* '.' digit+ [fd]?
</I>&gt;<i>                ) &gt;float_init %float_done;
</I>&gt;<i>
</I>&gt;<i>                #
</I>&gt;<i>                # base64 decoder
</I>&gt;<i>                #
</I>&gt;<i>                base64_char = (
</I>&gt;<i>                        ([A-Z] @{ b64 = (b64 &lt;&lt; 6) | (fc - 'A'); }) |
</I>&gt;<i>                        ([a-z] @{ b64 = (b64 &lt;&lt; 6) | (fc - 'a' + 26 ); }) |
</I>&gt;<i>                        ([0-9] @{ b64 = (b64 &lt;&lt; 6) | (fc - '0' + 52 ); }) |
</I>&gt;<i>                        ('+' @{ b64 = (b64 &lt;&lt; 6) | 62; }) |
</I>&gt;<i>                        ('/' @{ b64 = (b64 &lt;&lt; 6) | 63; })
</I>&gt;<i>                );
</I>&gt;<i>                base64_pad = '=' @{ b64 = (b64 &lt;&lt; 6); };
</I>&gt;<i>                base64_four = (
</I>&gt;<i>                        base64_char base64_char base64_char base64_char
</I>&gt;<i>                ) %{ b64_cnt = 3; } %obj_flush_data;
</I>&gt;<i>                base64_padder = (
</I>&gt;<i>                        base64_char base64_char
</I>&gt;<i>                        (
</I>&gt;<i>                                (( base64_char base64_pad )
</I>&gt;<i>                                        %{ b64_cnt = 2; } ) |
</I>&gt;<i>                                (( base64_pad base64_pad )
</I>&gt;<i>                                        %{ b64_cnt = 1; } )
</I>&gt;<i>                        )
</I>&gt;<i>                ) %obj_flush_data;
</I>&gt;<i>
</I>&gt;<i>                base64 = ( base64_four** (base64_four | base64_padder) ) &gt;{b64 = 0;}
</I>&gt;<i>                                %err{ printf(&quot;### base64 Error : '%s'\n&quot;, p); };
</I>&gt;<i>
</I>&gt;<i>                #
</I>&gt;<i>                # JSON value, extended
</I>&gt;<i>                #
</I>&gt;<i>                json_value = (
</I>&gt;<i>                        (string %obj_set_string) |
</I>&gt;<i>                        (integer %obj_set_integer) |
</I>&gt;<i>                        (hex %obj_set_hex ) |
</I>&gt;<i>                        (float %obj_set_float) |
</I>&gt;<i>                        ('true' %obj_set_true) |
</I>&gt;<i>                        ('false' %obj_set_false) |
</I>&gt;<i>                        ('null' %obj_set_null) |
</I>&gt;<i>                        ('{' @{ fhold; fcall obj_field_list; } ) |
</I>&gt;<i>                        ('[' @{ fhold; fcall json_value_list; } ) |
</I>&gt;<i>                        (('%' (W base64)* W '%') &gt;obj_start_data %obj_end_data)
</I>&gt;<i>                );
</I>&gt;<i>
</I>&gt;<i>                json_value_list := (
</I>&gt;<i>                        '[' (
</I>&gt;<i>                                '' |
</I>&gt;<i>                                (W json_value (W ',' W json_value)* )
</I>&gt;<i>                        ) W ','? W ']'
</I>&gt;<i>                ) &gt;obj_value_list_start @obj_value_list_done @{ fret; }
</I>&gt;<i>                                %err{ printf(&quot;### Array[%d] Error : '%s'\n&quot;, top, p); };
</I>&gt;<i>
</I>&gt;<i>                obj_field_flag = ( ident ) %obj_set_flag;
</I>&gt;<i>                obj_field_flags = (
</I>&gt;<i>                        '(' W obj_field_flag (W ',' W obj_field_flag)** ')'
</I>&gt;<i>                );
</I>&gt;<i>                obj_field = ((string | ident) %obj_create_name) W obj_field_flags? W
</I>&gt;<i> ':' W json_value;
</I>&gt;<i>
</I>&gt;<i>                obj_field_list := (
</I>&gt;<i>                        '{' (
</I>&gt;<i>                                '' |
</I>&gt;<i>                                (W obj_field (W ',' W obj_field)** )
</I>&gt;<i>                        ) W ','? W '}'
</I>&gt;<i>                ) &gt;obj_field_list_start @obj_field_list_done @{ fret; }
</I>&gt;<i>                                %err{ printf(&quot;### Object[%d] Error : '%s'\n&quot;, top, p); };
</I>&gt;<i>
</I>&gt;<i>                main := (
</I>&gt;<i>                        W json_value
</I>&gt;<i>                ) %err{ printf(&quot;### JSON Error : '%s'\n&quot;, p); };
</I>&gt;<i>
</I>&gt;<i>                # Initialize and execute.
</I>&gt;<i>                write init;
</I>&gt;<i>                write exec;
</I>&gt;<i>        }%%
</I>&gt;<i>
</I>&gt;<i>        return 0;
</I>&gt;<i> };
</I>&gt;<i>
</I>&gt;<i> #ifdef JSON_TEST_UNIT
</I>&gt;<i> static void d_set_name(struct json_driver_t *d,
</I>&gt;<i>                json_driver_value_t * v)
</I>&gt;<i> {
</I>&gt;<i>        int l = v-&gt;u.v_str.end - v-&gt;u.v_str.start;
</I>&gt;<i>        printf(&quot;\&quot;%*.*s\&quot;: &quot;, l, l, v-&gt;u.v_str.start);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> static void d_open_array(struct json_driver_t *d)
</I>&gt;<i> {
</I>&gt;<i>        printf(&quot;[&quot;);fflush(stdout);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> static void d_open_object(struct json_driver_t *d)
</I>&gt;<i> {
</I>&gt;<i>        printf(&quot;{&quot;);fflush(stdout);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> static void d_set_value(struct json_driver_t *d,
</I>&gt;<i>                int type,
</I>&gt;<i>                json_driver_value_t * v)
</I>&gt;<i> {
</I>&gt;<i>        switch (type) {
</I>&gt;<i>                case json_driver_type_null:
</I>&gt;<i>                        printf(&quot;null, &quot;);
</I>&gt;<i>                        break;
</I>&gt;<i>                case json_driver_type_bool:
</I>&gt;<i>                        printf(&quot;%s, &quot;, v-&gt;u.v_bool ? &quot;true&quot; : &quot;false&quot;);
</I>&gt;<i>                        break;
</I>&gt;<i>                case json_driver_type_integer:
</I>&gt;<i>                        printf(&quot;%d, &quot;, (int)v-&gt;u.v_int);
</I>&gt;<i>                        break;
</I>&gt;<i>                case json_driver_type_hex:
</I>&gt;<i>                        printf(&quot;0x%x, &quot;, (int)v-&gt;u.v_int);
</I>&gt;<i>                        break;
</I>&gt;<i>                case json_driver_type_float:
</I>&gt;<i>                        printf(&quot;%f, &quot;, (float)v-&gt;u.v_float);
</I>&gt;<i>                        break;
</I>&gt;<i>                case json_driver_type_string: {
</I>&gt;<i>                        char buf[256];
</I>&gt;<i>                        json_parse_string(v-&gt;u.v_str.start, v-&gt;u.v_str.end, buf);
</I>&gt;<i>                        printf(&quot;\&quot;%s\&quot;: &quot;, buf);
</I>&gt;<i>                }       break;
</I>&gt;<i>        }
</I>&gt;<i>        fflush(stdout);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> static void d_close_array(struct json_driver_t *d)
</I>&gt;<i> {
</I>&gt;<i>        printf(&quot;],&quot;);fflush(stdout);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> static void d_close_object(struct json_driver_t *d)
</I>&gt;<i> {
</I>&gt;<i>        printf(&quot;},&quot;);fflush(stdout);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> static void d_open_data(struct json_driver_t *d)
</I>&gt;<i> {
</I>&gt;<i>        printf(&quot;%% '&quot;);fflush(stdout);
</I>&gt;<i> }
</I>&gt;<i> static void d_add_data(struct json_driver_t *d, uint8_t data)
</I>&gt;<i> {
</I>&gt;<i>        printf(&quot;%c&quot;,data);fflush(stdout);
</I>&gt;<i> }
</I>&gt;<i> static void d_close_data(struct json_driver_t *d)
</I>&gt;<i> {
</I>&gt;<i>        printf(&quot;' %%,&quot;);fflush(stdout);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> json_driver_t driver = {
</I>&gt;<i>        .set_name = d_set_name,
</I>&gt;<i>        .open_array = d_open_array,
</I>&gt;<i>        .open_object = d_open_object,
</I>&gt;<i>        .set_value = d_set_value,
</I>&gt;<i>        .close_array = d_close_array,
</I>&gt;<i>        .close_object = d_close_object,
</I>&gt;<i>
</I>&gt;<i>        .open_data = d_open_data,
</I>&gt;<i>        .add_data = d_add_data,
</I>&gt;<i>        .close_data = d_close_data,
</I>&gt;<i> };
</I>&gt;<i>
</I>&gt;<i> int main(int argc, char * argv[])
</I>&gt;<i> {
</I>&gt;<i>
</I>&gt;<i>        for (int i = 1; i &lt; argc; i++) {
</I>&gt;<i>                printf(&quot;### parsing '%s'\n&quot;, argv[i]);
</I>&gt;<i>                json_parse(&amp;driver, argv[i]);printf(&quot;\n&quot;);
</I>&gt;<i>        }
</I>&gt;<i>        return 0;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> #endif
</I>&gt;<i>
</I>
_______________________________________________
ragel-users mailing list
<A HREF="http://www.colm.net/cgi-bin/mailman/listinfo/ragel-users">ragel-users at complang.org</A>
<A HREF="http://www.complang.org/mailman/listinfo/ragel-users">http://www.complang.org/mailman/listinfo/ragel-users</A>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002913.html">[ragel-users] parser getting gigantic ?
</A></li>
	<LI>Next message: <A HREF="002915.html">[ragel-users] Writing a Telnet parser
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2914">[ date ]</a>
              <a href="thread.html#2914">[ thread ]</a>
              <a href="subject.html#2914">[ subject ]</a>
              <a href="author.html#2914">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.colm.net/cgi-bin/mailman/listinfo/ragel-users">More information about the ragel-users
mailing list</a><br>
</body></html>
