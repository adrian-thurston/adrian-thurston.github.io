From matt.mo... at gmail.com  Mon Jan  1 18:14:41 2007
From: matt.mo... at gmail.com (Matt Mower)
Date: Mon, 1 Jan 2007 18:14:41 +0000
Subject: Problematic machine specification
Message-ID: <d56373190701011014m7ffdbf62y9bae19e72ddd7b62@mail.gmail.com>

Hi folks.

I'm writing an app that needs to parse the output from svn diff
although not to any great degree of detail. For various reasons (blame
Zed!) I decided to use this as an opportunity to learn Ragel.

With a lot of help from Zed I have something that seems close but
isn't quite working. The problem section revolves around the contents
of a diff hunk. This looks something like:

@@ -205,3 +205,15 @@
 .hugeTag {
  font-size: 125%;
 }
+
+.asp_timestamp_col {
...

the first three lines after the line beginning @@... have a space
prefix (meaning a line common to both files), the next line has a '+'
prefix (meaning a new line). A hunk ends when you reach a line that
doesn't begin with " ", "+", or "-".

The problem is that the machine recognizes the first three lines of my
example (prefixed " ") but comes back with an error when it reaches
the first line prefixed "+". Looking at the diagram (diffBody.png
attached) for the diffBody machine it looks to me as if it should
correctly parse the example.

If anyone can help point out where I am going wrong that would be much
appreciated. I'm not sure if & how I can get it to log the state or
character being processed when the error was raised. That too would be
useful.

My application is being written in Objective-C. So far as I can tell
that doesn't significantly muddy the waters and the O-C bits seem to
be working.

Many thanks,

Matt

-- 
Matt Mower :: http://matt.blogs.it/
-------------- next part --------------
A non-text attachment was scrubbed...
Name: DiffParser.m.rl
Type: application/octet-stream
Size: 2098 bytes
Desc: not available
URL: <http://www.colm.net/pipermail/ragel/attachments/20070101/d7a8b028/attachment.obj>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: diffBody.png
Type: image/png
Size: 101358 bytes
Desc: not available
URL: <http://www.colm.net/pipermail/ragel/attachments/20070101/d7a8b028/attachment.png>

From thurs... at cs.queensu.ca  Mon Jan  1 21:57:14 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Mon, 01 Jan 2007 16:57:14 -0500
Subject: [ragel-users] Problematic machine specification
In-Reply-To: <d56373190701011014m7ffdbf62y9bae19e72ddd7b62@mail.gmail.com>
References: <d56373190701011014m7ffdbf62y9bae19e72ddd7b62@mail.gmail.com>
Message-ID: <459983BA.6080600@cs.queensu.ca>

Hi Matt,

I noticed a couple spots to fix. Since the line machine is given with 
the + operator it requires at least one character. Use * instead and 
empty lines (following +/- etc) will be accepted.

The 'print' builtin machine does not accept tabs, so any diff with tabs 
will fail.

When the machine hits an error it transitions into the error state and 
then breaks out of the loop from there. Look at p[-1] after the loop to 
see on what character the error occurred. Alternatively you can embed an 
error action and look at p[0] from within the action.

If you want to see the state that the error occurred in you'll need to 
embed an error action and look at fcurs (this is macro rewritten by ragel).

Cheers (and happy new year)

Adrian

Matt Mower wrote:
> Hi folks.
> 
> I'm writing an app that needs to parse the output from svn diff
> although not to any great degree of detail. For various reasons (blame
> Zed!) I decided to use this as an opportunity to learn Ragel.
> 
> With a lot of help from Zed I have something that seems close but
> isn't quite working. The problem section revolves around the contents
> of a diff hunk. This looks something like:
> 
> @@ -205,3 +205,15 @@
> .hugeTag {
>  font-size: 125%;
> }
> +
> +.asp_timestamp_col {
> ...
> 
> the first three lines after the line beginning @@... have a space
> prefix (meaning a line common to both files), the next line has a '+'
> prefix (meaning a new line). A hunk ends when you reach a line that
> doesn't begin with " ", "+", or "-".
> 
> The problem is that the machine recognizes the first three lines of my
> example (prefixed " ") but comes back with an error when it reaches
> the first line prefixed "+". Looking at the diagram (diffBody.png
> attached) for the diffBody machine it looks to me as if it should
> correctly parse the example.
> 
> If anyone can help point out where I am going wrong that would be much
> appreciated. I'm not sure if & how I can get it to log the state or
> character being processed when the error was raised. That too would be
> useful.
> 
> My application is being written in Objective-C. So far as I can tell
> that doesn't significantly muddy the waters and the O-C bits seem to
> be working.
> 
> Many thanks,
> 
> Matt
> 
> 
> ------------------------------------------------------------------------
> 


From matt.mo... at gmail.com  Tue Jan  2 13:04:58 2007
From: matt.mo... at gmail.com (Matt Mower)
Date: Tue, 2 Jan 2007 13:04:58 +0000
Subject: [ragel-users] Re: Problematic machine specification
In-Reply-To: <459983BA.6080600@cs.queensu.ca>
References: <d56373190701011014m7ffdbf62y9bae19e72ddd7b62@mail.gmail.com>
	 <459983BA.6080600@cs.queensu.ca>
Message-ID: <d56373190701020504g415c0372ye0689c8a65fa0710@mail.gmail.com>

Hi Adrian,

Thanks for your reply.

On 01/01/07, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
> I noticed a couple spots to fix. Since the line machine is given with
> the + operator it requires at least one character. Use * instead and
> empty lines (following +/- etc) will be accepted.
>

Yes, done that, thanks.

> The 'print' builtin machine does not accept tabs, so any diff with tabs
> will fail.
>

That was my major sin. I had just blindly internalized the assumption
that it would and this was throwing off the scanner. It became obvious
once I figured out to print *p when I detected the error state.

> When the machine hits an error it transitions into the error state and
> then breaks out of the loop from there. Look at p[-1] after the loop to
> see on what character the error occurred. Alternatively you can embed an
> error action and look at p[0] from within the action.
>
> If you want to see the state that the error occurred in you'll need to
> embed an error action and look at fcurs (this is macro rewritten by ragel).
>

That's very useful. Zed pointed me to the docs on error actions but I
wasn't able to take it in because I was grappling with everything else
as well. I'm figuring the actions out better now (making use of enter
as well as exit actions) so I'll go back over the guide now that I
have the basic scanner working.

Thanks again & Happy New Year to you too!

Regards,

Matt


From s... at mattmower.com  Wed Jan  3 01:16:32 2007
From: s... at mattmower.com (Matt Mower)
Date: Wed, 3 Jan 2007 01:16:32 +0000
Subject: Machine not running terminating actions
Message-ID: <d56373190701021716v3df6d8cdu6de1198597d95b8c@mail.gmail.com>

Hi again.

With your help I've been able to iron out many of the wrinkles in my
diff parser and have something approximating a good parse of arbitrary
svn diff output. One thing has me stumped though. The actions for the
last hunk of the last diff are not being fired.

Here is my machine:

### expressions

	lineChar = ( print | space ) - '\n';
	
	nbsp = space - '\n';
	
	line = ( ' ' | '-' | '+' ) @{ fhold; } lineChar* '\n'+ ;
	
	ignore_line = lineChar* '\n';

	ignoreCode = '\\' line;
	separator = '='+ '\n';
	hunkEndChar = print - ( space | '+' | '-' );
	
	oldFile = '---' ignore_line;
	newFile = '+++' ignore_line;
	
	hunkHeader = '@@' print+ '@@' '\n'+;
	
	hunkBody = ( line )+ ( ignoreCode | hunkEndChar @{ fhold; } );
	
	hunk = hunkHeader >enter_hunk hunkBody %exit_hunk;
	
	fileName = ( lineChar+ ) >mark %copy_to_filespec;
	
	fileSpec = "Index:" nbsp+ fileName '\n'+;
	
	diffHeader = ( fileSpec separator oldFile newFile );
	diffBody = hunk* %exit_diff;
	
	diff = diffHeader >enter_diff diffBody;
	
#	main := diff* $!error $~track;
#	main := diff* $!error;
	main := diff*;

It's the result of much tinkering to get the actions to fire in the
right sequence (I have a lot of problems with exit_diff actions firing
before corresponding exit_hunk's and so forth).

It correctly parses into each diff and each hunk within in. Where it
falls down, as I say, is that exit_hunk and exit_diff are not fired
for the last parsed hunk of the last diff.

I've attached a graph showing the diffBody machine as well as the full
.dot and the parser itself.

Any help would be much appreciated.

Thanks,

Matt

-- 
Matt Mower :: http://matt.blogs.it/
-------------- next part --------------
A non-text attachment was scrubbed...
Name: machine_26863.png
Type: image/png
Size: 116343 bytes
Desc: not available
URL: <http://www.colm.net/pipermail/ragel/attachments/20070103/199b98d9/attachment.png>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: DiffParser.m.dot
Type: application/octet-stream
Size: 2531 bytes
Desc: not available
URL: <http://www.colm.net/pipermail/ragel/attachments/20070103/199b98d9/attachment.obj>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: DiffParser.m.rl
Type: application/octet-stream
Size: 2884 bytes
Desc: not available
URL: <http://www.colm.net/pipermail/ragel/attachments/20070103/199b98d9/attachment-0001.obj>

From thurs... at cs.queensu.ca  Wed Jan  3 03:21:59 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Tue, 02 Jan 2007 22:21:59 -0500
Subject: [ragel-users] Machine not running terminating actions
In-Reply-To: <d56373190701021716v3df6d8cdu6de1198597d95b8c@mail.gmail.com>
References: <d56373190701021716v3df6d8cdu6de1198597d95b8c@mail.gmail.com>
Message-ID: <459B2157.4020900@cs.queensu.ca>

Hi Matt,

You're parser is coming along nicely :) Here are some more tips.

When it comes to ordering actions on the same character, just remember 
that there is an outer-inner ordering. It goes outer start actions, 
inner start actions, inner rest actions, outer rest actions. "rest" 
meaning finishing, leaving, and all actions. It seems that what you have 
now is right.

Leaving actions (%) only fire on character transitions. What is 
happening is that at the end of the input the machine is just exiting. 
There is no character to cause the action to get executed. If you embed 
an eof action (using %eof exit_diff) at the same places that you've 
specified the leaving actions (%exit_diff) and you write the eof switch 
(with %%write eof;) then they will fire.

Alternatively you can specify a termination character (perhaps 0) at the 
end of main and send it once the input is done. That will 'flush' the 
leaving actions.

You can try it out with something simple like the following. I find the 
smaller machines are easier to reason about and what you learn 
generalizes well.

%%{
	machine tmp;
	action e1 {}
	action e2 {}

	sub = ( 's' [^\n]* '\n' ) %e1 %eof e1;
	fun = ( 'f' sub* ) %e2 %eof e2;

	main := fun*;
}%%

I'm not sure what you intend with the following, maybe some explicitly 
specified lookahead? I would remove it though because I don't think it's 
necessary and it doesn't seem to be compatible with my advice above.

( ignoreCode | hunkEndChar @{ fhold; } );

In general, it's advisable to avoid fhold unless you're about to jump 
somewhere using fgoto or you're really sure of what you're doing. The 
problem is that if you union a machine that has an fhold in it with 
something else, the fhold will also apply to the something else when you 
probably don't want it to. It can make things really complicated.

Cheers,
  Adrian

Matt Mower wrote:
> Hi again.
> 
> With your help I've been able to iron out many of the wrinkles in my
> diff parser and have something approximating a good parse of arbitrary
> svn diff output. One thing has me stumped though. The actions for the
> last hunk of the last diff are not being fired.
> 
> Here is my machine:
> 
> ### expressions
> 
>     lineChar = ( print | space ) - '\n';
>     
>     nbsp = space - '\n';
>     
>     line = ( ' ' | '-' | '+' ) @{ fhold; } lineChar* '\n'+ ;
>     
>     ignore_line = lineChar* '\n';
> 
>     ignoreCode = '\\' line;
>     separator = '='+ '\n';
>     hunkEndChar = print - ( space | '+' | '-' );
>     
>     oldFile = '---' ignore_line;
>     newFile = '+++' ignore_line;
>     
>     hunkHeader = '@@' print+ '@@' '\n'+;
>     
>     hunkBody = ( line )+ ( ignoreCode | hunkEndChar @{ fhold; } );
>     
>     hunk = hunkHeader >enter_hunk hunkBody %exit_hunk;
>     
>     fileName = ( lineChar+ ) >mark %copy_to_filespec;
>     
>     fileSpec = "Index:" nbsp+ fileName '\n'+;
>     
>     diffHeader = ( fileSpec separator oldFile newFile );
>     diffBody = hunk* %exit_diff;
>     
>     diff = diffHeader >enter_diff diffBody;
>     
> #    main := diff* $!error $~track;
> #    main := diff* $!error;
>     main := diff*;
> 
> It's the result of much tinkering to get the actions to fire in the
> right sequence (I have a lot of problems with exit_diff actions firing
> before corresponding exit_hunk's and so forth).
> 
> It correctly parses into each diff and each hunk within in. Where it
> falls down, as I say, is that exit_hunk and exit_diff are not fired
> for the last parsed hunk of the last diff.
> 
> I've attached a graph showing the diffBody machine as well as the full
> .dot and the parser itself.
> 
> Any help would be much appreciated.
> 
> Thanks,
> 
> Matt
> 
> 
> ------------------------------------------------------------------------
> 


From s... at mattmower.com  Wed Jan  3 08:31:19 2007
From: s... at mattmower.com (Matt Mower)
Date: Wed, 3 Jan 2007 08:31:19 +0000
Subject: [ragel-users] Re: Machine not running terminating actions
In-Reply-To: <459B2157.4020900@cs.queensu.ca>
References: <d56373190701021716v3df6d8cdu6de1198597d95b8c@mail.gmail.com>
	 <459B2157.4020900@cs.queensu.ca>
Message-ID: <d56373190701030031u54ce1b44mb213fbd002292bb0@mail.gmail.com>

Hi Adrian,

On 03/01/07, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
> When it comes to ordering actions on the same character, just remember
> that there is an outer-inner ordering. It goes outer start actions,
> inner start actions, inner rest actions, outer rest actions. "rest"
> meaning finishing, leaving, and all actions. It seems that what you have
> now is right.
>

Cool. I think I'd figured that out intuitively but not on a conscious level.

> Leaving actions (%) only fire on character transitions. What is
> happening is that at the end of the input the machine is just exiting.

Ah.

> There is no character to cause the action to get executed. If you embed
> an eof action (using %eof exit_diff) at the same places that you've
> specified the leaving actions (%exit_diff) and you write the eof switch
> (with %%write eof;) then they will fire.
>

Zed prompted me to look at write eof, but I misread the guide and
didn't realise you had to embed specific EOF actions. I guess using
Ruby so much has lead me to expect magic everywhere ;-)

> You can try it out with something simple like the following. I find the
> smaller machines are easier to reason about and what you learn
> generalizes well.

Good point.

>         sub = ( 's' [^\n]* '\n' ) %e1 %eof e1;

%eof, isn't that another action the same as %e1?  When I looked
through the 5.16 guide about EOF actions it suggested I should use %/
(maybe %eof is alternative syntax? I couldn't find it when I
searched).

Anyway I tried:

hunk = hunkHeader >enter_hunk hunkBody %exit_hunk %/exit_hunk;
	
	fileName = ( lineChar+ ) >mark %copy_to_filespec;
	
	fileSpec = "Index:" nbsp+ fileName '\n'+;
	
	diffHeader = ( fileSpec separator oldFile newFile );
	diffBody = hunk* %exit_diff %/exit_diff;

and it worked first time out (since I already had the %% write eof, it
just wasn't doing anything!)

> ( ignoreCode | hunkEndChar @{ fhold; } );
>

I removed the lookahead as you suggested. I'll consume the \\ prefixed
comment inside 'line' from now on.

> In general, it's advisable to avoid fhold unless you're about to jump
> somewhere using fgoto or you're really sure of what you're doing. The

Yeah I think we can safely say I don't *quite* know what I'm doing
yet. But I do feel like I'm getting, slowly, to grips with it. I think
that part of my problem is that I'm not a visual thinker, I can't
imagine the resulting graph as I'm constructing the machine. I
probably need to be a bit less sloppy in my reasoning to compensate
;-)

So, this morning, I have:

[Session started at 2007-01-03 08:24:20 +0000.]
2007-01-03 08:24:20.716 Ragel2[1666] begin_diff
2007-01-03 08:24:20.716 Ragel2[1666]     filespec:
app/helpers/application_helper.rb
2007-01-03 08:24:20.716 Ragel2[1666]   begin_hunk
2007-01-03 08:24:20.716 Ragel2[1666]   end_hunk
2007-01-03 08:24:20.716 Ragel2[1666] end_diff
2007-01-03 08:24:20.716 Ragel2[1666] begin_diff
2007-01-03 08:24:20.716 Ragel2[1666]     filespec:
app/views/layouts/application.rhtml
2007-01-03 08:24:20.716 Ragel2[1666]   begin_hunk
2007-01-03 08:24:20.716 Ragel2[1666]   end_hunk
2007-01-03 08:24:20.716 Ragel2[1666] end_diff
2007-01-03 08:24:20.716 Ragel2[1666] begin_diff
2007-01-03 08:24:20.716 Ragel2[1666]     filespec: db/schema.rb
2007-01-03 08:24:20.716 Ragel2[1666]   begin_hunk
2007-01-03 08:24:20.716 Ragel2[1666]   end_hunk
2007-01-03 08:24:20.716 Ragel2[1666]   begin_hunk
2007-01-03 08:24:20.716 Ragel2[1666]   end_hunk
2007-01-03 08:24:20.717 Ragel2[1666]   begin_hunk
2007-01-03 08:24:20.717 Ragel2[1666]   end_hunk
2007-01-03 08:24:20.717 Ragel2[1666]   begin_hunk
2007-01-03 08:24:20.717 Ragel2[1666]   end_hunk
2007-01-03 08:24:20.717 Ragel2[1666] end_diff
2007-01-03 08:24:20.717 Ragel2[1666] Parser exit no errors

Thank you Adrian & Zed!

Regards,

Matt

-- 
Matt Mower :: http://matt.blogs.it/


From thurs... at cs.queensu.ca  Wed Jan  3 15:18:14 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Wed, 03 Jan 2007 10:18:14 -0500
Subject: [ragel-users] Re: Machine not running terminating actions
In-Reply-To: <d56373190701030031u54ce1b44mb213fbd002292bb0@mail.gmail.com>
References: <d56373190701021716v3df6d8cdu6de1198597d95b8c@mail.gmail.com> <459B2157.4020900@cs.queensu.ca> <d56373190701030031u54ce1b44mb213fbd002292bb0@mail.gmail.com>
Message-ID: <459BC936.1050103@cs.queensu.ca>

Matt Mower wrote:
> Zed prompted me to look at write eof, but I misread the guide and
> didn't realise you had to embed specific EOF actions. I guess using
> Ruby so much has lead me to expect magic everywhere ;-)

Ragel actually used to behave this way. The % operator would also embed 
EOF actions. But I found this to be problematic in a few scenarios 
because the EOF context is not the same as the regular action context 
(the p pointer is not alway available). So I ended up splitting them.

> %eof, isn't that another action the same as %e1?  When I looked
> through the 5.16 guide about EOF actions it suggested I should use %/
> (maybe %eof is alternative syntax? I couldn't find it when I
> searched).

The %eof syntax is an alternate syntax for the %/ operator. It's new. 
I'll add that to the guide ASAP.

Cheers,
  Adrian


From jason2... at jasonjobe.com  Wed Jan  3 20:01:07 2007
From: jason2... at jasonjobe.com (Jason)
Date: Wed, 03 Jan 2007 12:01:07 -0800
Subject: integrating ragel w/ bison
Message-ID: <1167854467.572809.228150@11g2000cwr.googlegroups.com>

I have a good bit of experience writing grammars using re2c and bison
but I really like the clarity of ragel and would like to use it as a
replacement for re2c.

Are there any examples (e.g. the quintessential calculator) using ragel
as the lexical frontend to bison?

thanks,
Jason


From thurs... at cs.queensu.ca  Wed Jan  3 20:36:28 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Wed, 03 Jan 2007 15:36:28 -0500
Subject: [ragel-users] integrating ragel w/ bison
In-Reply-To: <1167854467.572809.228150@11g2000cwr.googlegroups.com>
References: <1167854467.572809.228150@11g2000cwr.googlegroups.com>
Message-ID: <459C13CC.2040201@cs.queensu.ca>

Hi Jason, all the scanner examples I have use the push model. To write a
pull-based scanner you'll need to use the fbreak; statement to break out of
the processing loop. You can then return from the scanner function. You
can't use a C return statement in a scanner action because it will leave the
scanner in an inconsistent state. The fbreak statement does a little cleanup
first.

How does it work in re2c? Do you just give a C return from the pattern action?

For a long time I've been meaning to add a version of fbreak that cleans up
then issues a C return but I don't know what to call it because there
already is fret which returns from an fcall. I might just make it

fbreak_return value;

even though that's very long. But it could also be extended to include

fbreak_goto label;

to jump to somewhere else in your function. Do you think that's clear? I
wouldn't want these to be confused with fret and fgoto.

Regards,
 Adrian

Jason wrote:
> 
> I have a good bit of experience writing grammars using re2c and bison
> but I really like the clarity of ragel and would like to use it as a
> replacement for re2c.
> 
> Are there any examples (e.g. the quintessential calculator) using ragel
> as the lexical frontend to bison?
> 
> thanks,
> Jason
> 
> 
> 


From jason2... at jasonjobe.com  Wed Jan  3 21:27:17 2007
From: jason2... at jasonjobe.com (Jason)
Date: Wed, 03 Jan 2007 13:27:17 -0800
Subject: integrating ragel w/ bison
In-Reply-To: <459C13CC.2040201@cs.queensu.ca>
References: <1167854467.572809.228150@11g2000cwr.googlegroups.com>
   <459C13CC.2040201@cs.queensu.ca>
Message-ID: <1167859637.857914.142110@q40g2000cwq.googlegroups.com>

Adrian,

How about
  freturn value;
or
  fcreturn value; // for a 'C' return

>> How does it work in re2c? Do you just give a C return from the pattern action?
Yes. You create a struct that you pass to your re2c_lex call. Each call
returns the next token.

Would you just make repeated calls to the scanner? i.e. would the state
be such that it just picks up where you left off?

This sort of interface would certainly make yacc/bison much easier!

If you would like me test it out please let me know :-)

regards,
Jason


From thurs... at cs.queensu.ca  Thu Jan  4 00:47:11 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Wed, 03 Jan 2007 19:47:11 -0500
Subject: [ragel-users] Re: integrating ragel w/ bison
In-Reply-To: <1167859637.857914.142110@q40g2000cwq.googlegroups.com>
References: <1167854467.572809.228150@11g2000cwr.googlegroups.com> <459C13CC.2040201@cs.queensu.ca> <1167859637.857914.142110@q40g2000cwq.googlegroups.com>
Message-ID: <459C4E8F.4000600@cs.queensu.ca>


Jason wrote:
> Would you just make repeated calls to the scanner? i.e. would the state
> be such that it just picks up where you left off?

That's what I was thinking. I haven't tried this out, but you should be able
to do something like the following. Note that you need to manually get local
copies of p and pe because the access statement does not affect them.

void scan( Scanner *s )
{
	char *p = s->p;
	char *pe = s->pe;

	while ( true ) {
		if ( p == pe ) {
			check_for_preserve_condition();
			if ( ! fetch_more_data() )
				return EOF;
		}

		token = no_token;

		%%{
			machine Scanner;
			access s->;

			main := |*

			# Identifiers
			( [a-zA-Z_] [a-zA-Z0-9_]* ) =>
				{ token = Identifier; fbreak; };

			# Whitespace
			[ \t\n];

			# Anything else
			any => { token = *p; fbreak; };

			*|;

			write exec;
		}%%

		if ( token != no_token ) {
			s->p = p;
			s->pe = pe;
			return token;
		}

		if ( s->cs == Scanner_error )
			return ERR;
	}
}


From jason2... at jasonjobe.com  Thu Jan  4 18:21:54 2007
From: jason2... at jasonjobe.com (Jason)
Date: Thu, 04 Jan 2007 10:21:54 -0800
Subject: integrating ragel w/ bison
In-Reply-To: <459C4E8F.4000600@cs.queensu.ca>
References: <1167854467.572809.228150@11g2000cwr.googlegroups.com>
   <459C13CC.2040201@cs.queensu.ca>
   <1167859637.857914.142110@q40g2000cwq.googlegroups.com>
   <459C4E8F.4000600@cs.queensu.ca>
Message-ID: <1167934914.170228.44670@6g2000cwy.googlegroups.com>

Adrian,

I'm still not following your full intent but I did manage to get some
code (below) that builds and runs but produces no output.

Hopefully, you can help me fill in the blanks.

thanks,
Jason

----------------------------------- CUT HERE
-------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct _Scanner {
	int cs;
	int act;
	int have;
	int curline;
	char *tokstart;
	char *tokend;
	char *p;
	char *pe;
	int done;

	int value;
} Scanner;

#define ERR (-1000)

void scan_init( Scanner *s )
{
  memset (s, '\0', sizeof(Scanner));
  s->curline = 1;
}

int fetch_more_data ( Scanner *s ) {
	return 0;
}

void check_for_preserve_condition( Scanner *s ) {
}

int Scanner_error = -1;

#define Identifier 1
#define Number 2


int scan( Scanner *s )
{
        char *p = s->p;
        char *pe = s->pe;
	int token, no_token = '\0';

        while ( 1 ) {
                if ( p == pe ) {
                        check_for_preserve_condition(s);
                        if ( ! fetch_more_data(s) )
                                return EOF;
                }

                token = no_token;

                %%{
                        machine Scanner;
                        access s->;

                        main := |*

                        # Identifiers
                        ( [a-zA-Z_] [a-zA-Z0-9_]* ) =>
                                { token = Identifier; fbreak; };

                        # Whitespace
                        [ \t\n];

			# Number
                        digit+ => { token = Number; s->value = atoi(p);
fbreak; };

                        # Anything else
                        any => { token = *p; fbreak; };

                        *|;

                        write exec;
                }%%

                if ( token != no_token ) {
                        s->p = p;
                        s->pe = pe;
                        return token;
                }

                if ( s->cs == Scanner_error )
                        return ERR;
        }
}


int main (int argc, char** argv)
{
    Scanner ss;
    int tok;

    ss.pe = "2 * 3";
    scan_init (&ss);

    while (1) {
	tok = scan (&ss);
	if (tok == EOF || tok == ERR)
	  break;
	printf ("%d\n", tok);
    }

    return 0;
}


From thurs... at cs.queensu.ca  Fri Jan  5 03:41:16 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Thu, 04 Jan 2007 22:41:16 -0500
Subject: [ragel-users] Re: integrating ragel w/ bison
In-Reply-To: <1167934914.170228.44670@6g2000cwy.googlegroups.com>
References: <1167854467.572809.228150@11g2000cwr.googlegroups.com> <459C13CC.2040201@cs.queensu.ca> <1167859637.857914.142110@q40g2000cwq.googlegroups.com> <459C4E8F.4000600@cs.queensu.ca> <1167934914.170228.44670@6g2000cwy.googlegroups.com>
Message-ID: <459DC8DC.7090205@cs.queensu.ca>

Hi Jason,

I finished off the rest of the pull driver and added it to the examples 
directory. Be sure to let me know if you find any bugs. I did it fast.

Cheers,
  Adrian

Jason wrote:
> 
> Adrian,
> 
> I'm still not following your full intent but I did manage to get some
> code (below) that builds and runs but produces no output.
> 
> Hopefully, you can help me fill in the blanks.
> 
> thanks,
> Jason
> 
> ----------------------------------- CUT HERE
> -------------------------------------------------
> #include <stdio.h>
> #include <stdlib.h>
> #include <string.h>
> 
> typedef struct _Scanner {
>     int cs;
>     int act;
>     int have;
>     int curline;
>     char *tokstart;
>     char *tokend;
>     char *p;
>     char *pe;
>     int done;
> 
>     int value;
> } Scanner;
> 
> #define ERR (-1000)
> 
> void scan_init( Scanner *s )
> {
>  memset (s, '\0', sizeof(Scanner));
>  s->curline = 1;
> }
> 
> int fetch_more_data ( Scanner *s ) {
>     return 0;
> }
> 
> void check_for_preserve_condition( Scanner *s ) {
> }
> 
> int Scanner_error = -1;
> 
> #define Identifier 1
> #define Number 2
> 
> 
> int scan( Scanner *s )
> {
>        char *p = s->p;
>        char *pe = s->pe;
>     int token, no_token = '\0';
> 
>        while ( 1 ) {
>                if ( p == pe ) {
>                        check_for_preserve_condition(s);
>                        if ( ! fetch_more_data(s) )
>                                return EOF;
>                }
> 
>                token = no_token;
> 
>                %%{
>                        machine Scanner;
>                        access s->;
> 
>                        main := |*
> 
>                        # Identifiers
>                        ( [a-zA-Z_] [a-zA-Z0-9_]* ) =>
>                                { token = Identifier; fbreak; };
> 
>                        # Whitespace
>                        [ \t\n];
> 
>             # Number
>                        digit+ => { token = Number; s->value = atoi(p);
> fbreak; };
> 
>                        # Anything else
>                        any => { token = *p; fbreak; };
> 
>                        *|;
> 
>                        write exec;
>                }%%
> 
>                if ( token != no_token ) {
>                        s->p = p;
>                        s->pe = pe;
>                        return token;
>                }
> 
>                if ( s->cs == Scanner_error )
>                        return ERR;
>        }
> }
> 
> 
> int main (int argc, char** argv)
> {
>    Scanner ss;
>    int tok;
> 
>    ss.pe = "2 * 3";
>    scan_init (&ss);
> 
>    while (1) {
>     tok = scan (&ss);
>     if (tok == EOF || tok == ERR)
>       break;
>     printf ("%d\n", tok);
>    }
> 
>    return 0;
> }
> 
> 
> 
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: pullscan.rl
URL: <http://www.colm.net/pipermail/ragel/attachments/20070104/64beea16/attachment.ksh>

From s... at mattmower.com  Mon Jan  8 21:01:34 2007
From: s... at mattmower.com (Matt Mower)
Date: Mon, 8 Jan 2007 21:01:34 +0000
Subject: Any chance of rlcodegen outputting pure-ruby
Message-ID: <d56373190701081301k304d4376w5f70940a489b4219@mail.gmail.com>

Hi,

I realise that wrapping the C code generated by Ragel into a Ruby
extension is a reasonably simple exercise but I really think it would
help with adoption if Ragel could directly generate Ruby source code.

Is there any likelyhood of that happening? Or does it need someone
from the Ruby side to pitch in? And how hard might that be?

Regards,

Matt

-- 
Matt Mower :: http://matt.blogs.it/


From thurs... at cs.queensu.ca  Tue Jan  9 04:06:20 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Mon, 08 Jan 2007 23:06:20 -0500
Subject: [ragel-users] Any chance of rlcodegen outputting pure-ruby
In-Reply-To: <d56373190701081301k304d4376w5f70940a489b4219@mail.gmail.com>
References: <d56373190701081301k304d4376w5f70940a489b4219@mail.gmail.com>
Message-ID: <45A314BC.7090500@cs.queensu.ca>

Hi Matt, it wouldn't be too much work to add a Ruby backend. I can't 
commit much time to it right now (school is very busy). But I'd be happy 
to help out anyone that wants to try it.

I don't know Ruby all that well so there may be issues which crop up. 
Some things to consider:

Table-based parses will be the easiest to port. Start with the generated 
C code (or maybe Java) for some working parser, then port it to Ruby and 
get it working. You should be able to then just rip out the driver code 
and stick it into rlcodegen.

The fastest code generated by Ragel is directly executable. This relies 
on having a goto. A lack of goto is also a problem for Ragel+Java. Colin 
Fleming discussed generating Java byte code directly to get around this 
issue. The same might be an option for Ruby.

Some changes will need to be made to the frontend. Ruby comments and 
literals will need to be supported and the ruby integral types 
represented. I'm currently in the middle of rewriting the Ragel frontend 
parser. When that's done it will be a better time to add a scanner for 
Ruby which can properly separate Ragel code from Ruby code.

Cheers,
  Adrian

Matt Mower wrote:
> 
> Hi,
> 
> I realise that wrapping the C code generated by Ragel into a Ruby
> extension is a reasonably simple exercise but I really think it would
> help with adoption if Ragel could directly generate Ruby source code.
> 
> Is there any likelyhood of that happening? Or does it need someone
> from the Ruby side to pitch in? And how hard might that be?
> 
> Regards,
> 
> Matt
> 


From vhbo... at gmail.com  Wed Jan 10 10:19:25 2007
From: vhbo... at gmail.com (Victor Hugo Borja)
Date: Wed, 10 Jan 2007 10:19:25 -0000
Subject: Any chance of rlcodegen outputting pure-ruby
In-Reply-To: <45A314BC.7090500@cs.queensu.ca>
References: <d56373190701081301k304d4376w5f70940a489b4219@mail.gmail.com>
   <45A314BC.7090500@cs.queensu.ca>
Message-ID: <1168424365.999868.266240@p59g2000hsd.googlegroups.com>

Matt,

I'm also interested on getting Ragel to output ruby, today I've been
working on this.
Following Adrian's advice, I decided to start by porting a simple
generated parser from c to ruby.
Once the ruby parser was working as expected (used continuations
instead of c' gotos), I started to work on the backend for ragel,
code generation is working now (with awful code indentation atm). the
generated parsers are still somewhat buggy, so I'd appreciate if anyone
could help with tests  for this.

my work up to now is on http://vic.selfip.com/pub/ragel-5.16-rb.tar.gz,
check the rbtmp directory if you want to see the ported parser.

I expect to have some time this weekend to fix the generated parsers,
and commit a working patch to Adrian.

Cheers,
--
Victor Hugo Borja.
v... at rubyforge.org

On Jan 8, 10:06 pm, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
> Hi Matt, it wouldn't be too much work to add a Ruby backend. I can't
> commit much time to it right now (school is very busy). But I'd be happy
> to help out anyone that wants to try it.
>
> I don't know Ruby all that well so there may be issues which crop up.
> Some things to consider:
>
> Table-based parses will be the easiest to port. Start with the generated
> C code (or maybe Java) for some working parser, then port it to Ruby and
> get it working. You should be able to then just rip out the driver code
> and stick it into rlcodegen.
>
> The fastest code generated by Ragel is directly executable. This relies
> on having a goto. A lack of goto is also a problem for Ragel+Java. Colin
> Fleming discussed generating Java byte code directly to get around this
> issue. The same might be an option for Ruby.
>
> Some changes will need to be made to the frontend. Ruby comments and
> literals will need to be supported and the ruby integral types
> represented. I'm currently in the middle of rewriting the Ragel frontend
> parser. When that's done it will be a better time to add a scanner for
> Ruby which can properly separate Ragel code from Ruby code.
>
> Cheers,
>   Adrian
>
> Matt Mower wrote:
>
> > Hi,
>
> > I realise that wrapping the C code generated by Ragel into a Ruby
> > extension is a reasonably simple exercise but I really think it would
> > help with adoption if Ragel could directly generate Ruby source code.
>
> > Is there any likelyhood of that happening? Or does it need someone
> > from the Ruby side to pitch in? And how hard might that be?
> 
> > Regards,
> 
> > Matt


From thurs... at cs.queensu.ca  Wed Jan 10 23:26:49 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Wed, 10 Jan 2007 18:26:49 -0500
Subject: [ragel-users] Re: Any chance of rlcodegen outputting pure-ruby
In-Reply-To: <1168424365.999868.266240@p59g2000hsd.googlegroups.com>
References: <d56373190701081301k304d4376w5f70940a489b4219@mail.gmail.com> <45A314BC.7090500@cs.queensu.ca> <1168424365.999868.266240@p59g2000hsd.googlegroups.com>
Message-ID: <45A57639.8040606@cs.queensu.ca>

Cool! I'll have a look at this ASAP. 5.17 is going to be just a parser
rewrite release but after that I'll add this work in.

Cheers,
 Adrian

Victor Hugo Borja wrote:
> Matt,
> 
> I'm also interested on getting Ragel to output ruby, today I've been
> working on this.
> Following Adrian's advice, I decided to start by porting a simple
> generated parser from c to ruby.
> Once the ruby parser was working as expected (used continuations
> instead of c' gotos), I started to work on the backend for ragel,
> code generation is working now (with awful code indentation atm). the
> generated parsers are still somewhat buggy, so I'd appreciate if anyone
> could help with tests  for this.
> 
> my work up to now is on http://vic.selfip.com/pub/ragel-5.16-rb.tar.gz,
> check the rbtmp directory if you want to see the ported parser.
> 
> I expect to have some time this weekend to fix the generated parsers,
> and commit a working patch to Adrian.
> 
> Cheers,
> --
> Victor Hugo Borja.
> v... at rubyforge.org
> 
> On Jan 8, 10:06 pm, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
>> Hi Matt, it wouldn't be too much work to add a Ruby backend. I can't
>> commit much time to it right now (school is very busy). But I'd be happy
>> to help out anyone that wants to try it.
>>
>> I don't know Ruby all that well so there may be issues which crop up.
>> Some things to consider:
>>
>> Table-based parses will be the easiest to port. Start with the generated
>> C code (or maybe Java) for some working parser, then port it to Ruby and
>> get it working. You should be able to then just rip out the driver code
>> and stick it into rlcodegen.
>>
>> The fastest code generated by Ragel is directly executable. This relies
>> on having a goto. A lack of goto is also a problem for Ragel+Java. Colin
>> Fleming discussed generating Java byte code directly to get around this
>> issue. The same might be an option for Ruby.
>>
>> Some changes will need to be made to the frontend. Ruby comments and
>> literals will need to be supported and the ruby integral types
>> represented. I'm currently in the middle of rewriting the Ragel frontend
>> parser. When that's done it will be a better time to add a scanner for
>> Ruby which can properly separate Ragel code from Ruby code.
>>
>> Cheers,
>>   Adrian
>>
>> Matt Mower wrote:
>>
>>> Hi,
>>> I realise that wrapping the C code generated by Ragel into a Ruby
>>> extension is a reasonably simple exercise but I really think it would
>>> help with adoption if Ragel could directly generate Ruby source code.
>>> Is there any likelyhood of that happening? Or does it need someone
>>> from the Ruby side to pitch in? And how hard might that be?
>>> Regards,
>>> Matt
> 
> 
> 


From vhbo... at gmail.com  Thu Jan 11 06:59:11 2007
From: vhbo... at gmail.com (Victor Hugo Borja)
Date: Thu, 11 Jan 2007 06:59:11 -0000
Subject: Any chance of rlcodegen outputting pure-ruby
In-Reply-To: <45A57639.8040606@cs.queensu.ca>
References: <d56373190701081301k304d4376w5f70940a489b4219@mail.gmail.com>
   <45A314BC.7090500@cs.queensu.ca>
   <1168424365.999868.266240@p59g2000hsd.googlegroups.com>
   <45A57639.8040606@cs.queensu.ca>
Message-ID: <1168498751.118580.312840@k58g2000hse.googlegroups.com>

Just updated the tar on http://vic.selfip.com/pub/ragel-5.16-rb.tar.gz
, fixed some bugs, used the atoi.rl example to prove code generation,
checkout rbtmp/atoi.rb.xml and rbtmp/atoi.rb , next step will be adding
test cases and test/langtrans_ruby.txl

On Jan 10, 5:26 pm, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
> 5.17 is going to be just a parser rewrite release but after that I'll add this work in.

Fine, I'd like to work on the ruby frontend support when 5.17 is ready.

Cheers,
  vic


From s... at mattmower.com  Mon Jan 15 17:00:29 2007
From: s... at mattmower.com (Matt Mower)
Date: Mon, 15 Jan 2007 17:00:29 +0000
Subject: Ragel chat
Message-ID: <d56373190701150900w690d52a1qddb5559ad84d5433@mail.gmail.com>

BTW on the off-chance anyone wants to talk about Ragel stuff I am
hanging around in #ragel on FreeNode IRC.

M

-- 
Matt Mower :: http://matt.blogs.it/


From s... at mattmower.com  Mon Jan 15 16:57:50 2007
From: s... at mattmower.com (Matt Mower)
Date: Mon, 15 Jan 2007 16:57:50 +0000
Subject: Fixing an edge case
Message-ID: <d56373190701150857m55c30464h584961023b62a012@mail.gmail.com>

Hi there.

I have come across a case that my "svn diff" parser doesn't handle and
I'm hoping you can help me in solving it.

The situation is this: It is possible (however unlikely) to "svn add"
an empty file to a repository (e.g. touch <file>; svn add <file>). If
you do this the output from "svn diff" contains an imcomplete header
for the diff and no hunk information. Thus instead of something like:

Index: newfile
=====================
--- new file (revision 0)
+++ new file (revision 0)
@@ .... @@
content here

you get:

Index: newfile
=====================

and this can occur in one of two places: either with another diff
following, or as the last diff so that potentially you can get the
output of "svn diff" terminate with:

=====================

which previously would have been considered to be an incomplete diff.
Now it has to be treated as an empty file diff.

Here is my parser machine:

	nbsp = space - '\n' %count_line;
	lineChar = extend - '\n';
	
	diffLine = ( '\\' lineChar* '\n' %count_line ) | ( ' ' | '-' | '+' )
>mark lineChar* '\n' @add_line %count_line;
	
	separator = '='+ '\n' %count_line;
	
	oldFile = '---' lineChar+ '\n' %count_line;
	newFile = '+++' lineChar+ '\n' %count_line;
	
	range = ( '-' | '+' ) ( digit+ >mark %push ) ( ' ' %push_zero @{
fhold; }  | ',' ( digit+ >mark %push ) );
	
	hunkHeader = '@@' nbsp* range nbsp+ range nbsp* '@@' '\n'
@pop_hunk_spec %count_line;
	
	hunkBody = diffLine+;
	
	hunk = hunkHeader >enter_hunk hunkBody %exit_hunk %/exit_hunk;
	
	fileName = ( lineChar+ ) >mark %copy_to_filespec;
	
	fileSpec = "Index:" nbsp+ fileName '\n'+ @count_line;
	
	diffHeader = fileSpec separator;
	
	diffBody = hunk* %exit_diff %/exit_diff;
	
	binaryDiff = 'C' lineChar+ '\n' %count_line lineChar+ '\n'
%binary_diff %count_line;
	
	textDiff = oldFile newFile diffBody;
	
	diff = diffHeader >enter_diff ( binaryDiff | textDiff );
	
	main := diff* $!error;

This machine uses the fact that a diff is ended either by another diff
starting (a line not beginning ' ' | '-' | '+') or EOF using a %/
action.

My problem in coming up with a solution has been to come up with
something that works both when a diff follows an 'empty' diff, when an
'empty' diff comes at the end and not, in the process, ending up
generating spurious empty diffs all over the place!

For example I can find the former case with something like:

	emptyDiff = ( any - ['-'|'C'] @{ fhold; } %empty_diff;
	
	diff = diffHeader >enter_diff ( binaryDiff | textDiff | emptyDiff );

the problem comes when I try to detect the empty case, my first
thought being something like:

    emptyDiff = ( ( any - ['-'|'C'] @{ fhold; } ) | zlen ) %empty_diff;

but this kind of formulation (written from memory) ends up with
machines which detect zlen for every diff (as you'd expect once you
graph it).

I've tinkered but my lack of ability to reason out the answer suggests
I am not as comfortable with this as I thought. My next step will be
to draw out what I think the machine should look like and work
backwards to the spec but if anyone can guide my thinking or give me
some pointers that would help immensely. Fixing this edge case is one
of the last things holding up a first public release of the tool.

Many thanks,

Matt

-- 
Matt Mower :: http://matt.blogs.it/


From thurs... at cs.queensu.ca  Tue Jan 16 00:06:49 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Mon, 15 Jan 2007 19:06:49 -0500
Subject: [ragel-users] Fixing an edge case
In-Reply-To: <d56373190701150857m55c30464h584961023b62a012@mail.gmail.com>
References: <d56373190701150857m55c30464h584961023b62a012@mail.gmail.com>
Message-ID: <45AC1719.60607@cs.queensu.ca>

Hi Matt, try the attached file. The important part is in diff machine. The
first alternative handles the edge case of an empty diff. The second part
handles the regular case.

-Adrian
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: tmp.rl
URL: <http://www.colm.net/pipermail/ragel/attachments/20070115/4d45d754/attachment.ksh>

From thurs... at cs.queensu.ca  Tue Jan 16 16:55:33 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Tue, 16 Jan 2007 11:55:33 -0500
Subject: [ragel-users] Re: Fixing an edge case
In-Reply-To: <45AC1719.60607@cs.queensu.ca>
References: <d56373190701150857m55c30464h584961023b62a012@mail.gmail.com> <45AC1719.60607@cs.queensu.ca>
Message-ID: <45AD0385.7040602@cs.queensu.ca>

Sorry, this was sloppy ... the question mark in the diff machine can be removed.

-Adrian

Adrian Thurston wrote:
> Hi Matt, try the attached file. The important part is in diff machine. The
> first alternative handles the edge case of an empty diff. The second part
> handles the regular case.
> 
> -Adrian
> 
> > 
> jinclude <stdio.h>
> 
> %%{
>     machine diff;
>     action count_line {}
>     action mark {}
>     action add_line {}
>     action push {}
>     action push_zero {}
>     action pop_hunk_spec {}
>     action copy_to_filespec {}
>     action enter_hunk { printf("  enter_hunk\n"); }
>     action exit_hunk {  printf("  exit_hunk\n"); }
>     action enter_diff { printf("enter_diff\n"); }
>     action exit_diff { printf("exit_diff\n"); }
>     action empty_diff { printf("  this diff is empty\n"); }
>     action binary_diff {}
>     action error {}
> 
>     nbsp = space - '\n' %count_line;
>     lineChar = extend - '\n';
>     
>     diffLine =         ( '\\' lineChar* '\n' %count_line ) |
>         ( ' ' | '-' | '+' ) >mark         lineChar* '\n' @add_line
> %count_line;
>     
>     separator = '='+ '\n' %count_line;
>     
>     oldFile = '---' lineChar+ '\n' %count_line;
>     newFile = '+++' lineChar+ '\n' %count_line;
>     
>     range = ( '-' | '+' ) ( digit+ >mark %push ) ( ' ' %push_zero
>             @{ fhold; }  | ',' ( digit+ >mark %push ) );
>     
>     hunkHeader = '@@' nbsp* range nbsp+ range nbsp* '@@' '\n'
>         @pop_hunk_spec %count_line;
>     
>     hunkBody = diffLine+;
>     
>     hunk = hunkHeader >enter_hunk hunkBody %exit_hunk %/exit_hunk;
>     
>     fileName = ( lineChar+ ) >mark %copy_to_filespec;
>     
>     fileSpec = "Index:" nbsp+ fileName '\n'+ @count_line;
>     
>     diffHeader = fileSpec separator;
>     
>     diffBody = hunk*;
>     
>     binaryDiff = 'C' lineChar+ '\n' %count_line lineChar+ '\n'
>         %binary_diff %count_line;
>     
>     textDiff = oldFile newFile diffBody;
>     
>     diff = (
>         diffHeader %empty_diff %/empty_diff |
>         diffHeader ( binaryDiff | textDiff ) ?
>     )
>     >enter_diff    %exit_diff %/exit_diff;
>     
>     main := diff* $!error;
> }%%
> 
> %% write data;
> 
> int main()
> {
>     static char buf[2000000];
>     int len = fread( buf, 1, sizeof(buf), stdin );
>     printf( "%i\n", len );
> 
>     int cs;
>     char *p = buf, *pe = buf+len;
>     %%{
>         write init;
>         write exec;
>     }%%
> 
>     if ( cs < diff_first_final )
>         printf(" ERROR \n" );
>     else {
>         %% write eof;
>     }
>     return 0;
> }
> 


From thurs... at cs.queensu.ca  Tue Jan 16 19:07:21 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Tue, 16 Jan 2007 14:07:21 -0500
Subject: [ragel-users] Re: Fixing an edge case
In-Reply-To: <45AD0385.7040602@cs.queensu.ca>
References: <d56373190701150857m55c30464h584961023b62a012@mail.gmail.com> <45AC1719.60607@cs.queensu.ca> <45AD0385.7040602@cs.queensu.ca>
Message-ID: <45AD2269.7050704@cs.queensu.ca>

I've made this thread a little confusing, so here's a recap with some
explanations.

This machine does not do what you want. It does properly execute empty_diff
when an empty diff is found, but it also executes empty_diff on the
transitions from diffHeader to either binaryDiff or textDiff.

diff1 = (
	diffHeader %empty_diff %/empty_diff
	( binaryDiff | textDiff ) ?
);


The following code is one way to fix the problem. It's like the above, but
separates the leaving/eof actions from the non-empty case. When diff2 exits
after only a diffHeader the empty diff action is executed. Note that here
diffHeader is unioned with itself. This relies on the fact that ragel
removes action duplicates from transition lists. Otherwise the actions of
diffHeader would be doubled up.

diff2 = (
	diffHeader %empty_diff %/empty_diff |
	diffHeader ( binaryDiff | textDiff )
);

And finally, this is another way to do it. I essentially factor out the
diffHeader. The "" machine is a single state which has the leaving/eof
actions embedded into it.
	
diff3 = (
	diffHeader (
		"" %empty_diff %/empty_diff |
		( binaryDiff | textDiff )
	)
);


I hope this helps,
 Adrian


From s... at mattmower.com  Tue Jan 16 21:55:12 2007
From: s... at mattmower.com (Matt Mower)
Date: Tue, 16 Jan 2007 21:55:12 +0000
Subject: [ragel-users] Re: Fixing an edge case
In-Reply-To: <45AD2269.7050704@cs.queensu.ca>
References: <d56373190701150857m55c30464h584961023b62a012@mail.gmail.com>
	 <45AC1719.60607@cs.queensu.ca> <45AD0385.7040602@cs.queensu.ca>
	 <45AD2269.7050704@cs.queensu.ca>
Message-ID: <d56373190701161355u3acae0ecl97885e4aadaa64cd@mail.gmail.com>

Hi Adrian,

Many thanks for the recap :)

On 16/01/07, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
> The following code is one way to fix the problem. It's like the above, but
> separates the leaving/eof actions from the non-empty case. When diff2 exits
> after only a diffHeader the empty diff action is executed. Note that here
> diffHeader is unioned with itself. This relies on the fact that ragel
> removes action duplicates from transition lists. Otherwise the actions of
> diffHeader would be doubled up.
>
> diff2 = (
>         diffHeader %empty_diff %/empty_diff |
>         diffHeader ( binaryDiff | textDiff )
> );
>

Interesting, so it can track that the leaving action should only
happen when neither of the non-empty diff paths is taken after
reduction? My gut feeling would have been that it would end up
executing them every time. I shall have to graph it and take a look.

> And finally, this is another way to do it. I essentially factor out the
> diffHeader. The "" machine is a single state which has the leaving/eof
> actions embedded into it.
>
> diff3 = (
>         diffHeader (
>                 "" %empty_diff %/empty_diff |
>                 ( binaryDiff | textDiff )
>         )
> );
>

Ah, I think that's more what I was intuitively trying to grasp for. Cool.

Thanks again for your help!

Regards,

Matt

-- 
Matt Mower :: http://matt.blogs.it/


From thurs... at cs.queensu.ca  Wed Jan 17 01:47:55 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Tue, 16 Jan 2007 20:47:55 -0500
Subject: [ragel-users] Re: Fixing an edge case
In-Reply-To: <d56373190701161355u3acae0ecl97885e4aadaa64cd@mail.gmail.com>
References: <d56373190701150857m55c30464h584961023b62a012@mail.gmail.com> <45AC1719.60607@cs.queensu.ca> <45AD0385.7040602@cs.queensu.ca> <45AD2269.7050704@cs.queensu.ca> <d56373190701161355u3acae0ecl97885e4aadaa64cd@mail.gmail.com>
Message-ID: <45AD804B.9060806@cs.queensu.ca>


Matt Mower wrote:
>> diff2 = (
>>         diffHeader %empty_diff %/empty_diff |
>>         diffHeader ( binaryDiff | textDiff )
>> );
>>
> 
> Interesting, so it can track that the leaving action should only
> happen when neither of the non-empty diff paths is taken after
> reduction? My gut feeling would have been that it would end up
> executing them every time. I shall have to graph it and take a look.

Leaving actions initially go into final states. They stay there, inactive,
until transitions are made which leave the machine from those final states.
This leaving is either by concatenation or by kleene star. So the
%empty_diff is left alone by the union, but when kleene star is applied to
diff2 it is transferred to the transition which wraps around and starts
diff2 over again.

If you were to use the @ action embedding operator then it would be executed
on the final character of diffHeader in both cases because it goes right
into transitions. It is not 'pending' as is the % operator.

Regards,
 Adrian


From thurs... at cs.queensu.ca  Sun Jan 21 23:58:30 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Sun, 21 Jan 2007 18:58:30 -0500 (EST)
Subject: public read-only svn repository
Message-ID: <1917.66.102.72.38.1169423910.squirrel@mambo.cs.queensu.ca>

Greetings,

There is now a public read-only subversion repository in which I will do
all my committing. It can be found at:

svn://mambo.cs.queensu.ca/

In it you'll find:

/ragel/tags/
/ragel/branches/
/ragel/trunk/

Cheers,
 Adrian


From dam... at gmail.com  Sat Jan 20 21:20:52 2007
From: dam... at gmail.com (Damir Nedzibovic)
Date: Sat, 20 Jan 2007 21:20:52 -0000
Subject: ragel and memory usage
Message-ID: <1169328052.670628.158880@m58g2000cwm.googlegroups.com>

Hi all,

I'm trying to build a grammar for parsing SIP headers (from rfc3261),
but I have encountered a problem which I cannot solve - it seems that
there's a state explosion somewhere when I try to compile my grammar
with ragel 5.16.

here's my grammar (sorry for pasting all of it here)

-- cut --
%%{
  machine sip_parser;

  action mark
  {
  }

  action req_i
  {
  }

  action req_a
  {
  }

  action req_o
  {
  }

  action req_b
  {
  }

  action req_c
  {
  }

  action req_r
  {
  }

  action create_req
  {
  }

  action request_method
  {
  }

  action uri_host
  {
  }

  action done
  {
    fbreak;
  }

  action uri_port
  {
  }

  action uri_pass
  {
  }

  action uri_user
  {
  }

  action uri_scheme
  {
  }

  action set_req_uri
  {
  }

  action add_param
  {
  }

  action add_param_value
  {
  }

  action uri_query
  {
  }

#### SIP PROTOCOL GRAMMAR

  CRLF = "\r\n";
  SP = " ";
  HTAB = "\t";
  DQUOTE = "\"";
  LHEX = digit | [a-f];

  alphanum = [a-zA-Z0-9];
  reserved = (";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" | "$" |
",");
  mark = ("-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")");
  unreserved = (alphanum | mark);
  escaped = ("%" xdigit xdigit);

  LWS = ((" "* CRLF)? " "+);
  SWS = (LWS?);

  HCOLON = ((" " | "\t")* ":" SWS);

  token = (alphanum | "-" | "." | "!" | "%" | "*" | "_" | "+" | "`" |
"'" | "~" )+;
  separators = ("(" | ")" | "<" | ">" | "@" | "," | ";" | ":" | "\\" |
DQUOTE | "/" | "[" | "]" | "?" | "=" | "{" | "}" | SP | HTAB);
  word = (alphanum | "-" | "." | "!" | "%" | "*" | "_" | "+" | "`" |
"'" | "~" | "(" | ")" | "<" | ">" | ":" | "\\" | DQUOTE | "/" | "[" |
"]" | "?" | "{" | "}")+;

  STAR   = (SWS "*" SWS);
  SLASH  = (SWS "/" SWS);
  EQUAL  = (SWS "=" SWS);
  LPAREN = (SWS "(" SWS);
  RPAREN = (SWS ")" SWS);
  RAQUOT = (">" SWS);
  LAQUOT = (SWS "<");
  COMMA  = (SWS "," SWS);
  SEMI   = (SWS ";" SWS);
  COLON  = (SWS ":" SWS);
  LDQUOT = (SWS DQUOTE);
  RDQUOT = (DQUOTE SWS);

  qdtext = (LWS | 0x21 | 0x23..0x5B | 0x5D..0x7E);
  quoted_pair = ("\\" (0x00..0x09 | 0x0B..0x0C | 0x0E..0x7F));
  quoted_string = (SWS DQUOTE (qdtext | quoted_pair)* DQUOTE);
  ctext    = (0x21..27 | 0x2A..0x5B | 0x5D..0x7E | LWS);
  comment_r = (LPAREN? (ctext | quoted_pair) RPAREN?);
  comment  = (LPAREN (comment_r)* RPAREN);

  port = digit+;
  IPv4address =  (digit{1,3} "." digit{1,3} "." digit{1,3} "."
digit{1,3});
  toplabel = (alpha | (alpha (alphanum | "-")* alphanum));
  domainlabel = (alphanum | (alphanum (alphanum | "-")* alphanum));
  hostname = ((domainlabel ".")* toplabel "."?);
  host = (hostname | IPv4address);
  hostport = (host >mark %uri_host (":" port >mark %uri_port)?);
  password = ((unreserved | escaped | "&" | "=" | "+" | "$" | "," )*);
  user_unreserved = ("&" | "=" | "+" | "$" | "," | ";" | "?" | "/");
  user = ((unreserved | escaped | user_unreserved)+);
  userinfo = (user >mark %uri_user (":" password >mark %uri_pass)?
"@");

  extension_method = token;
  Method = (("INVITE" %req_i | "ACK" %req_a | "OPTIONS" %req_o | "BYE"
%req_b | "CANCEL" %req_c | "REGISTER" %req_r | extension_method)) >mark
%request_method;

  hnv_unreserved = ("[" | "]" | "|" | "?" | ":" | "+" | "$");
  hvalue = ((hnv_unreserved | unreserved | escaped)*);
  hname = ((hnv_unreserved | unreserved | escaped)+);
  header = (hname "=" hvalue);
  headers = ("?" header ("&" header)*);
  param_unreserved = ("[" | "]" | "/" | ":" | "&" | "+" | "$");
  paramchar = (param_unreserved | unreserved | escaped);
  pvalue = (paramchar+);
  pname = (paramchar+);
  other_param = (pname >mark %add_param ("=" pvalue >mark
%add_param_value)?);
  lr_param = "lr" >mark %add_param;
  maddr_param = "maddr" >mark %add_param "=" host >mark
%add_param_value;
  method_param = "method" >mark %add_param "=" Method >mark
%add_param_value;
  ttl = (digit{1,3});
  ttl_param = "ttl" >mark %add_param "=" ttl >mark %add_param_value;
  other_user = token;
  user_param = "user" >mark %add_param "=" ("phone" | "ip" |
other_user) >mark %add_param_value;
  other_transport = token;
  transport_param = ("transport" >mark %add_param "=" ("udp" | "tcp" |
"sctp" | "tls" | other_transport) >mark %add_param_value);
  uri_parameter = (transport_param | user_param | method_param |
ttl_param | maddr_param | lr_param | other_param);
  uri_parameters = ((";" uri_parameter)*);
  SIP_URI = ("sip:" %{ m_data->m_uri.scheme() = "sip"; } (userinfo)?
hostport uri_parameters (headers)?);
  SIPS_URI = ("sips:" %{ m_data->m_uri.scheme() = "sips"; } (userinfo)?
hostport uri_parameters (headers)?);

  x_token = ("x-" token);
  ietf_token = token;
  extension_token = (ietf_token | x_token);
  composite_type = ("message" | "multipart" | extension_token);
  discrete_type = ("text" | "image" | "audio" | "video" | "application"
| extension_token);
  m_type = (discrete_type | composite_type);

  m_value = (token | quoted_string);
  m_attribute = token;
  m_parameter = (m_attribute EQUAL m_value);
  iana_token = token;
  m_subtype = (extension_token | iana_token);

  uric           = (reserved | unreserved | escaped);
  query          = (uric*);
  reg_name       = (unreserved | escaped | "$" | "," | ";" | ":" | "@"
| "&" | "=" | "+" )+;
  srvr           = ((userinfo "@")? hostport)?;
  authority      = (srvr | reg_name);
  scheme         = (alpha (alpha | digit | "+" | "-" | "." )*);
  pchar          = (unreserved | escaped | ":" | "@" | "&" | "=" | "+"
| "$" | ",");
  param          = (pchar*);
  segment        = (pchar* (";" param)*);
  path_segments  = (segment ("/" segment)*);
  uric_no_slash  = (unreserved | escaped | ";" | "?" | ":" | "@" | "&"
| "=" | "+" | "$" | ",");
  opaque_part    = (uric_no_slash uric*);
  abs_path       = ("/" path_segments);
  net_path       = ("//" authority (abs_path)?);
  hier_part      = ((net_path | abs_path) ("?" query >mark
%uri_query)?);
  absoluteURI    = (scheme >mark %uri_scheme ":" (hier_part |
opaque_part));

  gen_value = (token | host | quoted_string);
  generic_param = (token (EQUAL gen_value)?);
  qvalue = (("0" ("." digit{,3})?) | ("1" ("." ("0"){,3})?));
  accept_param = (("q" EQUAL qvalue) | generic_param);
  media_range = (("*" "/" "*" | ( m_type SLASH "*" ) | ( m_type SLASH
m_subtype )) (SEMI m_parameter)*);
  accept_range = (media_range (SEMI accept_param)*);
  Accept = ("Accept" HCOLON (accept_range (COMMA accept_range)*))?;

  content_coding   = (token);
  codings          = (content_coding | "*");
  encoding         = (codings (SEMI accept_param)*);
  Accept_Encoding  = ("Accept-Encoding" HCOLON (encoding (COMMA
encoding)*)?);

  language_range   = (((alpha{1,8} ("-" alpha{1,8})*) | "*" ));
  language         = (language_range (SEMI accept_param)*);
  Accept_Language  = ("Accept-Language" HCOLON (language (COMMA
language)*)?);

  alert_param      = (LAQUOT absoluteURI RAQUOT (SEMI generic_param
)*);
  Alert_Info       = ("Alert-Info" HCOLON alert_param (COMMA
alert_param)*);

  Allow            = ("Allow" HCOLON (Method (COMMA Method)*)?);

  opaque           = ("opaque" EQUAL quoted_string);
  algorithm        = ("algorithm" EQUAL ("MD5" | "MD5-sess" | token));
  realm_value      = (quoted_string);
  realm            = ("realm" EQUAL realm_value);
  auth_scheme      = (token);
  auth_param_name  = (token);
  auth_param       = (auth_param_name EQUAL (token | quoted_string));
  other_response   = (auth_scheme LWS auth_param (COMMA auth_param)*);
  request_digest   = (LDQUOT LHEX{32} RDQUOT);
  dresponse        = ("response" EQUAL request_digest);
  nonce_value      = (quoted_string);
  nonce            = ("nonce" EQUAL nonce_value);
  nc_value         = (LHEX{8});
  nonce_count      = ("nc" EQUAL nc_value);
  cnonce_value     = (nonce_value);
  cnonce           = ("cnonce" EQUAL cnonce_value);
  qop_value        = ("auth" | "auth-int" | token);
  message_qop      = ("qop" EQUAL qop_value);
  digest_uri_value = (absoluteURI); # fixme
  digest_uri       = ("uri" EQUAL LDQUOT digest_uri_value RDQUOT);
  username_value   = (quoted_string);
  username         = ("username" EQUAL username_value);
  dig_resp         = (username | realm | nonce | digest_uri | dresponse
| algorithm | cnonce | opaque | message_qop | nonce_count |
auth_param);
  digest_response  = (dig_resp (COMMA dig_resp)*);
  credentials      = (("Digest" LWS digest_response) | other_response);
  Authorization    = ("Authorization" HCOLON credentials);

  response_digest      = (LDQUOT LHEX* RDQUOT);
  response_auth        = ("rspauth" EQUAL response_digest);
  nextnonce            = ("nextnonce" EQUAL nonce_value);
  ainfo                = (nextnonce | message_qop | response_auth |
cnonce | nonce_count);
  Authentication_Info  = ("Authentication-Info" HCOLON ainfo (COMMA
ainfo)*);

  callid   =  (word ("@" word)?);
  Call_ID  = (( "Call-ID" | "i" ) HCOLON callid);

  info_param  = (("purpose" EQUAL ("icon" | "info" | "card" | token)) |
generic_param);
  info        = (LAQUOT absoluteURI RAQUOT (SEMI info_param)*);
  Call_Info   = ("Call-Info" HCOLON info (COMMA info)*);

  delta_seconds      = (digit+);
  contact_extension  = (generic_param);
  c_p_expires    = ("expires" EQUAL delta_seconds);
  c_p_q          = ("q" EQUAL qvalue);
  contact_params = (c_p_q | c_p_expires);
  display_name   = ((token LWS)* | quoted_string);
  addr_spec      = (SIP_URI | SIPS_URI | absoluteURI);
  name_addr      = ((display_name)? LAQUOT addr_spec RAQUOT);
  contact_param  = ((name_addr | addr_spec) (SEMI contact_params)*);
  Contact     = (("Contact" | "m" ) HCOLON (STAR | (contact_param
(COMMA contact_param)*)));

  disp_extension_token  = (token);
  other_handling        = (token);
  handling_param        = ("handling" EQUAL ( "optional" | "required" |
other_handling));
  disp_param            = (handling_param | generic_param);
  disp_type             = ("render" | "session" | "icon" | "alert" |
disp_extension_token);
  Content_Disposition   = ("Content-Disposition" HCOLON disp_type (SEMI
disp_param)*);

  Content_Encoding  = (("Content-Encoding" | "e" ) HCOLON
content_coding (COMMA content_coding)*);

  subtag            = (alpha{1,8});
  primary_tag       = (alpha{1,8});
  language_tag      = (primary_tag ("-" subtag)*);
  Content_Language  = ("Content-Language" HCOLON language_tag (COMMA
language_tag)*);

  Content_Length    = (("Content-Length" | "l") HCOLON digit+);

  media_type        = (m_type SLASH m_subtype (SEMI m_parameter)*);
  Content_Type      = (("Content-Type" | "c" ) HCOLON media_type);

  CSeq = ("CSeq" HCOLON digit+ LWS Method);

  message_header = (Accept |
                    Accept_Encoding |
                    Accept_Language |
                    Alert_Info |
                    Allow |
                    Authentication_Info |
                    Authorization |
                    Call_ID |
                    Call_Info |
                    Contact |
                    Content_Disposition |
                    Content_Encoding |
                    Content_Language |
                    Content_Length |
                    Content_Type |
                    CSeq) CRLF;

  SIP_Version    = "SIP" "/" digit "." digit;
  Request_URI    = SIP_URI | SIPS_URI | absoluteURI;
  Request_Line   = Method %create_req SP Request_URI %set_req_uri SP
SIP_Version CRLF;
  Request        = Request_Line (message_header)* CRLF;

main := Request;
}%%

%% write data;

-- cut --

it seems the problem is in this line:
hier_part      = ((net_path | abs_path) ("?" query >mark %uri_query)?);

if I remove ">mark %uri_query" ragel is able to generate the code.

Can anyone give me a clue what's going on here?

tia,
d


From dam... at gmail.com  Sat Jan 20 21:40:53 2007
From: dam... at gmail.com (Damir Nedzibovic)
Date: Sat, 20 Jan 2007 21:40:53 -0000
Subject: ragel and memory usage
Message-ID: <1169329253.204791.3690@38g2000cwa.googlegroups.com>

Hi all,

I'm trying to build a grammar for parsing SIP messages (as in rfc3261),
but I have encountered a problem that I cannot solve - it seems that
I've hit a state explosion, since ragel just keeps allocating memory
and finally dies.

Here's my grammar (sorry for pasting it here like this)

--cut--
%%{
  machine sip_parser;

  action mark
  {
  }

  action req_i
  {
  }

  action req_a
  {
  }

  action req_o
  {
  }

  action req_b
  {
  }

  action req_c
  {
  }

  action req_r
  {
  }

  action create_req
  {
  }

  action request_method
  {
  }

  action uri_host
  {
  }

  action done
  {
    fbreak;
  }

  action uri_port
  {
  }

  action uri_pass
  {
  }

  action uri_user
  {
  }

  action uri_scheme
  {
  }

  action set_req_uri
  {
  }

  action add_param
  {
  }

  action add_param_value
  {
  }

  action uri_query
  {
  }

#### SIP PROTOCOL GRAMMAR

  CRLF = "\r\n";
  SP = " ";
  HTAB = "\t";
  DQUOTE = "\"";
  LHEX = digit | [a-f];

  alphanum = [a-zA-Z0-9];
  reserved = (";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" | "$" |
",");
  mark = ("-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")");
  unreserved = (alphanum | mark);
  escaped = ("%" xdigit xdigit);

  LWS = ((" "* CRLF)? " "+);
  SWS = (LWS?);

  HCOLON = ((" " | "\t")* ":" SWS);

  token = (alphanum | "-" | "." | "!" | "%" | "*" | "_" | "+" | "`" |
"'" | "~" )+;
  separators = ("(" | ")" | "<" | ">" | "@" | "," | ";" | ":" | "\\" |
DQUOTE | "/" | "[" | "]" | "?" | "=" | "{" | "}" | SP | HTAB);
  word = (alphanum | "-" | "." | "!" | "%" | "*" | "_" | "+" | "`" |
"'" | "~" | "(" | ")" | "<" | ">" | ":" | "\\" | DQUOTE | "/" | "[" |
"]" | "?" | "{" | "}")+;

  STAR   = (SWS "*" SWS);
  SLASH  = (SWS "/" SWS);
  EQUAL  = (SWS "=" SWS);
  LPAREN = (SWS "(" SWS);
  RPAREN = (SWS ")" SWS);
  RAQUOT = (">" SWS);
  LAQUOT = (SWS "<");
  COMMA  = (SWS "," SWS);
  SEMI   = (SWS ";" SWS);
  COLON  = (SWS ":" SWS);
  LDQUOT = (SWS DQUOTE);
  RDQUOT = (DQUOTE SWS);

  qdtext = (LWS | 0x21 | 0x23..0x5B | 0x5D..0x7E);
  quoted_pair = ("\\" (0x00..0x09 | 0x0B..0x0C | 0x0E..0x7F));
  quoted_string = (SWS DQUOTE (qdtext | quoted_pair)* DQUOTE);
  ctext    = (0x21..27 | 0x2A..0x5B | 0x5D..0x7E | LWS);
  comment_r = (LPAREN? (ctext | quoted_pair) RPAREN?);
  comment  = (LPAREN (comment_r)* RPAREN);

  port = digit+;
  IPv4address =  (digit{1,3} "." digit{1,3} "." digit{1,3} "."
digit{1,3});
  toplabel = (alpha | (alpha (alphanum | "-")* alphanum));
  domainlabel = (alphanum | (alphanum (alphanum | "-")* alphanum));
  hostname = ((domainlabel ".")* toplabel "."?);
  host = (hostname | IPv4address);
  hostport = (host >mark %uri_host (":" port >mark %uri_port)?);
  password = ((unreserved | escaped | "&" | "=" | "+" | "$" | "," )*);
  user_unreserved = ("&" | "=" | "+" | "$" | "," | ";" | "?" | "/");
  user = ((unreserved | escaped | user_unreserved)+);
  userinfo = (user >mark %uri_user (":" password >mark %uri_pass)?
"@");

  extension_method = token;
  Method = (("INVITE" %req_i | "ACK" %req_a | "OPTIONS" %req_o | "BYE"
%req_b | "CANCEL" %req_c | "REGISTER" %req_r | extension_method)) >mark
%request_method;

  hnv_unreserved = ("[" | "]" | "|" | "?" | ":" | "+" | "$");
  hvalue = ((hnv_unreserved | unreserved | escaped)*);
  hname = ((hnv_unreserved | unreserved | escaped)+);
  header = (hname "=" hvalue);
  headers = ("?" header ("&" header)*);
  param_unreserved = ("[" | "]" | "/" | ":" | "&" | "+" | "$");
  paramchar = (param_unreserved | unreserved | escaped);
  pvalue = (paramchar+);
  pname = (paramchar+);
  other_param = (pname >mark %add_param ("=" pvalue >mark
%add_param_value)?);
  lr_param = "lr" >mark %add_param;
  maddr_param = "maddr" >mark %add_param "=" host >mark
%add_param_value;
  method_param = "method" >mark %add_param "=" Method >mark
%add_param_value;
  ttl = (digit{1,3});
  ttl_param = "ttl" >mark %add_param "=" ttl >mark %add_param_value;
  other_user = token;
  user_param = "user" >mark %add_param "=" ("phone" | "ip" |
other_user) >mark %add_param_value;
  other_transport = token;
  transport_param = ("transport" >mark %add_param "=" ("udp" | "tcp" |
"sctp" | "tls" | other_transport) >mark %add_param_value);
  uri_parameter = (transport_param | user_param | method_param |
ttl_param | maddr_param | lr_param | other_param);
  uri_parameters = ((";" uri_parameter)*);
  SIP_URI = ("sip:" %{ m_data->m_uri.scheme() = "sip"; } (userinfo)?
hostport uri_parameters (headers)?);
  SIPS_URI = ("sips:" %{ m_data->m_uri.scheme() = "sips"; } (userinfo)?
hostport uri_parameters (headers)?);

  x_token = ("x-" token);
  ietf_token = token;
  extension_token = (ietf_token | x_token);
  composite_type = ("message" | "multipart" | extension_token);
  discrete_type = ("text" | "image" | "audio" | "video" | "application"
| extension_token);
  m_type = (discrete_type | composite_type);

  m_value = (token | quoted_string);
  m_attribute = token;
  m_parameter = (m_attribute EQUAL m_value);
  iana_token = token;
  m_subtype = (extension_token | iana_token);

  uric           = (reserved | unreserved | escaped);
  query          = (uric*);
  reg_name       = (unreserved | escaped | "$" | "," | ";" | ":" | "@"
| "&" | "=" | "+" )+;
  srvr           = ((userinfo "@")? hostport)?;
  authority      = (srvr | reg_name);
  scheme         = (alpha (alpha | digit | "+" | "-" | "." )*);
  pchar          = (unreserved | escaped | ":" | "@" | "&" | "=" | "+"
| "$" | ",");
  param          = (pchar*);
  segment        = (pchar* (";" param)*);
  path_segments  = (segment ("/" segment)*);
  uric_no_slash  = (unreserved | escaped | ";" | "?" | ":" | "@" | "&"
| "=" | "+" | "$" | ",");
  opaque_part    = (uric_no_slash uric*);
  abs_path       = ("/" path_segments);
  net_path       = ("//" authority (abs_path)?);
  hier_part      = ((net_path | abs_path) ("?" query >mark
%uri_query)?);
  absoluteURI    = (scheme >mark %uri_scheme ":" (hier_part |
opaque_part));

  gen_value = (token | host | quoted_string);
  generic_param = (token (EQUAL gen_value)?);
  qvalue = (("0" ("." digit{,3})?) | ("1" ("." ("0"){,3})?));
  accept_param = (("q" EQUAL qvalue) | generic_param);
  media_range = (("*" "/" "*" | ( m_type SLASH "*" ) | ( m_type SLASH
m_subtype )) (SEMI m_parameter)*);
  accept_range = (media_range (SEMI accept_param)*);
  Accept = ("Accept" HCOLON (accept_range (COMMA accept_range)*))?;

  content_coding   = (token);
  codings          = (content_coding | "*");
  encoding         = (codings (SEMI accept_param)*);
  Accept_Encoding  = ("Accept-Encoding" HCOLON (encoding (COMMA
encoding)*)?);

  language_range   = (((alpha{1,8} ("-" alpha{1,8})*) | "*" ));
  language         = (language_range (SEMI accept_param)*);
  Accept_Language  = ("Accept-Language" HCOLON (language (COMMA
language)*)?);

  alert_param      = (LAQUOT absoluteURI RAQUOT (SEMI generic_param
)*);
  Alert_Info       = ("Alert-Info" HCOLON alert_param (COMMA
alert_param)*);

  Allow            = ("Allow" HCOLON (Method (COMMA Method)*)?);

  opaque           = ("opaque" EQUAL quoted_string);
  algorithm        = ("algorithm" EQUAL ("MD5" | "MD5-sess" | token));
  realm_value      = (quoted_string);
  realm            = ("realm" EQUAL realm_value);
  auth_scheme      = (token);
  auth_param_name  = (token);
  auth_param       = (auth_param_name EQUAL (token | quoted_string));
  other_response   = (auth_scheme LWS auth_param (COMMA auth_param)*);
  request_digest   = (LDQUOT LHEX{32} RDQUOT);
  dresponse        = ("response" EQUAL request_digest);
  nonce_value      = (quoted_string);
  nonce            = ("nonce" EQUAL nonce_value);
  nc_value         = (LHEX{8});
  nonce_count      = ("nc" EQUAL nc_value);
  cnonce_value     = (nonce_value);
  cnonce           = ("cnonce" EQUAL cnonce_value);
  qop_value        = ("auth" | "auth-int" | token);
  message_qop      = ("qop" EQUAL qop_value);
  digest_uri_value = (absoluteURI); # fixme
  digest_uri       = ("uri" EQUAL LDQUOT digest_uri_value RDQUOT);
  username_value   = (quoted_string);
  username         = ("username" EQUAL username_value);
  dig_resp         = (username | realm | nonce | digest_uri | dresponse
| algorithm | cnonce | opaque | message_qop | nonce_count |
auth_param);
  digest_response  = (dig_resp (COMMA dig_resp)*);
  credentials      = (("Digest" LWS digest_response) | other_response);
  Authorization    = ("Authorization" HCOLON credentials);

  response_digest      = (LDQUOT LHEX* RDQUOT);
  response_auth        = ("rspauth" EQUAL response_digest);
  nextnonce            = ("nextnonce" EQUAL nonce_value);
  ainfo                = (nextnonce | message_qop | response_auth |
cnonce | nonce_count);
  Authentication_Info  = ("Authentication-Info" HCOLON ainfo (COMMA
ainfo)*);

  callid   =  (word ("@" word)?);
  Call_ID  = (( "Call-ID" | "i" ) HCOLON callid);

  info_param  = (("purpose" EQUAL ("icon" | "info" | "card" | token)) |
generic_param);
  info        = (LAQUOT absoluteURI RAQUOT (SEMI info_param)*);
  Call_Info   = ("Call-Info" HCOLON info (COMMA info)*);

  delta_seconds      = (digit+);
  contact_extension  = (generic_param);
  c_p_expires    = ("expires" EQUAL delta_seconds);
  c_p_q          = ("q" EQUAL qvalue);
  contact_params = (c_p_q | c_p_expires);
  display_name   = ((token LWS)* | quoted_string);
  addr_spec      = (SIP_URI | SIPS_URI | absoluteURI);
  name_addr      = ((display_name)? LAQUOT addr_spec RAQUOT);
  contact_param  = ((name_addr | addr_spec) (SEMI contact_params)*);
  Contact     = (("Contact" | "m" ) HCOLON (STAR | (contact_param
(COMMA contact_param)*)));

  disp_extension_token  = (token);
  other_handling        = (token);
  handling_param        = ("handling" EQUAL ( "optional" | "required" |
other_handling));
  disp_param            = (handling_param | generic_param);
  disp_type             = ("render" | "session" | "icon" | "alert" |
disp_extension_token);
  Content_Disposition   = ("Content-Disposition" HCOLON disp_type (SEMI
disp_param)*);

  Content_Encoding  = (("Content-Encoding" | "e" ) HCOLON
content_coding (COMMA content_coding)*);

  subtag            = (alpha{1,8});
  primary_tag       = (alpha{1,8});
  language_tag      = (primary_tag ("-" subtag)*);
  Content_Language  = ("Content-Language" HCOLON language_tag (COMMA
language_tag)*);

  Content_Length    = (("Content-Length" | "l") HCOLON digit+);

  media_type        = (m_type SLASH m_subtype (SEMI m_parameter)*);
  Content_Type      = (("Content-Type" | "c" ) HCOLON media_type);

  CSeq = ("CSeq" HCOLON digit+ LWS Method);

  message_header = (Accept |
                    Accept_Encoding |
                    Accept_Language |
                    Alert_Info |
                    Allow |
                    Authentication_Info |
                    Authorization |
                    Call_ID |
                    Call_Info |
                    Contact |
                    Content_Disposition |
                    Content_Encoding |
                    Content_Language |
                    Content_Length |
                    Content_Type |
                    CSeq) CRLF;

  SIP_Version    = "SIP" "/" digit "." digit;
  Request_URI    = SIP_URI | SIPS_URI | absoluteURI;
  Request_Line   = Method %create_req SP Request_URI %set_req_uri SP
SIP_Version CRLF;
  Request        = Request_Line (message_header)* CRLF;

main := Request;
}%%

%% write data;
--cut--

I think that problems is somewhere around this line:

hier_part      = ((net_path | abs_path) ("?" query >mark %uri_query)?);

if I remove the ">mark %uri_query" part, ragel is able to complete the
operation.
Can anyone give me some clues what's gone bad?

tia,
d


From thurs... at cs.queensu.ca  Sat Jan 20 22:54:34 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Sat, 20 Jan 2007 17:54:34 -0500 (EST)
Subject: [ragel-users] ragel and memory usage
In-Reply-To: <1169329253.204791.3690@38g2000cwa.googlegroups.com>
References: <1169329253.204791.3690@38g2000cwa.googlegroups.com>
Message-ID: <1837.66.102.71.213.1169333674.squirrel@mambo.cs.queensu.ca>

Hi Damir,

There is likely an ambiguity in there which causes a state explosion. But
since the grammar is so large, trying to track it down is probably not
worth anybody's time. Instead I would suggest starting from scratch and
taking an incremental approach. Start with a simple superset of the
language. For example just separate the request line from the headers and
the message body. Be liberal with actions. Verify that it works properly,
then slowly refine the grammar. If you take this approach and test
frequently you'll easily discover where the ambiguities are because
suddenly things will go way wrong.

-Adrian

>
> Hi all,
>
> I'm trying to build a grammar for parsing SIP messages (as in rfc3261),
> but I have encountered a problem that I cannot solve - it seems that
> I've hit a state explosion, since ragel just keeps allocating memory
> and finally dies.
>
> Here's my grammar (sorry for pasting it here like this)
>
> --cut--
> %%{
>   machine sip_parser;
>
>   action mark
>   {
>   }
>
>   action req_i
>   {
>   }
>
>   action req_a
>   {
>   }
>
>   action req_o
>   {
>   }
>
>   action req_b
>   {
>   }
>
>   action req_c
>   {
>   }
>
>   action req_r
>   {
>   }
>
>   action create_req
>   {
>   }
>
>   action request_method
>   {
>   }
>
>   action uri_host
>   {
>   }
>
>   action done
>   {
>     fbreak;
>   }
>
>   action uri_port
>   {
>   }
>
>   action uri_pass
>   {
>   }
>
>   action uri_user
>   {
>   }
>
>   action uri_scheme
>   {
>   }
>
>   action set_req_uri
>   {
>   }
>
>   action add_param
>   {
>   }
>
>   action add_param_value
>   {
>   }
>
>   action uri_query
>   {
>   }
>
> #### SIP PROTOCOL GRAMMAR
>
>   CRLF = "\r\n";
>   SP = " ";
>   HTAB = "\t";
>   DQUOTE = "\"";
>   LHEX = digit | [a-f];
>
>   alphanum = [a-zA-Z0-9];
>   reserved = (";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" | "$" |
> ",");
>   mark = ("-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")");
>   unreserved = (alphanum | mark);
>   escaped = ("%" xdigit xdigit);
>
>   LWS = ((" "* CRLF)? " "+);
>   SWS = (LWS?);
>
>   HCOLON = ((" " | "\t")* ":" SWS);
>
>   token = (alphanum | "-" | "." | "!" | "%" | "*" | "_" | "+" | "`" |
> "'" | "~" )+;
>   separators = ("(" | ")" | "<" | ">" | "@" | "," | ";" | ":" | "\\" |
> DQUOTE | "/" | "[" | "]" | "?" | "=" | "{" | "}" | SP | HTAB);
>   word = (alphanum | "-" | "." | "!" | "%" | "*" | "_" | "+" | "`" |
> "'" | "~" | "(" | ")" | "<" | ">" | ":" | "\\" | DQUOTE | "/" | "[" |
> "]" | "?" | "{" | "}")+;
>
>   STAR   = (SWS "*" SWS);
>   SLASH  = (SWS "/" SWS);
>   EQUAL  = (SWS "=" SWS);
>   LPAREN = (SWS "(" SWS);
>   RPAREN = (SWS ")" SWS);
>   RAQUOT = (">" SWS);
>   LAQUOT = (SWS "<");
>   COMMA  = (SWS "," SWS);
>   SEMI   = (SWS ";" SWS);
>   COLON  = (SWS ":" SWS);
>   LDQUOT = (SWS DQUOTE);
>   RDQUOT = (DQUOTE SWS);
>
>   qdtext = (LWS | 0x21 | 0x23..0x5B | 0x5D..0x7E);
>   quoted_pair = ("\\" (0x00..0x09 | 0x0B..0x0C | 0x0E..0x7F));
>   quoted_string = (SWS DQUOTE (qdtext | quoted_pair)* DQUOTE);
>   ctext    = (0x21..27 | 0x2A..0x5B | 0x5D..0x7E | LWS);
>   comment_r = (LPAREN? (ctext | quoted_pair) RPAREN?);
>   comment  = (LPAREN (comment_r)* RPAREN);
>
>   port = digit+;
>   IPv4address =  (digit{1,3} "." digit{1,3} "." digit{1,3} "."
> digit{1,3});
>   toplabel = (alpha | (alpha (alphanum | "-")* alphanum));
>   domainlabel = (alphanum | (alphanum (alphanum | "-")* alphanum));
>   hostname = ((domainlabel ".")* toplabel "."?);
>   host = (hostname | IPv4address);
>   hostport = (host >mark %uri_host (":" port >mark %uri_port)?);
>   password = ((unreserved | escaped | "&" | "=" | "+" | "$" | "," )*);
>   user_unreserved = ("&" | "=" | "+" | "$" | "," | ";" | "?" | "/");
>   user = ((unreserved | escaped | user_unreserved)+);
>   userinfo = (user >mark %uri_user (":" password >mark %uri_pass)?
> "@");
>
>   extension_method = token;
>   Method = (("INVITE" %req_i | "ACK" %req_a | "OPTIONS" %req_o | "BYE"
> %req_b | "CANCEL" %req_c | "REGISTER" %req_r | extension_method)) >mark
> %request_method;
>
>   hnv_unreserved = ("[" | "]" | "|" | "?" | ":" | "+" | "$");
>   hvalue = ((hnv_unreserved | unreserved | escaped)*);
>   hname = ((hnv_unreserved | unreserved | escaped)+);
>   header = (hname "=" hvalue);
>   headers = ("?" header ("&" header)*);
>   param_unreserved = ("[" | "]" | "/" | ":" | "&" | "+" | "$");
>   paramchar = (param_unreserved | unreserved | escaped);
>   pvalue = (paramchar+);
>   pname = (paramchar+);
>   other_param = (pname >mark %add_param ("=" pvalue >mark
> %add_param_value)?);
>   lr_param = "lr" >mark %add_param;
>   maddr_param = "maddr" >mark %add_param "=" host >mark
> %add_param_value;
>   method_param = "method" >mark %add_param "=" Method >mark
> %add_param_value;
>   ttl = (digit{1,3});
>   ttl_param = "ttl" >mark %add_param "=" ttl >mark %add_param_value;
>   other_user = token;
>   user_param = "user" >mark %add_param "=" ("phone" | "ip" |
> other_user) >mark %add_param_value;
>   other_transport = token;
>   transport_param = ("transport" >mark %add_param "=" ("udp" | "tcp" |
> "sctp" | "tls" | other_transport) >mark %add_param_value);
>   uri_parameter = (transport_param | user_param | method_param |
> ttl_param | maddr_param | lr_param | other_param);
>   uri_parameters = ((";" uri_parameter)*);
>   SIP_URI = ("sip:" %{ m_data->m_uri.scheme() = "sip"; } (userinfo)?
> hostport uri_parameters (headers)?);
>   SIPS_URI = ("sips:" %{ m_data->m_uri.scheme() = "sips"; } (userinfo)?
> hostport uri_parameters (headers)?);
>
>   x_token = ("x-" token);
>   ietf_token = token;
>   extension_token = (ietf_token | x_token);
>   composite_type = ("message" | "multipart" | extension_token);
>   discrete_type = ("text" | "image" | "audio" | "video" | "application"
> | extension_token);
>   m_type = (discrete_type | composite_type);
>
>   m_value = (token | quoted_string);
>   m_attribute = token;
>   m_parameter = (m_attribute EQUAL m_value);
>   iana_token = token;
>   m_subtype = (extension_token | iana_token);
>
>   uric           = (reserved | unreserved | escaped);
>   query          = (uric*);
>   reg_name       = (unreserved | escaped | "$" | "," | ";" | ":" | "@"
> | "&" | "=" | "+" )+;
>   srvr           = ((userinfo "@")? hostport)?;
>   authority      = (srvr | reg_name);
>   scheme         = (alpha (alpha | digit | "+" | "-" | "." )*);
>   pchar          = (unreserved | escaped | ":" | "@" | "&" | "=" | "+"
> | "$" | ",");
>   param          = (pchar*);
>   segment        = (pchar* (";" param)*);
>   path_segments  = (segment ("/" segment)*);
>   uric_no_slash  = (unreserved | escaped | ";" | "?" | ":" | "@" | "&"
> | "=" | "+" | "$" | ",");
>   opaque_part    = (uric_no_slash uric*);
>   abs_path       = ("/" path_segments);
>   net_path       = ("//" authority (abs_path)?);
>   hier_part      = ((net_path | abs_path) ("?" query >mark
> %uri_query)?);
>   absoluteURI    = (scheme >mark %uri_scheme ":" (hier_part |
> opaque_part));
>
>   gen_value = (token | host | quoted_string);
>   generic_param = (token (EQUAL gen_value)?);
>   qvalue = (("0" ("." digit{,3})?) | ("1" ("." ("0"){,3})?));
>   accept_param = (("q" EQUAL qvalue) | generic_param);
>   media_range = (("*" "/" "*" | ( m_type SLASH "*" ) | ( m_type SLASH
> m_subtype )) (SEMI m_parameter)*);
>   accept_range = (media_range (SEMI accept_param)*);
>   Accept = ("Accept" HCOLON (accept_range (COMMA accept_range)*))?;
>
>   content_coding   = (token);
>   codings          = (content_coding | "*");
>   encoding         = (codings (SEMI accept_param)*);
>   Accept_Encoding  = ("Accept-Encoding" HCOLON (encoding (COMMA
> encoding)*)?);
>
>   language_range   = (((alpha{1,8} ("-" alpha{1,8})*) | "*" ));
>   language         = (language_range (SEMI accept_param)*);
>   Accept_Language  = ("Accept-Language" HCOLON (language (COMMA
> language)*)?);
>
>   alert_param      = (LAQUOT absoluteURI RAQUOT (SEMI generic_param
> )*);
>   Alert_Info       = ("Alert-Info" HCOLON alert_param (COMMA
> alert_param)*);
>
>   Allow            = ("Allow" HCOLON (Method (COMMA Method)*)?);
>
>   opaque           = ("opaque" EQUAL quoted_string);
>   algorithm        = ("algorithm" EQUAL ("MD5" | "MD5-sess" | token));
>   realm_value      = (quoted_string);
>   realm            = ("realm" EQUAL realm_value);
>   auth_scheme      = (token);
>   auth_param_name  = (token);
>   auth_param       = (auth_param_name EQUAL (token | quoted_string));
>   other_response   = (auth_scheme LWS auth_param (COMMA auth_param)*);
>   request_digest   = (LDQUOT LHEX{32} RDQUOT);
>   dresponse        = ("response" EQUAL request_digest);
>   nonce_value      = (quoted_string);
>   nonce            = ("nonce" EQUAL nonce_value);
>   nc_value         = (LHEX{8});
>   nonce_count      = ("nc" EQUAL nc_value);
>   cnonce_value     = (nonce_value);
>   cnonce           = ("cnonce" EQUAL cnonce_value);
>   qop_value        = ("auth" | "auth-int" | token);
>   message_qop      = ("qop" EQUAL qop_value);
>   digest_uri_value = (absoluteURI); # fixme
>   digest_uri       = ("uri" EQUAL LDQUOT digest_uri_value RDQUOT);
>   username_value   = (quoted_string);
>   username         = ("username" EQUAL username_value);
>   dig_resp         = (username | realm | nonce | digest_uri | dresponse
> | algorithm | cnonce | opaque | message_qop | nonce_count |
> auth_param);
>   digest_response  = (dig_resp (COMMA dig_resp)*);
>   credentials      = (("Digest" LWS digest_response) | other_response);
>   Authorization    = ("Authorization" HCOLON credentials);
>
>   response_digest      = (LDQUOT LHEX* RDQUOT);
>   response_auth        = ("rspauth" EQUAL response_digest);
>   nextnonce            = ("nextnonce" EQUAL nonce_value);
>   ainfo                = (nextnonce | message_qop | response_auth |
> cnonce | nonce_count);
>   Authentication_Info  = ("Authentication-Info" HCOLON ainfo (COMMA
> ainfo)*);
>
>   callid   =  (word ("@" word)?);
>   Call_ID  = (( "Call-ID" | "i" ) HCOLON callid);
>
>   info_param  = (("purpose" EQUAL ("icon" | "info" | "card" | token)) |
> generic_param);
>   info        = (LAQUOT absoluteURI RAQUOT (SEMI info_param)*);
>   Call_Info   = ("Call-Info" HCOLON info (COMMA info)*);
>
>   delta_seconds      = (digit+);
>   contact_extension  = (generic_param);
>   c_p_expires    = ("expires" EQUAL delta_seconds);
>   c_p_q          = ("q" EQUAL qvalue);
>   contact_params = (c_p_q | c_p_expires);
>   display_name   = ((token LWS)* | quoted_string);
>   addr_spec      = (SIP_URI | SIPS_URI | absoluteURI);
>   name_addr      = ((display_name)? LAQUOT addr_spec RAQUOT);
>   contact_param  = ((name_addr | addr_spec) (SEMI contact_params)*);
>   Contact     = (("Contact" | "m" ) HCOLON (STAR | (contact_param
> (COMMA contact_param)*)));
>
>   disp_extension_token  = (token);
>   other_handling        = (token);
>   handling_param        = ("handling" EQUAL ( "optional" | "required" |
> other_handling));
>   disp_param            = (handling_param | generic_param);
>   disp_type             = ("render" | "session" | "icon" | "alert" |
> disp_extension_token);
>   Content_Disposition   = ("Content-Disposition" HCOLON disp_type (SEMI
> disp_param)*);
>
>   Content_Encoding  = (("Content-Encoding" | "e" ) HCOLON
> content_coding (COMMA content_coding)*);
>
>   subtag            = (alpha{1,8});
>   primary_tag       = (alpha{1,8});
>   language_tag      = (primary_tag ("-" subtag)*);
>   Content_Language  = ("Content-Language" HCOLON language_tag (COMMA
> language_tag)*);
>
>   Content_Length    = (("Content-Length" | "l") HCOLON digit+);
>
>   media_type        = (m_type SLASH m_subtype (SEMI m_parameter)*);
>   Content_Type      = (("Content-Type" | "c" ) HCOLON media_type);
>
>   CSeq = ("CSeq" HCOLON digit+ LWS Method);
>
>   message_header = (Accept |
>                     Accept_Encoding |
>                     Accept_Language |
>                     Alert_Info |
>                     Allow |
>                     Authentication_Info |
>                     Authorization |
>                     Call_ID |
>                     Call_Info |
>                     Contact |
>                     Content_Disposition |
>                     Content_Encoding |
>                     Content_Language |
>                     Content_Length |
>                     Content_Type |
>                     CSeq) CRLF;
>
>   SIP_Version    = "SIP" "/" digit "." digit;
>   Request_URI    = SIP_URI | SIPS_URI | absoluteURI;
>   Request_Line   = Method %create_req SP Request_URI %set_req_uri SP
> SIP_Version CRLF;
>   Request        = Request_Line (message_header)* CRLF;
>
> main := Request;
> }%%
>
> %% write data;
> --cut--
>
> I think that problems is somewhere around this line:
>
> hier_part      = ((net_path | abs_path) ("?" query >mark %uri_query)?);
>
> if I remove the ">mark %uri_query" part, ragel is able to complete the
> operation.
> Can anyone give me some clues what's gone bad?
>
> tia,
> d
>
>
> >



From thurs... at cs.queensu.ca  Sun Jan 21 06:00:15 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Sun, 21 Jan 2007 01:00:15 -0500 (EST)
Subject: [ragel-users] ragel and memory usage
In-Reply-To: <1169329253.204791.3690@38g2000cwa.googlegroups.com>
References: <1169329253.204791.3690@38g2000cwa.googlegroups.com>
Message-ID: <1157.66.102.72.164.1169359215.squirrel@mambo.cs.queensu.ca>

Hi, sorry I didn't notice the message text at the bottom. I'll have a look
at it to find out why it fails when adding the actions mentioned.

-Adrian


> Hi all,
>
> I'm trying to build a grammar for parsing SIP messages (as in rfc3261),
> but I have encountered a problem that I cannot solve - it seems that
> I've hit a state explosion, since ragel just keeps allocating memory
> and finally dies.
>
> Here's my grammar (sorry for pasting it here like this)
>
> --cut--
> %%{
>   machine sip_parser;
>
>   action mark
>   {
>   }
>
>   action req_i
>   {
>   }
>
>   action req_a
>   {
>   }
>
>   action req_o
>   {
>   }
>
>   action req_b
>   {
>   }
>
>   action req_c
>   {
>   }
>
>   action req_r
>   {
>   }
>
>   action create_req
>   {
>   }
>
>   action request_method
>   {
>   }
>
>   action uri_host
>   {
>   }
>
>   action done
>   {
>     fbreak;
>   }
>
>   action uri_port
>   {
>   }
>
>   action uri_pass
>   {
>   }
>
>   action uri_user
>   {
>   }
>
>   action uri_scheme
>   {
>   }
>
>   action set_req_uri
>   {
>   }
>
>   action add_param
>   {
>   }
>
>   action add_param_value
>   {
>   }
>
>   action uri_query
>   {
>   }
>
> #### SIP PROTOCOL GRAMMAR
>
>   CRLF = "\r\n";
>   SP = " ";
>   HTAB = "\t";
>   DQUOTE = "\"";
>   LHEX = digit | [a-f];
>
>   alphanum = [a-zA-Z0-9];
>   reserved = (";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" | "$" |
> ",");
>   mark = ("-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")");
>   unreserved = (alphanum | mark);
>   escaped = ("%" xdigit xdigit);
>
>   LWS = ((" "* CRLF)? " "+);
>   SWS = (LWS?);
>
>   HCOLON = ((" " | "\t")* ":" SWS);
>
>   token = (alphanum | "-" | "." | "!" | "%" | "*" | "_" | "+" | "`" |
> "'" | "~" )+;
>   separators = ("(" | ")" | "<" | ">" | "@" | "," | ";" | ":" | "\\" |
> DQUOTE | "/" | "[" | "]" | "?" | "=" | "{" | "}" | SP | HTAB);
>   word = (alphanum | "-" | "." | "!" | "%" | "*" | "_" | "+" | "`" |
> "'" | "~" | "(" | ")" | "<" | ">" | ":" | "\\" | DQUOTE | "/" | "[" |
> "]" | "?" | "{" | "}")+;
>
>   STAR   = (SWS "*" SWS);
>   SLASH  = (SWS "/" SWS);
>   EQUAL  = (SWS "=" SWS);
>   LPAREN = (SWS "(" SWS);
>   RPAREN = (SWS ")" SWS);
>   RAQUOT = (">" SWS);
>   LAQUOT = (SWS "<");
>   COMMA  = (SWS "," SWS);
>   SEMI   = (SWS ";" SWS);
>   COLON  = (SWS ":" SWS);
>   LDQUOT = (SWS DQUOTE);
>   RDQUOT = (DQUOTE SWS);
>
>   qdtext = (LWS | 0x21 | 0x23..0x5B | 0x5D..0x7E);
>   quoted_pair = ("\\" (0x00..0x09 | 0x0B..0x0C | 0x0E..0x7F));
>   quoted_string = (SWS DQUOTE (qdtext | quoted_pair)* DQUOTE);
>   ctext    = (0x21..27 | 0x2A..0x5B | 0x5D..0x7E | LWS);
>   comment_r = (LPAREN? (ctext | quoted_pair) RPAREN?);
>   comment  = (LPAREN (comment_r)* RPAREN);
>
>   port = digit+;
>   IPv4address =  (digit{1,3} "." digit{1,3} "." digit{1,3} "."
> digit{1,3});
>   toplabel = (alpha | (alpha (alphanum | "-")* alphanum));
>   domainlabel = (alphanum | (alphanum (alphanum | "-")* alphanum));
>   hostname = ((domainlabel ".")* toplabel "."?);
>   host = (hostname | IPv4address);
>   hostport = (host >mark %uri_host (":" port >mark %uri_port)?);
>   password = ((unreserved | escaped | "&" | "=" | "+" | "$" | "," )*);
>   user_unreserved = ("&" | "=" | "+" | "$" | "," | ";" | "?" | "/");
>   user = ((unreserved | escaped | user_unreserved)+);
>   userinfo = (user >mark %uri_user (":" password >mark %uri_pass)?
> "@");
>
>   extension_method = token;
>   Method = (("INVITE" %req_i | "ACK" %req_a | "OPTIONS" %req_o | "BYE"
> %req_b | "CANCEL" %req_c | "REGISTER" %req_r | extension_method)) >mark
> %request_method;
>
>   hnv_unreserved = ("[" | "]" | "|" | "?" | ":" | "+" | "$");
>   hvalue = ((hnv_unreserved | unreserved | escaped)*);
>   hname = ((hnv_unreserved | unreserved | escaped)+);
>   header = (hname "=" hvalue);
>   headers = ("?" header ("&" header)*);
>   param_unreserved = ("[" | "]" | "/" | ":" | "&" | "+" | "$");
>   paramchar = (param_unreserved | unreserved | escaped);
>   pvalue = (paramchar+);
>   pname = (paramchar+);
>   other_param = (pname >mark %add_param ("=" pvalue >mark
> %add_param_value)?);
>   lr_param = "lr" >mark %add_param;
>   maddr_param = "maddr" >mark %add_param "=" host >mark
> %add_param_value;
>   method_param = "method" >mark %add_param "=" Method >mark
> %add_param_value;
>   ttl = (digit{1,3});
>   ttl_param = "ttl" >mark %add_param "=" ttl >mark %add_param_value;
>   other_user = token;
>   user_param = "user" >mark %add_param "=" ("phone" | "ip" |
> other_user) >mark %add_param_value;
>   other_transport = token;
>   transport_param = ("transport" >mark %add_param "=" ("udp" | "tcp" |
> "sctp" | "tls" | other_transport) >mark %add_param_value);
>   uri_parameter = (transport_param | user_param | method_param |
> ttl_param | maddr_param | lr_param | other_param);
>   uri_parameters = ((";" uri_parameter)*);
>   SIP_URI = ("sip:" %{ m_data->m_uri.scheme() = "sip"; } (userinfo)?
> hostport uri_parameters (headers)?);
>   SIPS_URI = ("sips:" %{ m_data->m_uri.scheme() = "sips"; } (userinfo)?
> hostport uri_parameters (headers)?);
>
>   x_token = ("x-" token);
>   ietf_token = token;
>   extension_token = (ietf_token | x_token);
>   composite_type = ("message" | "multipart" | extension_token);
>   discrete_type = ("text" | "image" | "audio" | "video" | "application"
> | extension_token);
>   m_type = (discrete_type | composite_type);
>
>   m_value = (token | quoted_string);
>   m_attribute = token;
>   m_parameter = (m_attribute EQUAL m_value);
>   iana_token = token;
>   m_subtype = (extension_token | iana_token);
>
>   uric           = (reserved | unreserved | escaped);
>   query          = (uric*);
>   reg_name       = (unreserved | escaped | "$" | "," | ";" | ":" | "@"
> | "&" | "=" | "+" )+;
>   srvr           = ((userinfo "@")? hostport)?;
>   authority      = (srvr | reg_name);
>   scheme         = (alpha (alpha | digit | "+" | "-" | "." )*);
>   pchar          = (unreserved | escaped | ":" | "@" | "&" | "=" | "+"
> | "$" | ",");
>   param          = (pchar*);
>   segment        = (pchar* (";" param)*);
>   path_segments  = (segment ("/" segment)*);
>   uric_no_slash  = (unreserved | escaped | ";" | "?" | ":" | "@" | "&"
> | "=" | "+" | "$" | ",");
>   opaque_part    = (uric_no_slash uric*);
>   abs_path       = ("/" path_segments);
>   net_path       = ("//" authority (abs_path)?);
>   hier_part      = ((net_path | abs_path) ("?" query >mark
> %uri_query)?);
>   absoluteURI    = (scheme >mark %uri_scheme ":" (hier_part |
> opaque_part));
>
>   gen_value = (token | host | quoted_string);
>   generic_param = (token (EQUAL gen_value)?);
>   qvalue = (("0" ("." digit{,3})?) | ("1" ("." ("0"){,3})?));
>   accept_param = (("q" EQUAL qvalue) | generic_param);
>   media_range = (("*" "/" "*" | ( m_type SLASH "*" ) | ( m_type SLASH
> m_subtype )) (SEMI m_parameter)*);
>   accept_range = (media_range (SEMI accept_param)*);
>   Accept = ("Accept" HCOLON (accept_range (COMMA accept_range)*))?;
>
>   content_coding   = (token);
>   codings          = (content_coding | "*");
>   encoding         = (codings (SEMI accept_param)*);
>   Accept_Encoding  = ("Accept-Encoding" HCOLON (encoding (COMMA
> encoding)*)?);
>
>   language_range   = (((alpha{1,8} ("-" alpha{1,8})*) | "*" ));
>   language         = (language_range (SEMI accept_param)*);
>   Accept_Language  = ("Accept-Language" HCOLON (language (COMMA
> language)*)?);
>
>   alert_param      = (LAQUOT absoluteURI RAQUOT (SEMI generic_param
> )*);
>   Alert_Info       = ("Alert-Info" HCOLON alert_param (COMMA
> alert_param)*);
>
>   Allow            = ("Allow" HCOLON (Method (COMMA Method)*)?);
>
>   opaque           = ("opaque" EQUAL quoted_string);
>   algorithm        = ("algorithm" EQUAL ("MD5" | "MD5-sess" | token));
>   realm_value      = (quoted_string);
>   realm            = ("realm" EQUAL realm_value);
>   auth_scheme      = (token);
>   auth_param_name  = (token);
>   auth_param       = (auth_param_name EQUAL (token | quoted_string));
>   other_response   = (auth_scheme LWS auth_param (COMMA auth_param)*);
>   request_digest   = (LDQUOT LHEX{32} RDQUOT);
>   dresponse        = ("response" EQUAL request_digest);
>   nonce_value      = (quoted_string);
>   nonce            = ("nonce" EQUAL nonce_value);
>   nc_value         = (LHEX{8});
>   nonce_count      = ("nc" EQUAL nc_value);
>   cnonce_value     = (nonce_value);
>   cnonce           = ("cnonce" EQUAL cnonce_value);
>   qop_value        = ("auth" | "auth-int" | token);
>   message_qop      = ("qop" EQUAL qop_value);
>   digest_uri_value = (absoluteURI); # fixme
>   digest_uri       = ("uri" EQUAL LDQUOT digest_uri_value RDQUOT);
>   username_value   = (quoted_string);
>   username         = ("username" EQUAL username_value);
>   dig_resp         = (username | realm | nonce | digest_uri | dresponse
> | algorithm | cnonce | opaque | message_qop | nonce_count |
> auth_param);
>   digest_response  = (dig_resp (COMMA dig_resp)*);
>   credentials      = (("Digest" LWS digest_response) | other_response);
>   Authorization    = ("Authorization" HCOLON credentials);
>
>   response_digest      = (LDQUOT LHEX* RDQUOT);
>   response_auth        = ("rspauth" EQUAL response_digest);
>   nextnonce            = ("nextnonce" EQUAL nonce_value);
>   ainfo                = (nextnonce | message_qop | response_auth |
> cnonce | nonce_count);
>   Authentication_Info  = ("Authentication-Info" HCOLON ainfo (COMMA
> ainfo)*);
>
>   callid   =  (word ("@" word)?);
>   Call_ID  = (( "Call-ID" | "i" ) HCOLON callid);
>
>   info_param  = (("purpose" EQUAL ("icon" | "info" | "card" | token)) |
> generic_param);
>   info        = (LAQUOT absoluteURI RAQUOT (SEMI info_param)*);
>   Call_Info   = ("Call-Info" HCOLON info (COMMA info)*);
>
>   delta_seconds      = (digit+);
>   contact_extension  = (generic_param);
>   c_p_expires    = ("expires" EQUAL delta_seconds);
>   c_p_q          = ("q" EQUAL qvalue);
>   contact_params = (c_p_q | c_p_expires);
>   display_name   = ((token LWS)* | quoted_string);
>   addr_spec      = (SIP_URI | SIPS_URI | absoluteURI);
>   name_addr      = ((display_name)? LAQUOT addr_spec RAQUOT);
>   contact_param  = ((name_addr | addr_spec) (SEMI contact_params)*);
>   Contact     = (("Contact" | "m" ) HCOLON (STAR | (contact_param
> (COMMA contact_param)*)));
>
>   disp_extension_token  = (token);
>   other_handling        = (token);
>   handling_param        = ("handling" EQUAL ( "optional" | "required" |
> other_handling));
>   disp_param            = (handling_param | generic_param);
>   disp_type             = ("render" | "session" | "icon" | "alert" |
> disp_extension_token);
>   Content_Disposition   = ("Content-Disposition" HCOLON disp_type (SEMI
> disp_param)*);
>
>   Content_Encoding  = (("Content-Encoding" | "e" ) HCOLON
> content_coding (COMMA content_coding)*);
>
>   subtag            = (alpha{1,8});
>   primary_tag       = (alpha{1,8});
>   language_tag      = (primary_tag ("-" subtag)*);
>   Content_Language  = ("Content-Language" HCOLON language_tag (COMMA
> language_tag)*);
>
>   Content_Length    = (("Content-Length" | "l") HCOLON digit+);
>
>   media_type        = (m_type SLASH m_subtype (SEMI m_parameter)*);
>   Content_Type      = (("Content-Type" | "c" ) HCOLON media_type);
>
>   CSeq = ("CSeq" HCOLON digit+ LWS Method);
>
>   message_header = (Accept |
>                     Accept_Encoding |
>                     Accept_Language |
>                     Alert_Info |
>                     Allow |
>                     Authentication_Info |
>                     Authorization |
>                     Call_ID |
>                     Call_Info |
>                     Contact |
>                     Content_Disposition |
>                     Content_Encoding |
>                     Content_Language |
>                     Content_Length |
>                     Content_Type |
>                     CSeq) CRLF;
>
>   SIP_Version    = "SIP" "/" digit "." digit;
>   Request_URI    = SIP_URI | SIPS_URI | absoluteURI;
>   Request_Line   = Method %create_req SP Request_URI %set_req_uri SP
> SIP_Version CRLF;
>   Request        = Request_Line (message_header)* CRLF;
>
> main := Request;
> }%%
>
> %% write data;
> --cut--
>
> I think that problems is somewhere around this line:
>
> hier_part      = ((net_path | abs_path) ("?" query >mark %uri_query)?);
>
> if I remove the ">mark %uri_query" part, ragel is able to complete the
> operation.
> Can anyone give me some clues what's gone bad?
>
> tia,
> d
>
>
> >



From dam... at gmail.com  Sun Jan 21 13:58:32 2007
From: dam... at gmail.com (Damir Nedzibovic)
Date: Sun, 21 Jan 2007 13:58:32 -0000
Subject: ragel and memory usage
In-Reply-To: <1157.66.102.72.164.1169359215.squirrel@mambo.cs.queensu.ca>
References: <1169329253.204791.3690@38g2000cwa.googlegroups.com>
   <1157.66.102.72.164.1169359215.squirrel@mambo.cs.queensu.ca>
Message-ID: <1169387912.529683.254540@51g2000cwl.googlegroups.com>

Hi Adrian,

thanks for your help - I managed to isolate the ambiguity in my grammar
and even to refine it a bit. It works much better now.

Once I finish the complete grammar I'll post it here, maybe somebody
else will find it useful

thanks,
d

On Jan 21, 7:00 am, "Adrian Thurston" <thurs... at cs.queensu.ca> wrote:
> Hi, sorry I didn't notice the message text at the bottom. I'll have a look
> at it to find out why it fails when adding the actions mentioned.
>
> -Adrian
>
> > Hi all,
>
> > I'm trying to build a grammar for parsing SIP messages (as in rfc3261),
> > but I have encountered a problem that I cannot solve - it seems that
> > I've hit a state explosion, since ragel just keeps allocating memory
> > and finally dies.
>
> > Here's my grammar (sorry for pasting it here like this)
>
> > --cut--
> > %%{
> >   machine sip_parser;
>
> >   action mark
> >   {
> >   }
>
> >   action req_i
> >   {
> >   }
>
> >   action req_a
> >   {
> >   }
>
> >   action req_o
> >   {
> >   }
>
> >   action req_b
> >   {
> >   }
>
> >   action req_c
> >   {
> >   }
>
> >   action req_r
> >   {
> >   }
>
> >   action create_req
> >   {
> >   }
>
> >   action request_method
> >   {
> >   }
>
> >   action uri_host
> >   {
> >   }
>
> >   action done
> >   {
> >     fbreak;
> >   }
>
> >   action uri_port
> >   {
> >   }
>
> >   action uri_pass
> >   {
> >   }
>
> >   action uri_user
> >   {
> >   }
>
> >   action uri_scheme
> >   {
> >   }
>
> >   action set_req_uri
> >   {
> >   }
>
> >   action add_param
> >   {
> >   }
>
> >   action add_param_value
> >   {
> >   }
>
> >   action uri_query
> >   {
> >   }
>
> > #### SIP PROTOCOL GRAMMAR
>
> >   CRLF = "\r\n";
> >   SP = " ";
> >   HTAB = "\t";
> >   DQUOTE = "\"";
> >   LHEX = digit | [a-f];
>
> >   alphanum = [a-zA-Z0-9];
> >   reserved = (";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" | "$" |
> > ",");
> >   mark = ("-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")");
> >   unreserved = (alphanum | mark);
> >   escaped = ("%" xdigit xdigit);
>
> >   LWS = ((" "* CRLF)? " "+);
> >   SWS = (LWS?);
>
> >   HCOLON = ((" " | "\t")* ":" SWS);
>
> >   token = (alphanum | "-" | "." | "!" | "%" | "*" | "_" | "+" | "`" |
> > "'" | "~" )+;
> >   separators = ("(" | ")" | "<" | ">" | "@" | "," | ";" | ":" | "\\" |
> > DQUOTE | "/" | "[" | "]" | "?" | "=" | "{" | "}" | SP | HTAB);
> >   word = (alphanum | "-" | "." | "!" | "%" | "*" | "_" | "+" | "`" |
> > "'" | "~" | "(" | ")" | "<" | ">" | ":" | "\\" | DQUOTE | "/" | "[" |
> > "]" | "?" | "{" | "}")+;
>
> >   STAR   = (SWS "*" SWS);
> >   SLASH  = (SWS "/" SWS);
> >   EQUAL  = (SWS "=" SWS);
> >   LPAREN = (SWS "(" SWS);
> >   RPAREN = (SWS ")" SWS);
> >   RAQUOT = (">" SWS);
> >   LAQUOT = (SWS "<");
> >   COMMA  = (SWS "," SWS);
> >   SEMI   = (SWS ";" SWS);
> >   COLON  = (SWS ":" SWS);
> >   LDQUOT = (SWS DQUOTE);
> >   RDQUOT = (DQUOTE SWS);
>
> >   qdtext = (LWS | 0x21 | 0x23..0x5B | 0x5D..0x7E);
> >   quoted_pair = ("\\" (0x00..0x09 | 0x0B..0x0C | 0x0E..0x7F));
> >   quoted_string = (SWS DQUOTE (qdtext | quoted_pair)* DQUOTE);
> >   ctext    = (0x21..27 | 0x2A..0x5B | 0x5D..0x7E | LWS);
> >   comment_r = (LPAREN? (ctext | quoted_pair) RPAREN?);
> >   comment  = (LPAREN (comment_r)* RPAREN);
>
> >   port = digit+;
> >   IPv4address =  (digit{1,3} "." digit{1,3} "." digit{1,3} "."
> > digit{1,3});
> >   toplabel = (alpha | (alpha (alphanum | "-")* alphanum));
> >   domainlabel = (alphanum | (alphanum (alphanum | "-")* alphanum));
> >   hostname = ((domainlabel ".")* toplabel "."?);
> >   host = (hostname | IPv4address);
> >   hostport = (host >mark %uri_host (":" port >mark %uri_port)?);
> >   password = ((unreserved | escaped | "&" | "=" | "+" | "$" | "," )*);
> >   user_unreserved = ("&" | "=" | "+" | "$" | "," | ";" | "?" | "/");
> >   user = ((unreserved | escaped | user_unreserved)+);
> >   userinfo = (user >mark %uri_user (":" password >mark %uri_pass)?
> > "@");
>
> >   extension_method = token;
> >   Method = (("INVITE" %req_i | "ACK" %req_a | "OPTIONS" %req_o | "BYE"
> > %req_b | "CANCEL" %req_c | "REGISTER" %req_r | extension_method)) >mark
> > %request_method;
>
> >   hnv_unreserved = ("[" | "]" | "|" | "?" | ":" | "+" | "$");
> >   hvalue = ((hnv_unreserved | unreserved | escaped)*);
> >   hname = ((hnv_unreserved | unreserved | escaped)+);
> >   header = (hname "=" hvalue);
> >   headers = ("?" header ("&" header)*);
> >   param_unreserved = ("[" | "]" | "/" | ":" | "&" | "+" | "$");
> >   paramchar = (param_unreserved | unreserved | escaped);
> >   pvalue = (paramchar+);
> >   pname = (paramchar+);
> >   other_param = (pname >mark %add_param ("=" pvalue >mark
> > %add_param_value)?);
> >   lr_param = "lr" >mark %add_param;
> >   maddr_param = "maddr" >mark %add_param "=" host >mark
> > %add_param_value;
> >   method_param = "method" >mark %add_param "=" Method >mark
> > %add_param_value;
> >   ttl = (digit{1,3});
> >   ttl_param = "ttl" >mark %add_param "=" ttl >mark %add_param_value;
> >   other_user = token;
> >   user_param = "user" >mark %add_param "=" ("phone" | "ip" |
> > other_user) >mark %add_param_value;
> >   other_transport = token;
> >   transport_param = ("transport" >mark %add_param "=" ("udp" | "tcp" |
> > "sctp" | "tls" | other_transport) >mark %add_param_value);
> >   uri_parameter = (transport_param | user_param | method_param |
> > ttl_param | maddr_param | lr_param | other_param);
> >   uri_parameters = ((";" uri_parameter)*);
> >   SIP_URI = ("sip:" %{ m_data->m_uri.scheme() = "sip"; } (userinfo)?
> > hostport uri_parameters (headers)?);
> >   SIPS_URI = ("sips:" %{ m_data->m_uri.scheme() = "sips"; } (userinfo)?
> > hostport uri_parameters (headers)?);
>
> >   x_token = ("x-" token);
> >   ietf_token = token;
> >   extension_token = (ietf_token | x_token);
> >   composite_type = ("message" | "multipart" | extension_token);
> >   discrete_type = ("text" | "image" | "audio" | "video" | "application"
> > | extension_token);
> >   m_type = (discrete_type | composite_type);
>
> >   m_value = (token | quoted_string);
> >   m_attribute = token;
> >   m_parameter = (m_attribute EQUAL m_value);
> >   iana_token = token;
> >   m_subtype = (extension_token | iana_token);
>
> >   uric           = (reserved | unreserved | escaped);
> >   query          = (uric*);
> >   reg_name       = (unreserved | escaped | "$" | "," | ";" | ":" | "@"
> > | "&" | "=" | "+" )+;
> >   srvr           = ((userinfo "@")? hostport)?;
> >   authority      = (srvr | reg_name);
> >   scheme         = (alpha (alpha | digit | "+" | "-" | "." )*);
> >   pchar          = (unreserved | escaped | ":" | "@" | "&" | "=" | "+"
> > | "$" | ",");
> >   param          = (pchar*);
> >   segment        = (pchar* (";" param)*);
> >   path_segments  = (segment ("/" segment)*);
> >   uric_no_slash  = (unreserved | escaped | ";" | "?" | ":" | "@" | "&"
> > | "=" | "+" | "$" | ",");
> >   opaque_part    = (uric_no_slash uric*);
> >   abs_path       = ("/" path_segments);
> >   net_path       = ("//" authority (abs_path)?);
> >   hier_part      = ((net_path | abs_path) ("?" query >mark
> > %uri_query)?);
> >   absoluteURI    = (scheme >mark %uri_scheme ":" (hier_part |
> > opaque_part));
>
> >   gen_value = (token | host | quoted_string);
> >   generic_param = (token (EQUAL gen_value)?);
> >   qvalue = (("0" ("." digit{,3})?) | ("1" ("." ("0"){,3})?));
> >   accept_param = (("q" EQUAL qvalue) | generic_param);
> >   media_range = (("*" "/" "*" | ( m_type SLASH "*" ) | ( m_type SLASH
> > m_subtype )) (SEMI m_parameter)*);
> >   accept_range = (media_range (SEMI accept_param)*);
> >   Accept = ("Accept" HCOLON (accept_range (COMMA accept_range)*))?;
>
> >   content_coding   = (token);
> >   codings          = (content_coding | "*");
> >   encoding         = (codings (SEMI accept_param)*);
> >   Accept_Encoding  = ("Accept-Encoding" HCOLON (encoding (COMMA
> > encoding)*)?);
>
> >   language_range   = (((alpha{1,8} ("-" alpha{1,8})*) | "*" ));
> >   language         = (language_range (SEMI accept_param)*);
> >   Accept_Language  = ("Accept-Language" HCOLON (language (COMMA
> > language)*)?);
>
> >   alert_param      = (LAQUOT absoluteURI RAQUOT (SEMI generic_param
> > )*);
> >   Alert_Info       = ("Alert-Info" HCOLON alert_param (COMMA
> > alert_param)*);
>
> >   Allow            = ("Allow" HCOLON (Method (COMMA Method)*)?);
>
> >   opaque           = ("opaque" EQUAL quoted_string);
> >   algorithm        = ("algorithm" EQUAL ("MD5" | "MD5-sess" | token));
> >   realm_value      = (quoted_string);
> >   realm            = ("realm" EQUAL realm_value);
> >   auth_scheme      = (token);
> >   auth_param_name  = (token);
> >   auth_param       = (auth_param_name EQUAL (token | quoted_string));
> >   other_response   = (auth_scheme LWS auth_param (COMMA auth_param)*);
> >   request_digest   = (LDQUOT LHEX{32} RDQUOT);
> >   dresponse        = ("response" EQUAL request_digest);
> >   nonce_value      = (quoted_string);
> >   nonce            = ("nonce" EQUAL nonce_value);
> >   nc_value         = (LHEX{8});
> >   nonce_count      = ("nc" EQUAL nc_value);
> >   cnonce_value     = (nonce_value);
> >   cnonce           = ("cnonce" EQUAL cnonce_value);
> >   qop_value        = ("auth" | "auth-int" | token);
> >   message_qop      = ("qop" EQUAL qop_value);
> >   digest_uri_value = (absoluteURI); # fixme
> >   digest_uri       = ("uri" EQUAL LDQUOT digest_uri_value RDQUOT);
> >   username_value   = (quoted_string);
> >   username         = ("username" EQUAL username_value);
> >   dig_resp         = (username | realm | nonce | digest_uri | dresponse
> > | algorithm | cnonce | opaque | message_qop | nonce_count |
> > auth_param);
> >   digest_response  = (dig_resp (COMMA dig_resp)*);
> >   credentials      = (("Digest" LWS digest_response) | other_response);
> >   Authorization    = ("Authorization" HCOLON credentials);
>
> >   response_digest      = (LDQUOT LHEX* RDQUOT);
> >   response_auth        = ("rspauth" EQUAL response_digest);
> >   nextnonce            = ("nextnonce" EQUAL nonce_value);
> >   ainfo                = (nextnonce | message_qop | response_auth |
> > cnonce | nonce_count);
> >   Authentication_Info  = ("Authentication-Info" HCOLON ainfo (COMMA
> > ainfo)*);
>
> >   callid   =  (word ("@" word)?);
> >   Call_ID  = (( "Call-ID" | "i" ) HCOLON callid);
>
> >   info_param  = (("purpose" EQUAL ("icon" | "info" | "card" | token)) |
> > generic_param);
> >   info        = (LAQUOT absoluteURI RAQUOT (SEMI info_param)*);
> >   Call_Info   = ("Call-Info" HCOLON info (COMMA info)*);
>
> >   delta_seconds      = (digit+);
> >   contact_extension  = (generic_param);
> >   c_p_expires    = ("expires" EQUAL delta_seconds);
> >   c_p_q          = ("q" EQUAL qvalue);
> >   contact_params = (c_p_q | c_p_expires);
> >   display_name   = ((token LWS)* | quoted_string);
> >   addr_spec    ...
> 
> read more »


From thurs... at cs.queensu.ca  Mon Jan 22 04:53:40 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Sun, 21 Jan 2007 23:53:40 -0500 (EST)
Subject: [ragel-users] Re: ragel and memory usage
In-Reply-To: <1169387912.529683.254540@51g2000cwl.googlegroups.com>
References: <1169329253.204791.3690@38g2000cwa.googlegroups.com>
    <1157.66.102.72.164.1169359215.squirrel@mambo.cs.queensu.ca>
    <1169387912.529683.254540@51g2000cwl.googlegroups.com>
Message-ID: <3279.66.102.72.38.1169441620.squirrel@mambo.cs.queensu.ca>


> Once I finish the complete grammar I'll post it here, maybe somebody
> else will find it useful

That would be great! I heard from at least one other person using Ragel
for parsing SIP. Also, it would be a good grammar for profiling Ragel.

Cheers,
 Adrian


From dam... at gmail.com  Mon Jan 22 14:03:02 2007
From: dam... at gmail.com (Damir Nedzibovic)
Date: Mon, 22 Jan 2007 14:03:02 -0000
Subject: ragel and memory usage
In-Reply-To: <3279.66.102.72.38.1169441620.squirrel@mambo.cs.queensu.ca>
References: <1169329253.204791.3690@38g2000cwa.googlegroups.com>
   <1157.66.102.72.164.1169359215.squirrel@mambo.cs.queensu.ca>
   <1169387912.529683.254540@51g2000cwl.googlegroups.com>
   <3279.66.102.72.38.1169441620.squirrel@mambo.cs.queensu.ca>
Message-ID: <1169474582.584908.99340@l53g2000cwa.googlegroups.com>

Hi Adrian,

it seems that I wasn't able to remove the ambiguity after all :-(

I managed to further isolate the problem, I think:

if I replace this line

contact_param  = ((name_addr | addr_spec) (SEMI contact_params)*);

with

contact_param  = ((name_addr ) (SEMI contact_params)*);

the problem goes away, and ragel is able to complete the task.

I'm pretty much clues at this point...

thanks,
d


From thurs... at cs.queensu.ca  Mon Jan 22 16:45:26 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Mon, 22 Jan 2007 11:45:26 -0500
Subject: [ragel-users] Re: ragel and memory usage
In-Reply-To: <1169474582.584908.99340@l53g2000cwa.googlegroups.com>
References: <1169329253.204791.3690@38g2000cwa.googlegroups.com> <1157.66.102.72.164.1169359215.squirrel@mambo.cs.queensu.ca> <1169387912.529683.254540@51g2000cwl.googlegroups.com> <3279.66.102.72.38.1169441620.squirrel@mambo.cs.queensu.ca> <1169474582.584908.99340@l53g2000cwa.googlegroups.com>
Message-ID: <45B4EA26.1000803@cs.queensu.ca>

Hi Damir,

If you run

ragel -M contact_param -s memory.rl >memory.xml

And then look at the XML file you'll see that there are several final states
with transitions on ',' (44) in them. They seem to come from URIs. This is a
problem for making a comma-separated list of contact_param. You need to
exclude the comma if you want to make an unambiguous list.

Contact = (("Contact" | "m" ) HCOLON
    (STAR | (contact_param (COMMA contact_param)*)));

You should probably see what the RFC has to say, but if you want a quick fix
you can resolve the ambiguity explicitly using priorities. This resolution
favours the the COMMA which separates items.

COMMA_pri = (SWS "," @(contact_COMMA, 1) SWS);
contact_param_pri = contact_param $(contact_COMMA, 0);

Contact = ( ( "Contact" | "m" ) HCOLON (STAR |
    (contact_param_pri (COMMA_pri contact_param_pri)*)));

You can also resolve the ambiguity by making a new version of contact_param
that does not have any commas. This can be done with "strong subtraction"
(see the manual).

contact_param_nocomma = contact_param -- ",";

To get a feel for what is going on here play around with a mini-version of
your parser and look at the graphviz output.

action in {}
action all {}
action out {}

sym = "+" | "-" | ",";
word = ( [a-z] | sym )+ >in $all %out;

WS = ' ';
COMMA = WS* "," @1 WS*;

word_lowpri = word $(COMMA,0);
word_nocomma = word -- ',';

main := ':' word_nocomma (COMMA word_nocomma)*;

Cheers,
 Adrian

Damir Nedzibovic wrote:
> Hi Adrian,
> 
> it seems that I wasn't able to remove the ambiguity after all :-(
> 
> I managed to further isolate the problem, I think:
> 
> if I replace this line
> 
> contact_param  = ((name_addr | addr_spec) (SEMI contact_params)*);
> 
> with
> 
> contact_param  = ((name_addr ) (SEMI contact_params)*);
> 
> the problem goes away, and ragel is able to complete the task.
> 
> I'm pretty much clues at this point...
> 
> thanks,
> d
> 
> 
> 


From thurs... at cs.queensu.ca  Tue Jan 23 05:15:09 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Tue, 23 Jan 2007 00:15:09 -0500
Subject: need help testing
Message-ID: <45B599DD.1010202@cs.queensu.ca>

Hi, the holdup over the rewrite of the parsers is almost over. But 
before I do a release ... I've changed a lot of code and there is a 
pretty good chance I broke something that I don't know about. In fact 
I'm sure of it. So I'm asking for some help testing.

Here's how (it's easy).

1. Grab the latest from

http://www.cs.queensu.ca/~thurston/ragel/ragel-20070122.tar.gz
or
svn://mambo.cs.queensu.ca/ragel/trunk/ (requires ragel and kelbt)

2. Run it on your .rl files.

3. Diff the output against the old output of ragel.

4. Tell me if anything is different.
Note some minor whitespace changes are expected.

Thanks!

Adrian


From astra... at gmail.com  Tue Jan 23 21:38:25 2007
From: astra... at gmail.com (Alexander Strange)
Date: Tue, 23 Jan 2007 13:38:25 -0800
Subject: Reproducable crash
Message-ID: <1169588305.955977.317210@k78g2000cwa.googlegroups.com>

The attached file causes "ragel" (not rlcodegen) to bus error.

Program received signal EXC_BAD_ACCESS, Could not access memory.
Reason: KERN_PROTECTION_FAILURE at address: 0x00000064
0x0002e355 in STable<SBstMapEl<int, Action*> >::length (this=0x64) at
../aapl/table.h:152
152                     { return data == 0 ? 0 : (((STabHead*)data) -
1)->tabLen; }
(gdb) bt
#0  0x0002e355 in STable<SBstMapEl<int, Action*> >::length (this=0x64)
at ../aapl/table.h:152
#1  0x00022432 in FsmAp::hasOutData (this=0x60a8c0, state=0x0) at
fsmap.cpp:790
#2  0x00020796 in FsmAp::mergeStatesLeaving (this=0x60a8c0,
md=@0xbfffeda4, destState=0x0, srcState=0x610af0) at fsmgraph.cpp:1178
#3  0x00021b7c in FsmAp::starOp (this=0x60a8c0) at fsmgraph.cpp:228
#4  0x000119f9 in FactorWithRep::walk (this=0x609c50, pd=0x600460) at
parsetree.cpp:1356
#5  0x00012316 in FactorWithAug::walk (this=0x609c80, pd=0x600460) at
parsetree.cpp:1109
#6  0x00012af9 in Term::walk (this=0x609cd0, pd=0x600460,
lastInSeq=true) at parsetree.cpp:845
#7  0x00012d5e in Expression::walk (this=0x609cf0, pd=0x600460,
lastInSeq=true) at parsetree.cpp:687
#8  0x00012f98 in Join::walk (this=0x609d10, pd=0x600460) at
parsetree.cpp:502
#9  0x000112b4 in JoinOrLm::walk (this=0x609d30, pd=0x600460) at
parsetree.cpp:446
#10 0x00011329 in VarDef::walk (this=0x609d70, pd=0x600460) at
parsetree.cpp:44
#11 0x00017cbb in ParseData::makeInstance (this=0x600460,
gdNode=0x609d40) at parsedata.cpp:1025
#12 0x00017ef6 in ParseData::makeAll (this=0x600460) at
parsedata.cpp:1141
#13 0x000180a1 in ParseData::prepareMachineGen (this=0x600460,
graphDictEl=0x0) at parsedata.cpp:1302
#14 0x00018184 in writeMachines (out=@0xa0b0a920, hostData=@0xbffff284,
inputFileName=0xbffff41c "SSATagParsing.m.rl") at parsedata.cpp:1368
#15 0x0000c66b in main (argc=2, argv=0xbffff300) at main.cpp:372

The error can be worked around by removing "crasher" from the "tag"
machine.

(The intent of this was to be able to match any text inside a special
tag as valid, so my added actions would clean tags out of the text even
if I hadn't implemented all the commands inside them.)

Some other issues I've noticed writing this (a parser for text style
annotations in a subtitle format):

1. I get a warning:
SSATagParsing.m.rl:200:28: warning: applying plus operator to a machine
that accpets zero length word

This is obviously misspelled. Besides that, is there a way to avoid
this? I really am scanning any text that may have optional special
codes in it at random places, and empty text is perfectly fine by me.

2. According to the graph, once inside the "tag" machine, it generates
transitions to reenter that state upon reading '{', or to enter the nl
machine upon '\'. tag and nl should be exclusive, according to:

				tag = "{" cmd* "}";

				nl = "\\" [Nn];

				special = nl % nl_handler |
						 (tag > enter_tag % exit_tag);

and it shouldn't be looking for either of those until it's met a '}'.
Am I wrong?

Finally, just as a feature request, the things I'm using actions for
some of the time seem too obvious. I use several just to save the
current buffer position, since all the ending actions get is a pointer
past the end of what they want to read, and one to reimplement strtod.
I don't want to use the full tokenizing machinery since I have the
entire buffer available at once, but I would like beginning positions
of machines.


From thurs... at cs.queensu.ca  Wed Jan 24 00:00:16 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Tue, 23 Jan 2007 19:00:16 -0500
Subject: [ragel-users] Reproducable crash
In-Reply-To: <1169588305.955977.317210@k78g2000cwa.googlegroups.com>
References: <1169588305.955977.317210@k78g2000cwa.googlegroups.com>
Message-ID: <45B6A190.70605@cs.queensu.ca>

Hi Alex, it appears that the attachment didn't make it. Could you resend?

> This is obviously misspelled. Besides that, is there a way to avoid
> this? I really am scanning any text that may have optional special
> codes in it at random places, and empty text is perfectly fine by me.

It's not normally necessary to have the empty case in something that's
repeated. In theory it creates an infinite loop. If ragel actions strictly
adhered to the rules of automata theory then action foo would be executed an
infinite number of times in between each "bar". But ragel can only
approximate this behaviour, and the approximation is a little wonky in the
case of repeating the empty word.

main := ( "" %foo | "bar" )+ '\n';

If you look at the graphviz drawing of the above you'll see that on the
first and second 'b' foo is executed once, on all subsequent b's it is not
executed. This is inconsistent at best, so ragel yields a warning. A better
implementation isn't really worth it because you can usually just factor the
empty case out of a repetition.

> I don't want to use the full tokenizing machinery since I have the
> entire buffer available at once, but I would like beginning positions
> of machines.

While providing pointers to machines would be useful, here are my reasons
for opting not to.

Ragel is often used to parse text that arrives in blocks. When pointers get
invalidated by moving to the next block, something needs to be done. There
are many options for dealing with this and they depend on how input arrives.
Rather than make any assumptions I feel it is better to leave it up to the
user. At least in Ragel that is. I think auto-pointers is something that
could be done in a higher-level type of program. This is something I intend
to work on in the future (in the broader context of source transformation
systems).

Also, since it would be wasteful to automatically save pointers for every
named machine, the machines for which pointers are saved would need to be
explicitly declared. They can't be extracted from the host language because
the host language is not parsed. I think doing >{ptr = p;} is not much more
typing than a declaration :)

Regards,
 Adrian



From astra... at gmail.com  Wed Jan 24 00:51:46 2007
From: astra... at gmail.com (Alexander Strange)
Date: Tue, 23 Jan 2007 16:51:46 -0800
Subject: Reproducable crash
In-Reply-To: <45B6A190.70605@cs.queensu.ca>
References: <1169588305.955977.317210@k78g2000cwa.googlegroups.com>
   <45B6A190.70605@cs.queensu.ca>
Message-ID: <1169599906.519853.160970@m58g2000cwm.googlegroups.com>



On Jan 23, 7:00 pm, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
> Hi Alex, it appears that the attachment didn't make it. Could you resend?

Oh, sorry, I forgot to add it.

Actually, it doesn't look like the Google post field lets you attach
files, so here's a URL:
http://astrange.ithinksw.net/tools/SSATagParsing.m.rl

> Also, since it would be wasteful to automatically save pointers for every
> named machine, the machines for which pointers are saved would need to be
> explicitly declared. They can't be extracted from the host language because
> the host language is not parsed. I think doing >{ptr = p;} is not much more
> typing than a declaration :)

I see your point; the manual method certainly works for me now.

> Regards,
>  Adrian


From thurs... at cs.queensu.ca  Wed Jan 24 01:27:17 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Tue, 23 Jan 2007 20:27:17 -0500
Subject: [ragel-users] Re: Reproducable crash
In-Reply-To: <1169599906.519853.160970@m58g2000cwm.googlegroups.com>
References: <1169588305.955977.317210@k78g2000cwa.googlegroups.com> <45B6A190.70605@cs.queensu.ca> <1169599906.519853.160970@m58g2000cwm.googlegroups.com>
Message-ID: <45B6B5F5.9080007@cs.queensu.ca>

I can't seem to reproduce the crash. I think it might be architecture 
dependent. Are you running on a Mac? Bus errors in Ragel seem to crop up 
only on Macs.

crasher = any*;
tag = "{" cmd* crasher "}";

This is heavily ambiguous. The any* will never end. Also the any* of the 
text machine will never end. What happens when you change it to 
something unambiguous?

crasher = [^}]*;
text = [^\\{]*;

Regards,
  Adrian

Alexander Strange wrote:
> 
> 
> On Jan 23, 7:00 pm, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
>> Hi Alex, it appears that the attachment didn't make it. Could you resend?
> 
> Oh, sorry, I forgot to add it.
> 
> Actually, it doesn't look like the Google post field lets you attach
> files, so here's a URL:
> http://astrange.ithinksw.net/tools/SSATagParsing.m.rl
> 
>> Also, since it would be wasteful to automatically save pointers for every
>> named machine, the machines for which pointers are saved would need to be
>> explicitly declared. They can't be extracted from the host language because
>> the host language is not parsed. I think doing >{ptr = p;} is not much more
>> typing than a declaration :)
> 
> I see your point; the manual method certainly works for me now.
> 
>> Regards,
>>  Adrian
> 
> 
> 


From astra... at gmail.com  Wed Jan 24 02:58:36 2007
From: astra... at gmail.com (Alexander Strange)
Date: Tue, 23 Jan 2007 18:58:36 -0800
Subject: Reproducable crash
In-Reply-To: <45B6B5F5.9080007@cs.queensu.ca>
References: <1169588305.955977.317210@k78g2000cwa.googlegroups.com>
   <45B6A190.70605@cs.queensu.ca>
   <1169599906.519853.160970@m58g2000cwm.googlegroups.com>
   <45B6B5F5.9080007@cs.queensu.ca>
Message-ID: <1169607516.432704.179790@j27g2000cwj.googlegroups.com>



On Jan 23, 8:27 pm, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
> I can't seem to reproduce the crash. I think it might be architecture
> dependent. Are you running on a Mac? Bus errors in Ragel seem to crop up
> only on Macs.

Yes (10.4.8 i386), which means I don't have access to valgrind. I might
try to debug it later myself if you can't reproduce it, though.

> crasher = any*;
> tag = "{" cmd* crasher "}";
>
> This is heavily ambiguous. The any* will never end. Also the any* of the
> text machine will never end. What happens when you change it to
> something unambiguous?
>
> crasher = [^}]*;
> text = [^\\{]*;

text is actually supposed to be ambiguous; the people who made this
file format didn't think about parsing simplicity when they did it :(

I can certainly give that up for now, though.

With the current file, those two lines work. Changing either of them to
any* crashes. Using them and -m or -n crashes.

There are a few more situations, but since the presence of crasher was
causing cmd to do unintentional things (call the num and fsize exit
actions on every digit of "{\fs40.12}" instead of only at the end) I've
removed it anyway.

So, it looks like all is well. I'll report back if I have any useful
patches.

> Regards,
>   Adrian


From thurs... at cs.queensu.ca  Wed Jan 24 04:32:27 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Tue, 23 Jan 2007 23:32:27 -0500
Subject: [ragel-users] Reproducable crash
In-Reply-To: <1169588305.955977.317210@k78g2000cwa.googlegroups.com>
References: <1169588305.955977.317210@k78g2000cwa.googlegroups.com>
Message-ID: <45B6E15B.7030402@cs.queensu.ca>

The second argument (destState) of mergeStatesLeaving should never be 
null. Somehow a null value has gotten into the final state set of the 
machine starOp is applied to.

If you're willing to give me an account on your machine I can try to 
track it down remotely.

Adrian

Alexander Strange wrote:
> #2  0x00020796 in FsmAp::mergeStatesLeaving (this=0x60a8c0,
> md=@0xbfffeda4, destState=0x0, srcState=0x610af0) at fsmgraph.cpp:1178
> #3  0x00021b7c in FsmAp::starOp (this=0x60a8c0) at fsmgraph.cpp:228


From astra... at gmail.com  Wed Jan 24 18:45:27 2007
From: astra... at gmail.com (Alexander Strange)
Date: Wed, 24 Jan 2007 18:45:27 -0000
Subject: Reproducable crash
In-Reply-To: <45B6E15B.7030402@cs.queensu.ca>
References: <1169588305.955977.317210@k78g2000cwa.googlegroups.com>
   <45B6E15B.7030402@cs.queensu.ca>
Message-ID: <1169664327.253872.248100@k78g2000cwa.googlegroups.com>



On Jan 23, 11:32 pm, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
> The second argument (destState) of mergeStatesLeaving should never be
> null. Somehow a null value has gotten into the final state set of the
> machine starOp is applied to.
>
> If you're willing to give me an account on your machine I can try to
> track it down remotely.
>
> Adrian

I'm on a laptop behind a NAT, so no exporting shells for me. I did a
bit of poking but didn't get anywhere, will do some more later.

It doesn't break in FreeBSD, and valgrind reports nothing funny there
aside from a bit of memory leaked.
(http://astrange.ithinksw.net/valgrind.txt)

> Alexander Strange wrote:
> > #2  0x00020796 in FsmAp::mergeStatesLeaving (this=0x60a8c0,
> > md=@0xbfffeda4, destState=0x0, srcState=0x610af0) at fsmgraph.cpp:1178
> > #3  0x00021b7c in FsmAp::starOp (this=0x60a8c0) at fsmgraph.cpp:228


From thurs... at cs.queensu.ca  Sun Jan 28 05:44:35 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Sun, 28 Jan 2007 00:44:35 -0500
Subject: version 5.17
Message-ID: <45BC3843.1090503@cs.queensu.ca>

Hi all,

Version 5.17 has been released. This is the self-hosting release. Both 
the scanners and the parsers have been completely rewritten. For 
context-free parsing I use Kelbt, another project of mine.

This release has been tested, but I still believe that problems are 
likely to show up. A lot of code that hasn't been touched for a really 
long time is suddenly way different. Please post any problems you have 
to the mailing list.

Thanks,
  Adrian


From matt.mo... at gmail.com  Mon Jan  1 18:14:41 2007
From: matt.mo... at gmail.com (Matt Mower)
Date: Mon, 1 Jan 2007 18:14:41 +0000
Subject: Problematic machine specification
Message-ID: <d56373190701011014m7ffdbf62y9bae19e72ddd7b62@mail.gmail.com>

Hi folks.

I'm writing an app that needs to parse the output from svn diff
although not to any great degree of detail. For various reasons (blame
Zed!) I decided to use this as an opportunity to learn Ragel.

With a lot of help from Zed I have something that seems close but
isn't quite working. The problem section revolves around the contents
of a diff hunk. This looks something like:

@@ -205,3 +205,15 @@
 .hugeTag {
  font-size: 125%;
 }
+
+.asp_timestamp_col {
...

the first three lines after the line beginning @@... have a space
prefix (meaning a line common to both files), the next line has a '+'
prefix (meaning a new line). A hunk ends when you reach a line that
doesn't begin with " ", "+", or "-".

The problem is that the machine recognizes the first three lines of my
example (prefixed " ") but comes back with an error when it reaches
the first line prefixed "+". Looking at the diagram (diffBody.png
attached) for the diffBody machine it looks to me as if it should
correctly parse the example.

If anyone can help point out where I am going wrong that would be much
appreciated. I'm not sure if & how I can get it to log the state or
character being processed when the error was raised. That too would be
useful.

My application is being written in Objective-C. So far as I can tell
that doesn't significantly muddy the waters and the O-C bits seem to
be working.

Many thanks,

Matt

-- 
Matt Mower :: http://matt.blogs.it/
-------------- next part --------------
A non-text attachment was scrubbed...
Name: DiffParser.m.rl
Type: application/octet-stream
Size: 2098 bytes
Desc: not available
URL: <http://www.colm.net/pipermail/ragel-users/attachments/20070101/d7a8b028/attachment-0001.obj>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: diffBody.png
Type: image/png
Size: 101358 bytes
Desc: not available
URL: <http://www.colm.net/pipermail/ragel-users/attachments/20070101/d7a8b028/attachment-0001.png>

From thurs... at cs.queensu.ca  Mon Jan  1 21:57:14 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Mon, 01 Jan 2007 16:57:14 -0500
Subject: [ragel-users] Problematic machine specification
In-Reply-To: <d56373190701011014m7ffdbf62y9bae19e72ddd7b62@mail.gmail.com>
References: <d56373190701011014m7ffdbf62y9bae19e72ddd7b62@mail.gmail.com>
Message-ID: <459983BA.6080600@cs.queensu.ca>

Hi Matt,

I noticed a couple spots to fix. Since the line machine is given with 
the + operator it requires at least one character. Use * instead and 
empty lines (following +/- etc) will be accepted.

The 'print' builtin machine does not accept tabs, so any diff with tabs 
will fail.

When the machine hits an error it transitions into the error state and 
then breaks out of the loop from there. Look at p[-1] after the loop to 
see on what character the error occurred. Alternatively you can embed an 
error action and look at p[0] from within the action.

If you want to see the state that the error occurred in you'll need to 
embed an error action and look at fcurs (this is macro rewritten by ragel).

Cheers (and happy new year)

Adrian

Matt Mower wrote:
> Hi folks.
> 
> I'm writing an app that needs to parse the output from svn diff
> although not to any great degree of detail. For various reasons (blame
> Zed!) I decided to use this as an opportunity to learn Ragel.
> 
> With a lot of help from Zed I have something that seems close but
> isn't quite working. The problem section revolves around the contents
> of a diff hunk. This looks something like:
> 
> @@ -205,3 +205,15 @@
> .hugeTag {
>  font-size: 125%;
> }
> +
> +.asp_timestamp_col {
> ...
> 
> the first three lines after the line beginning @@... have a space
> prefix (meaning a line common to both files), the next line has a '+'
> prefix (meaning a new line). A hunk ends when you reach a line that
> doesn't begin with " ", "+", or "-".
> 
> The problem is that the machine recognizes the first three lines of my
> example (prefixed " ") but comes back with an error when it reaches
> the first line prefixed "+". Looking at the diagram (diffBody.png
> attached) for the diffBody machine it looks to me as if it should
> correctly parse the example.
> 
> If anyone can help point out where I am going wrong that would be much
> appreciated. I'm not sure if & how I can get it to log the state or
> character being processed when the error was raised. That too would be
> useful.
> 
> My application is being written in Objective-C. So far as I can tell
> that doesn't significantly muddy the waters and the O-C bits seem to
> be working.
> 
> Many thanks,
> 
> Matt
> 
> 
> ------------------------------------------------------------------------
> 


From matt.mo... at gmail.com  Tue Jan  2 13:04:58 2007
From: matt.mo... at gmail.com (Matt Mower)
Date: Tue, 2 Jan 2007 13:04:58 +0000
Subject: [ragel-users] Re: Problematic machine specification
In-Reply-To: <459983BA.6080600@cs.queensu.ca>
References: <d56373190701011014m7ffdbf62y9bae19e72ddd7b62@mail.gmail.com>
	 <459983BA.6080600@cs.queensu.ca>
Message-ID: <d56373190701020504g415c0372ye0689c8a65fa0710@mail.gmail.com>

Hi Adrian,

Thanks for your reply.

On 01/01/07, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
> I noticed a couple spots to fix. Since the line machine is given with
> the + operator it requires at least one character. Use * instead and
> empty lines (following +/- etc) will be accepted.
>

Yes, done that, thanks.

> The 'print' builtin machine does not accept tabs, so any diff with tabs
> will fail.
>

That was my major sin. I had just blindly internalized the assumption
that it would and this was throwing off the scanner. It became obvious
once I figured out to print *p when I detected the error state.

> When the machine hits an error it transitions into the error state and
> then breaks out of the loop from there. Look at p[-1] after the loop to
> see on what character the error occurred. Alternatively you can embed an
> error action and look at p[0] from within the action.
>
> If you want to see the state that the error occurred in you'll need to
> embed an error action and look at fcurs (this is macro rewritten by ragel).
>

That's very useful. Zed pointed me to the docs on error actions but I
wasn't able to take it in because I was grappling with everything else
as well. I'm figuring the actions out better now (making use of enter
as well as exit actions) so I'll go back over the guide now that I
have the basic scanner working.

Thanks again & Happy New Year to you too!

Regards,

Matt


From s... at mattmower.com  Wed Jan  3 01:16:32 2007
From: s... at mattmower.com (Matt Mower)
Date: Wed, 3 Jan 2007 01:16:32 +0000
Subject: Machine not running terminating actions
Message-ID: <d56373190701021716v3df6d8cdu6de1198597d95b8c@mail.gmail.com>

Hi again.

With your help I've been able to iron out many of the wrinkles in my
diff parser and have something approximating a good parse of arbitrary
svn diff output. One thing has me stumped though. The actions for the
last hunk of the last diff are not being fired.

Here is my machine:

### expressions

	lineChar = ( print | space ) - '\n';
	
	nbsp = space - '\n';
	
	line = ( ' ' | '-' | '+' ) @{ fhold; } lineChar* '\n'+ ;
	
	ignore_line = lineChar* '\n';

	ignoreCode = '\\' line;
	separator = '='+ '\n';
	hunkEndChar = print - ( space | '+' | '-' );
	
	oldFile = '---' ignore_line;
	newFile = '+++' ignore_line;
	
	hunkHeader = '@@' print+ '@@' '\n'+;
	
	hunkBody = ( line )+ ( ignoreCode | hunkEndChar @{ fhold; } );
	
	hunk = hunkHeader >enter_hunk hunkBody %exit_hunk;
	
	fileName = ( lineChar+ ) >mark %copy_to_filespec;
	
	fileSpec = "Index:" nbsp+ fileName '\n'+;
	
	diffHeader = ( fileSpec separator oldFile newFile );
	diffBody = hunk* %exit_diff;
	
	diff = diffHeader >enter_diff diffBody;
	
#	main := diff* $!error $~track;
#	main := diff* $!error;
	main := diff*;

It's the result of much tinkering to get the actions to fire in the
right sequence (I have a lot of problems with exit_diff actions firing
before corresponding exit_hunk's and so forth).

It correctly parses into each diff and each hunk within in. Where it
falls down, as I say, is that exit_hunk and exit_diff are not fired
for the last parsed hunk of the last diff.

I've attached a graph showing the diffBody machine as well as the full
.dot and the parser itself.

Any help would be much appreciated.

Thanks,

Matt

-- 
Matt Mower :: http://matt.blogs.it/
-------------- next part --------------
A non-text attachment was scrubbed...
Name: machine_26863.png
Type: image/png
Size: 116343 bytes
Desc: not available
URL: <http://www.colm.net/pipermail/ragel-users/attachments/20070103/199b98d9/attachment-0001.png>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: DiffParser.m.dot
Type: application/octet-stream
Size: 2531 bytes
Desc: not available
URL: <http://www.colm.net/pipermail/ragel-users/attachments/20070103/199b98d9/attachment-0002.obj>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: DiffParser.m.rl
Type: application/octet-stream
Size: 2884 bytes
Desc: not available
URL: <http://www.colm.net/pipermail/ragel-users/attachments/20070103/199b98d9/attachment-0003.obj>

From thurs... at cs.queensu.ca  Wed Jan  3 03:21:59 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Tue, 02 Jan 2007 22:21:59 -0500
Subject: [ragel-users] Machine not running terminating actions
In-Reply-To: <d56373190701021716v3df6d8cdu6de1198597d95b8c@mail.gmail.com>
References: <d56373190701021716v3df6d8cdu6de1198597d95b8c@mail.gmail.com>
Message-ID: <459B2157.4020900@cs.queensu.ca>

Hi Matt,

You're parser is coming along nicely :) Here are some more tips.

When it comes to ordering actions on the same character, just remember 
that there is an outer-inner ordering. It goes outer start actions, 
inner start actions, inner rest actions, outer rest actions. "rest" 
meaning finishing, leaving, and all actions. It seems that what you have 
now is right.

Leaving actions (%) only fire on character transitions. What is 
happening is that at the end of the input the machine is just exiting. 
There is no character to cause the action to get executed. If you embed 
an eof action (using %eof exit_diff) at the same places that you've 
specified the leaving actions (%exit_diff) and you write the eof switch 
(with %%write eof;) then they will fire.

Alternatively you can specify a termination character (perhaps 0) at the 
end of main and send it once the input is done. That will 'flush' the 
leaving actions.

You can try it out with something simple like the following. I find the 
smaller machines are easier to reason about and what you learn 
generalizes well.

%%{
	machine tmp;
	action e1 {}
	action e2 {}

	sub = ( 's' [^\n]* '\n' ) %e1 %eof e1;
	fun = ( 'f' sub* ) %e2 %eof e2;

	main := fun*;
}%%

I'm not sure what you intend with the following, maybe some explicitly 
specified lookahead? I would remove it though because I don't think it's 
necessary and it doesn't seem to be compatible with my advice above.

( ignoreCode | hunkEndChar @{ fhold; } );

In general, it's advisable to avoid fhold unless you're about to jump 
somewhere using fgoto or you're really sure of what you're doing. The 
problem is that if you union a machine that has an fhold in it with 
something else, the fhold will also apply to the something else when you 
probably don't want it to. It can make things really complicated.

Cheers,
  Adrian

Matt Mower wrote:
> Hi again.
> 
> With your help I've been able to iron out many of the wrinkles in my
> diff parser and have something approximating a good parse of arbitrary
> svn diff output. One thing has me stumped though. The actions for the
> last hunk of the last diff are not being fired.
> 
> Here is my machine:
> 
> ### expressions
> 
>     lineChar = ( print | space ) - '\n';
>     
>     nbsp = space - '\n';
>     
>     line = ( ' ' | '-' | '+' ) @{ fhold; } lineChar* '\n'+ ;
>     
>     ignore_line = lineChar* '\n';
> 
>     ignoreCode = '\\' line;
>     separator = '='+ '\n';
>     hunkEndChar = print - ( space | '+' | '-' );
>     
>     oldFile = '---' ignore_line;
>     newFile = '+++' ignore_line;
>     
>     hunkHeader = '@@' print+ '@@' '\n'+;
>     
>     hunkBody = ( line )+ ( ignoreCode | hunkEndChar @{ fhold; } );
>     
>     hunk = hunkHeader >enter_hunk hunkBody %exit_hunk;
>     
>     fileName = ( lineChar+ ) >mark %copy_to_filespec;
>     
>     fileSpec = "Index:" nbsp+ fileName '\n'+;
>     
>     diffHeader = ( fileSpec separator oldFile newFile );
>     diffBody = hunk* %exit_diff;
>     
>     diff = diffHeader >enter_diff diffBody;
>     
> #    main := diff* $!error $~track;
> #    main := diff* $!error;
>     main := diff*;
> 
> It's the result of much tinkering to get the actions to fire in the
> right sequence (I have a lot of problems with exit_diff actions firing
> before corresponding exit_hunk's and so forth).
> 
> It correctly parses into each diff and each hunk within in. Where it
> falls down, as I say, is that exit_hunk and exit_diff are not fired
> for the last parsed hunk of the last diff.
> 
> I've attached a graph showing the diffBody machine as well as the full
> .dot and the parser itself.
> 
> Any help would be much appreciated.
> 
> Thanks,
> 
> Matt
> 
> 
> ------------------------------------------------------------------------
> 


From s... at mattmower.com  Wed Jan  3 08:31:19 2007
From: s... at mattmower.com (Matt Mower)
Date: Wed, 3 Jan 2007 08:31:19 +0000
Subject: [ragel-users] Re: Machine not running terminating actions
In-Reply-To: <459B2157.4020900@cs.queensu.ca>
References: <d56373190701021716v3df6d8cdu6de1198597d95b8c@mail.gmail.com>
	 <459B2157.4020900@cs.queensu.ca>
Message-ID: <d56373190701030031u54ce1b44mb213fbd002292bb0@mail.gmail.com>

Hi Adrian,

On 03/01/07, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
> When it comes to ordering actions on the same character, just remember
> that there is an outer-inner ordering. It goes outer start actions,
> inner start actions, inner rest actions, outer rest actions. "rest"
> meaning finishing, leaving, and all actions. It seems that what you have
> now is right.
>

Cool. I think I'd figured that out intuitively but not on a conscious level.

> Leaving actions (%) only fire on character transitions. What is
> happening is that at the end of the input the machine is just exiting.

Ah.

> There is no character to cause the action to get executed. If you embed
> an eof action (using %eof exit_diff) at the same places that you've
> specified the leaving actions (%exit_diff) and you write the eof switch
> (with %%write eof;) then they will fire.
>

Zed prompted me to look at write eof, but I misread the guide and
didn't realise you had to embed specific EOF actions. I guess using
Ruby so much has lead me to expect magic everywhere ;-)

> You can try it out with something simple like the following. I find the
> smaller machines are easier to reason about and what you learn
> generalizes well.

Good point.

>         sub = ( 's' [^\n]* '\n' ) %e1 %eof e1;

%eof, isn't that another action the same as %e1?  When I looked
through the 5.16 guide about EOF actions it suggested I should use %/
(maybe %eof is alternative syntax? I couldn't find it when I
searched).

Anyway I tried:

hunk = hunkHeader >enter_hunk hunkBody %exit_hunk %/exit_hunk;
	
	fileName = ( lineChar+ ) >mark %copy_to_filespec;
	
	fileSpec = "Index:" nbsp+ fileName '\n'+;
	
	diffHeader = ( fileSpec separator oldFile newFile );
	diffBody = hunk* %exit_diff %/exit_diff;

and it worked first time out (since I already had the %% write eof, it
just wasn't doing anything!)

> ( ignoreCode | hunkEndChar @{ fhold; } );
>

I removed the lookahead as you suggested. I'll consume the \\ prefixed
comment inside 'line' from now on.

> In general, it's advisable to avoid fhold unless you're about to jump
> somewhere using fgoto or you're really sure of what you're doing. The

Yeah I think we can safely say I don't *quite* know what I'm doing
yet. But I do feel like I'm getting, slowly, to grips with it. I think
that part of my problem is that I'm not a visual thinker, I can't
imagine the resulting graph as I'm constructing the machine. I
probably need to be a bit less sloppy in my reasoning to compensate
;-)

So, this morning, I have:

[Session started at 2007-01-03 08:24:20 +0000.]
2007-01-03 08:24:20.716 Ragel2[1666] begin_diff
2007-01-03 08:24:20.716 Ragel2[1666]     filespec:
app/helpers/application_helper.rb
2007-01-03 08:24:20.716 Ragel2[1666]   begin_hunk
2007-01-03 08:24:20.716 Ragel2[1666]   end_hunk
2007-01-03 08:24:20.716 Ragel2[1666] end_diff
2007-01-03 08:24:20.716 Ragel2[1666] begin_diff
2007-01-03 08:24:20.716 Ragel2[1666]     filespec:
app/views/layouts/application.rhtml
2007-01-03 08:24:20.716 Ragel2[1666]   begin_hunk
2007-01-03 08:24:20.716 Ragel2[1666]   end_hunk
2007-01-03 08:24:20.716 Ragel2[1666] end_diff
2007-01-03 08:24:20.716 Ragel2[1666] begin_diff
2007-01-03 08:24:20.716 Ragel2[1666]     filespec: db/schema.rb
2007-01-03 08:24:20.716 Ragel2[1666]   begin_hunk
2007-01-03 08:24:20.716 Ragel2[1666]   end_hunk
2007-01-03 08:24:20.716 Ragel2[1666]   begin_hunk
2007-01-03 08:24:20.716 Ragel2[1666]   end_hunk
2007-01-03 08:24:20.717 Ragel2[1666]   begin_hunk
2007-01-03 08:24:20.717 Ragel2[1666]   end_hunk
2007-01-03 08:24:20.717 Ragel2[1666]   begin_hunk
2007-01-03 08:24:20.717 Ragel2[1666]   end_hunk
2007-01-03 08:24:20.717 Ragel2[1666] end_diff
2007-01-03 08:24:20.717 Ragel2[1666] Parser exit no errors

Thank you Adrian & Zed!

Regards,

Matt

-- 
Matt Mower :: http://matt.blogs.it/


From thurs... at cs.queensu.ca  Wed Jan  3 15:18:14 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Wed, 03 Jan 2007 10:18:14 -0500
Subject: [ragel-users] Re: Machine not running terminating actions
In-Reply-To: <d56373190701030031u54ce1b44mb213fbd002292bb0@mail.gmail.com>
References: <d56373190701021716v3df6d8cdu6de1198597d95b8c@mail.gmail.com> <459B2157.4020900@cs.queensu.ca> <d56373190701030031u54ce1b44mb213fbd002292bb0@mail.gmail.com>
Message-ID: <459BC936.1050103@cs.queensu.ca>

Matt Mower wrote:
> Zed prompted me to look at write eof, but I misread the guide and
> didn't realise you had to embed specific EOF actions. I guess using
> Ruby so much has lead me to expect magic everywhere ;-)

Ragel actually used to behave this way. The % operator would also embed 
EOF actions. But I found this to be problematic in a few scenarios 
because the EOF context is not the same as the regular action context 
(the p pointer is not alway available). So I ended up splitting them.

> %eof, isn't that another action the same as %e1?  When I looked
> through the 5.16 guide about EOF actions it suggested I should use %/
> (maybe %eof is alternative syntax? I couldn't find it when I
> searched).

The %eof syntax is an alternate syntax for the %/ operator. It's new. 
I'll add that to the guide ASAP.

Cheers,
  Adrian


From jason2... at jasonjobe.com  Wed Jan  3 20:01:07 2007
From: jason2... at jasonjobe.com (Jason)
Date: Wed, 03 Jan 2007 12:01:07 -0800
Subject: integrating ragel w/ bison
Message-ID: <1167854467.572809.228150@11g2000cwr.googlegroups.com>

I have a good bit of experience writing grammars using re2c and bison
but I really like the clarity of ragel and would like to use it as a
replacement for re2c.

Are there any examples (e.g. the quintessential calculator) using ragel
as the lexical frontend to bison?

thanks,
Jason


From thurs... at cs.queensu.ca  Wed Jan  3 20:36:28 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Wed, 03 Jan 2007 15:36:28 -0500
Subject: [ragel-users] integrating ragel w/ bison
In-Reply-To: <1167854467.572809.228150@11g2000cwr.googlegroups.com>
References: <1167854467.572809.228150@11g2000cwr.googlegroups.com>
Message-ID: <459C13CC.2040201@cs.queensu.ca>

Hi Jason, all the scanner examples I have use the push model. To write a
pull-based scanner you'll need to use the fbreak; statement to break out of
the processing loop. You can then return from the scanner function. You
can't use a C return statement in a scanner action because it will leave the
scanner in an inconsistent state. The fbreak statement does a little cleanup
first.

How does it work in re2c? Do you just give a C return from the pattern action?

For a long time I've been meaning to add a version of fbreak that cleans up
then issues a C return but I don't know what to call it because there
already is fret which returns from an fcall. I might just make it

fbreak_return value;

even though that's very long. But it could also be extended to include

fbreak_goto label;

to jump to somewhere else in your function. Do you think that's clear? I
wouldn't want these to be confused with fret and fgoto.

Regards,
 Adrian

Jason wrote:
> 
> I have a good bit of experience writing grammars using re2c and bison
> but I really like the clarity of ragel and would like to use it as a
> replacement for re2c.
> 
> Are there any examples (e.g. the quintessential calculator) using ragel
> as the lexical frontend to bison?
> 
> thanks,
> Jason
> 
> 
> 


From jason2... at jasonjobe.com  Wed Jan  3 21:27:17 2007
From: jason2... at jasonjobe.com (Jason)
Date: Wed, 03 Jan 2007 13:27:17 -0800
Subject: integrating ragel w/ bison
In-Reply-To: <459C13CC.2040201@cs.queensu.ca>
References: <1167854467.572809.228150@11g2000cwr.googlegroups.com>
   <459C13CC.2040201@cs.queensu.ca>
Message-ID: <1167859637.857914.142110@q40g2000cwq.googlegroups.com>

Adrian,

How about
  freturn value;
or
  fcreturn value; // for a 'C' return

>> How does it work in re2c? Do you just give a C return from the pattern action?
Yes. You create a struct that you pass to your re2c_lex call. Each call
returns the next token.

Would you just make repeated calls to the scanner? i.e. would the state
be such that it just picks up where you left off?

This sort of interface would certainly make yacc/bison much easier!

If you would like me test it out please let me know :-)

regards,
Jason


From thurs... at cs.queensu.ca  Thu Jan  4 00:47:11 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Wed, 03 Jan 2007 19:47:11 -0500
Subject: [ragel-users] Re: integrating ragel w/ bison
In-Reply-To: <1167859637.857914.142110@q40g2000cwq.googlegroups.com>
References: <1167854467.572809.228150@11g2000cwr.googlegroups.com> <459C13CC.2040201@cs.queensu.ca> <1167859637.857914.142110@q40g2000cwq.googlegroups.com>
Message-ID: <459C4E8F.4000600@cs.queensu.ca>


Jason wrote:
> Would you just make repeated calls to the scanner? i.e. would the state
> be such that it just picks up where you left off?

That's what I was thinking. I haven't tried this out, but you should be able
to do something like the following. Note that you need to manually get local
copies of p and pe because the access statement does not affect them.

void scan( Scanner *s )
{
	char *p = s->p;
	char *pe = s->pe;

	while ( true ) {
		if ( p == pe ) {
			check_for_preserve_condition();
			if ( ! fetch_more_data() )
				return EOF;
		}

		token = no_token;

		%%{
			machine Scanner;
			access s->;

			main := |*

			# Identifiers
			( [a-zA-Z_] [a-zA-Z0-9_]* ) =>
				{ token = Identifier; fbreak; };

			# Whitespace
			[ \t\n];

			# Anything else
			any => { token = *p; fbreak; };

			*|;

			write exec;
		}%%

		if ( token != no_token ) {
			s->p = p;
			s->pe = pe;
			return token;
		}

		if ( s->cs == Scanner_error )
			return ERR;
	}
}


From jason2... at jasonjobe.com  Thu Jan  4 18:21:54 2007
From: jason2... at jasonjobe.com (Jason)
Date: Thu, 04 Jan 2007 10:21:54 -0800
Subject: integrating ragel w/ bison
In-Reply-To: <459C4E8F.4000600@cs.queensu.ca>
References: <1167854467.572809.228150@11g2000cwr.googlegroups.com>
   <459C13CC.2040201@cs.queensu.ca>
   <1167859637.857914.142110@q40g2000cwq.googlegroups.com>
   <459C4E8F.4000600@cs.queensu.ca>
Message-ID: <1167934914.170228.44670@6g2000cwy.googlegroups.com>

Adrian,

I'm still not following your full intent but I did manage to get some
code (below) that builds and runs but produces no output.

Hopefully, you can help me fill in the blanks.

thanks,
Jason

----------------------------------- CUT HERE
-------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct _Scanner {
	int cs;
	int act;
	int have;
	int curline;
	char *tokstart;
	char *tokend;
	char *p;
	char *pe;
	int done;

	int value;
} Scanner;

#define ERR (-1000)

void scan_init( Scanner *s )
{
  memset (s, '\0', sizeof(Scanner));
  s->curline = 1;
}

int fetch_more_data ( Scanner *s ) {
	return 0;
}

void check_for_preserve_condition( Scanner *s ) {
}

int Scanner_error = -1;

#define Identifier 1
#define Number 2


int scan( Scanner *s )
{
        char *p = s->p;
        char *pe = s->pe;
	int token, no_token = '\0';

        while ( 1 ) {
                if ( p == pe ) {
                        check_for_preserve_condition(s);
                        if ( ! fetch_more_data(s) )
                                return EOF;
                }

                token = no_token;

                %%{
                        machine Scanner;
                        access s->;

                        main := |*

                        # Identifiers
                        ( [a-zA-Z_] [a-zA-Z0-9_]* ) =>
                                { token = Identifier; fbreak; };

                        # Whitespace
                        [ \t\n];

			# Number
                        digit+ => { token = Number; s->value = atoi(p);
fbreak; };

                        # Anything else
                        any => { token = *p; fbreak; };

                        *|;

                        write exec;
                }%%

                if ( token != no_token ) {
                        s->p = p;
                        s->pe = pe;
                        return token;
                }

                if ( s->cs == Scanner_error )
                        return ERR;
        }
}


int main (int argc, char** argv)
{
    Scanner ss;
    int tok;

    ss.pe = "2 * 3";
    scan_init (&ss);

    while (1) {
	tok = scan (&ss);
	if (tok == EOF || tok == ERR)
	  break;
	printf ("%d\n", tok);
    }

    return 0;
}


From thurs... at cs.queensu.ca  Fri Jan  5 03:41:16 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Thu, 04 Jan 2007 22:41:16 -0500
Subject: [ragel-users] Re: integrating ragel w/ bison
In-Reply-To: <1167934914.170228.44670@6g2000cwy.googlegroups.com>
References: <1167854467.572809.228150@11g2000cwr.googlegroups.com> <459C13CC.2040201@cs.queensu.ca> <1167859637.857914.142110@q40g2000cwq.googlegroups.com> <459C4E8F.4000600@cs.queensu.ca> <1167934914.170228.44670@6g2000cwy.googlegroups.com>
Message-ID: <459DC8DC.7090205@cs.queensu.ca>

Hi Jason,

I finished off the rest of the pull driver and added it to the examples 
directory. Be sure to let me know if you find any bugs. I did it fast.

Cheers,
  Adrian

Jason wrote:
> 
> Adrian,
> 
> I'm still not following your full intent but I did manage to get some
> code (below) that builds and runs but produces no output.
> 
> Hopefully, you can help me fill in the blanks.
> 
> thanks,
> Jason
> 
> ----------------------------------- CUT HERE
> -------------------------------------------------
> #include <stdio.h>
> #include <stdlib.h>
> #include <string.h>
> 
> typedef struct _Scanner {
>     int cs;
>     int act;
>     int have;
>     int curline;
>     char *tokstart;
>     char *tokend;
>     char *p;
>     char *pe;
>     int done;
> 
>     int value;
> } Scanner;
> 
> #define ERR (-1000)
> 
> void scan_init( Scanner *s )
> {
>  memset (s, '\0', sizeof(Scanner));
>  s->curline = 1;
> }
> 
> int fetch_more_data ( Scanner *s ) {
>     return 0;
> }
> 
> void check_for_preserve_condition( Scanner *s ) {
> }
> 
> int Scanner_error = -1;
> 
> #define Identifier 1
> #define Number 2
> 
> 
> int scan( Scanner *s )
> {
>        char *p = s->p;
>        char *pe = s->pe;
>     int token, no_token = '\0';
> 
>        while ( 1 ) {
>                if ( p == pe ) {
>                        check_for_preserve_condition(s);
>                        if ( ! fetch_more_data(s) )
>                                return EOF;
>                }
> 
>                token = no_token;
> 
>                %%{
>                        machine Scanner;
>                        access s->;
> 
>                        main := |*
> 
>                        # Identifiers
>                        ( [a-zA-Z_] [a-zA-Z0-9_]* ) =>
>                                { token = Identifier; fbreak; };
> 
>                        # Whitespace
>                        [ \t\n];
> 
>             # Number
>                        digit+ => { token = Number; s->value = atoi(p);
> fbreak; };
> 
>                        # Anything else
>                        any => { token = *p; fbreak; };
> 
>                        *|;
> 
>                        write exec;
>                }%%
> 
>                if ( token != no_token ) {
>                        s->p = p;
>                        s->pe = pe;
>                        return token;
>                }
> 
>                if ( s->cs == Scanner_error )
>                        return ERR;
>        }
> }
> 
> 
> int main (int argc, char** argv)
> {
>    Scanner ss;
>    int tok;
> 
>    ss.pe = "2 * 3";
>    scan_init (&ss);
> 
>    while (1) {
>     tok = scan (&ss);
>     if (tok == EOF || tok == ERR)
>       break;
>     printf ("%d\n", tok);
>    }
> 
>    return 0;
> }
> 
> 
> 
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: pullscan.rl
URL: <http://www.colm.net/pipermail/ragel-users/attachments/20070104/64beea16/attachment-0001.ksh>

From s... at mattmower.com  Mon Jan  8 21:01:34 2007
From: s... at mattmower.com (Matt Mower)
Date: Mon, 8 Jan 2007 21:01:34 +0000
Subject: Any chance of rlcodegen outputting pure-ruby
Message-ID: <d56373190701081301k304d4376w5f70940a489b4219@mail.gmail.com>

Hi,

I realise that wrapping the C code generated by Ragel into a Ruby
extension is a reasonably simple exercise but I really think it would
help with adoption if Ragel could directly generate Ruby source code.

Is there any likelyhood of that happening? Or does it need someone
from the Ruby side to pitch in? And how hard might that be?

Regards,

Matt

-- 
Matt Mower :: http://matt.blogs.it/


From thurs... at cs.queensu.ca  Tue Jan  9 04:06:20 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Mon, 08 Jan 2007 23:06:20 -0500
Subject: [ragel-users] Any chance of rlcodegen outputting pure-ruby
In-Reply-To: <d56373190701081301k304d4376w5f70940a489b4219@mail.gmail.com>
References: <d56373190701081301k304d4376w5f70940a489b4219@mail.gmail.com>
Message-ID: <45A314BC.7090500@cs.queensu.ca>

Hi Matt, it wouldn't be too much work to add a Ruby backend. I can't 
commit much time to it right now (school is very busy). But I'd be happy 
to help out anyone that wants to try it.

I don't know Ruby all that well so there may be issues which crop up. 
Some things to consider:

Table-based parses will be the easiest to port. Start with the generated 
C code (or maybe Java) for some working parser, then port it to Ruby and 
get it working. You should be able to then just rip out the driver code 
and stick it into rlcodegen.

The fastest code generated by Ragel is directly executable. This relies 
on having a goto. A lack of goto is also a problem for Ragel+Java. Colin 
Fleming discussed generating Java byte code directly to get around this 
issue. The same might be an option for Ruby.

Some changes will need to be made to the frontend. Ruby comments and 
literals will need to be supported and the ruby integral types 
represented. I'm currently in the middle of rewriting the Ragel frontend 
parser. When that's done it will be a better time to add a scanner for 
Ruby which can properly separate Ragel code from Ruby code.

Cheers,
  Adrian

Matt Mower wrote:
> 
> Hi,
> 
> I realise that wrapping the C code generated by Ragel into a Ruby
> extension is a reasonably simple exercise but I really think it would
> help with adoption if Ragel could directly generate Ruby source code.
> 
> Is there any likelyhood of that happening? Or does it need someone
> from the Ruby side to pitch in? And how hard might that be?
> 
> Regards,
> 
> Matt
> 


From vhbo... at gmail.com  Wed Jan 10 10:19:25 2007
From: vhbo... at gmail.com (Victor Hugo Borja)
Date: Wed, 10 Jan 2007 10:19:25 -0000
Subject: Any chance of rlcodegen outputting pure-ruby
In-Reply-To: <45A314BC.7090500@cs.queensu.ca>
References: <d56373190701081301k304d4376w5f70940a489b4219@mail.gmail.com>
   <45A314BC.7090500@cs.queensu.ca>
Message-ID: <1168424365.999868.266240@p59g2000hsd.googlegroups.com>

Matt,

I'm also interested on getting Ragel to output ruby, today I've been
working on this.
Following Adrian's advice, I decided to start by porting a simple
generated parser from c to ruby.
Once the ruby parser was working as expected (used continuations
instead of c' gotos), I started to work on the backend for ragel,
code generation is working now (with awful code indentation atm). the
generated parsers are still somewhat buggy, so I'd appreciate if anyone
could help with tests  for this.

my work up to now is on http://vic.selfip.com/pub/ragel-5.16-rb.tar.gz,
check the rbtmp directory if you want to see the ported parser.

I expect to have some time this weekend to fix the generated parsers,
and commit a working patch to Adrian.

Cheers,
--
Victor Hugo Borja.
v... at rubyforge.org

On Jan 8, 10:06 pm, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
> Hi Matt, it wouldn't be too much work to add a Ruby backend. I can't
> commit much time to it right now (school is very busy). But I'd be happy
> to help out anyone that wants to try it.
>
> I don't know Ruby all that well so there may be issues which crop up.
> Some things to consider:
>
> Table-based parses will be the easiest to port. Start with the generated
> C code (or maybe Java) for some working parser, then port it to Ruby and
> get it working. You should be able to then just rip out the driver code
> and stick it into rlcodegen.
>
> The fastest code generated by Ragel is directly executable. This relies
> on having a goto. A lack of goto is also a problem for Ragel+Java. Colin
> Fleming discussed generating Java byte code directly to get around this
> issue. The same might be an option for Ruby.
>
> Some changes will need to be made to the frontend. Ruby comments and
> literals will need to be supported and the ruby integral types
> represented. I'm currently in the middle of rewriting the Ragel frontend
> parser. When that's done it will be a better time to add a scanner for
> Ruby which can properly separate Ragel code from Ruby code.
>
> Cheers,
>   Adrian
>
> Matt Mower wrote:
>
> > Hi,
>
> > I realise that wrapping the C code generated by Ragel into a Ruby
> > extension is a reasonably simple exercise but I really think it would
> > help with adoption if Ragel could directly generate Ruby source code.
>
> > Is there any likelyhood of that happening? Or does it need someone
> > from the Ruby side to pitch in? And how hard might that be?
> 
> > Regards,
> 
> > Matt


From thurs... at cs.queensu.ca  Wed Jan 10 23:26:49 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Wed, 10 Jan 2007 18:26:49 -0500
Subject: [ragel-users] Re: Any chance of rlcodegen outputting pure-ruby
In-Reply-To: <1168424365.999868.266240@p59g2000hsd.googlegroups.com>
References: <d56373190701081301k304d4376w5f70940a489b4219@mail.gmail.com> <45A314BC.7090500@cs.queensu.ca> <1168424365.999868.266240@p59g2000hsd.googlegroups.com>
Message-ID: <45A57639.8040606@cs.queensu.ca>

Cool! I'll have a look at this ASAP. 5.17 is going to be just a parser
rewrite release but after that I'll add this work in.

Cheers,
 Adrian

Victor Hugo Borja wrote:
> Matt,
> 
> I'm also interested on getting Ragel to output ruby, today I've been
> working on this.
> Following Adrian's advice, I decided to start by porting a simple
> generated parser from c to ruby.
> Once the ruby parser was working as expected (used continuations
> instead of c' gotos), I started to work on the backend for ragel,
> code generation is working now (with awful code indentation atm). the
> generated parsers are still somewhat buggy, so I'd appreciate if anyone
> could help with tests  for this.
> 
> my work up to now is on http://vic.selfip.com/pub/ragel-5.16-rb.tar.gz,
> check the rbtmp directory if you want to see the ported parser.
> 
> I expect to have some time this weekend to fix the generated parsers,
> and commit a working patch to Adrian.
> 
> Cheers,
> --
> Victor Hugo Borja.
> v... at rubyforge.org
> 
> On Jan 8, 10:06 pm, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
>> Hi Matt, it wouldn't be too much work to add a Ruby backend. I can't
>> commit much time to it right now (school is very busy). But I'd be happy
>> to help out anyone that wants to try it.
>>
>> I don't know Ruby all that well so there may be issues which crop up.
>> Some things to consider:
>>
>> Table-based parses will be the easiest to port. Start with the generated
>> C code (or maybe Java) for some working parser, then port it to Ruby and
>> get it working. You should be able to then just rip out the driver code
>> and stick it into rlcodegen.
>>
>> The fastest code generated by Ragel is directly executable. This relies
>> on having a goto. A lack of goto is also a problem for Ragel+Java. Colin
>> Fleming discussed generating Java byte code directly to get around this
>> issue. The same might be an option for Ruby.
>>
>> Some changes will need to be made to the frontend. Ruby comments and
>> literals will need to be supported and the ruby integral types
>> represented. I'm currently in the middle of rewriting the Ragel frontend
>> parser. When that's done it will be a better time to add a scanner for
>> Ruby which can properly separate Ragel code from Ruby code.
>>
>> Cheers,
>>   Adrian
>>
>> Matt Mower wrote:
>>
>>> Hi,
>>> I realise that wrapping the C code generated by Ragel into a Ruby
>>> extension is a reasonably simple exercise but I really think it would
>>> help with adoption if Ragel could directly generate Ruby source code.
>>> Is there any likelyhood of that happening? Or does it need someone
>>> from the Ruby side to pitch in? And how hard might that be?
>>> Regards,
>>> Matt
> 
> 
> 


From vhbo... at gmail.com  Thu Jan 11 06:59:11 2007
From: vhbo... at gmail.com (Victor Hugo Borja)
Date: Thu, 11 Jan 2007 06:59:11 -0000
Subject: Any chance of rlcodegen outputting pure-ruby
In-Reply-To: <45A57639.8040606@cs.queensu.ca>
References: <d56373190701081301k304d4376w5f70940a489b4219@mail.gmail.com>
   <45A314BC.7090500@cs.queensu.ca>
   <1168424365.999868.266240@p59g2000hsd.googlegroups.com>
   <45A57639.8040606@cs.queensu.ca>
Message-ID: <1168498751.118580.312840@k58g2000hse.googlegroups.com>

Just updated the tar on http://vic.selfip.com/pub/ragel-5.16-rb.tar.gz
, fixed some bugs, used the atoi.rl example to prove code generation,
checkout rbtmp/atoi.rb.xml and rbtmp/atoi.rb , next step will be adding
test cases and test/langtrans_ruby.txl

On Jan 10, 5:26 pm, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
> 5.17 is going to be just a parser rewrite release but after that I'll add this work in.

Fine, I'd like to work on the ruby frontend support when 5.17 is ready.

Cheers,
  vic


From s... at mattmower.com  Mon Jan 15 17:00:29 2007
From: s... at mattmower.com (Matt Mower)
Date: Mon, 15 Jan 2007 17:00:29 +0000
Subject: Ragel chat
Message-ID: <d56373190701150900w690d52a1qddb5559ad84d5433@mail.gmail.com>

BTW on the off-chance anyone wants to talk about Ragel stuff I am
hanging around in #ragel on FreeNode IRC.

M

-- 
Matt Mower :: http://matt.blogs.it/


From s... at mattmower.com  Mon Jan 15 16:57:50 2007
From: s... at mattmower.com (Matt Mower)
Date: Mon, 15 Jan 2007 16:57:50 +0000
Subject: Fixing an edge case
Message-ID: <d56373190701150857m55c30464h584961023b62a012@mail.gmail.com>

Hi there.

I have come across a case that my "svn diff" parser doesn't handle and
I'm hoping you can help me in solving it.

The situation is this: It is possible (however unlikely) to "svn add"
an empty file to a repository (e.g. touch <file>; svn add <file>). If
you do this the output from "svn diff" contains an imcomplete header
for the diff and no hunk information. Thus instead of something like:

Index: newfile
=====================
--- new file (revision 0)
+++ new file (revision 0)
@@ .... @@
content here

you get:

Index: newfile
=====================

and this can occur in one of two places: either with another diff
following, or as the last diff so that potentially you can get the
output of "svn diff" terminate with:

=====================

which previously would have been considered to be an incomplete diff.
Now it has to be treated as an empty file diff.

Here is my parser machine:

	nbsp = space - '\n' %count_line;
	lineChar = extend - '\n';
	
	diffLine = ( '\\' lineChar* '\n' %count_line ) | ( ' ' | '-' | '+' )
>mark lineChar* '\n' @add_line %count_line;
	
	separator = '='+ '\n' %count_line;
	
	oldFile = '---' lineChar+ '\n' %count_line;
	newFile = '+++' lineChar+ '\n' %count_line;
	
	range = ( '-' | '+' ) ( digit+ >mark %push ) ( ' ' %push_zero @{
fhold; }  | ',' ( digit+ >mark %push ) );
	
	hunkHeader = '@@' nbsp* range nbsp+ range nbsp* '@@' '\n'
@pop_hunk_spec %count_line;
	
	hunkBody = diffLine+;
	
	hunk = hunkHeader >enter_hunk hunkBody %exit_hunk %/exit_hunk;
	
	fileName = ( lineChar+ ) >mark %copy_to_filespec;
	
	fileSpec = "Index:" nbsp+ fileName '\n'+ @count_line;
	
	diffHeader = fileSpec separator;
	
	diffBody = hunk* %exit_diff %/exit_diff;
	
	binaryDiff = 'C' lineChar+ '\n' %count_line lineChar+ '\n'
%binary_diff %count_line;
	
	textDiff = oldFile newFile diffBody;
	
	diff = diffHeader >enter_diff ( binaryDiff | textDiff );
	
	main := diff* $!error;

This machine uses the fact that a diff is ended either by another diff
starting (a line not beginning ' ' | '-' | '+') or EOF using a %/
action.

My problem in coming up with a solution has been to come up with
something that works both when a diff follows an 'empty' diff, when an
'empty' diff comes at the end and not, in the process, ending up
generating spurious empty diffs all over the place!

For example I can find the former case with something like:

	emptyDiff = ( any - ['-'|'C'] @{ fhold; } %empty_diff;
	
	diff = diffHeader >enter_diff ( binaryDiff | textDiff | emptyDiff );

the problem comes when I try to detect the empty case, my first
thought being something like:

    emptyDiff = ( ( any - ['-'|'C'] @{ fhold; } ) | zlen ) %empty_diff;

but this kind of formulation (written from memory) ends up with
machines which detect zlen for every diff (as you'd expect once you
graph it).

I've tinkered but my lack of ability to reason out the answer suggests
I am not as comfortable with this as I thought. My next step will be
to draw out what I think the machine should look like and work
backwards to the spec but if anyone can guide my thinking or give me
some pointers that would help immensely. Fixing this edge case is one
of the last things holding up a first public release of the tool.

Many thanks,

Matt

-- 
Matt Mower :: http://matt.blogs.it/


From thurs... at cs.queensu.ca  Tue Jan 16 00:06:49 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Mon, 15 Jan 2007 19:06:49 -0500
Subject: [ragel-users] Fixing an edge case
In-Reply-To: <d56373190701150857m55c30464h584961023b62a012@mail.gmail.com>
References: <d56373190701150857m55c30464h584961023b62a012@mail.gmail.com>
Message-ID: <45AC1719.60607@cs.queensu.ca>

Hi Matt, try the attached file. The important part is in diff machine. The
first alternative handles the edge case of an empty diff. The second part
handles the regular case.

-Adrian
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: tmp.rl
URL: <http://www.colm.net/pipermail/ragel-users/attachments/20070115/4d45d754/attachment-0001.ksh>

From thurs... at cs.queensu.ca  Tue Jan 16 16:55:33 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Tue, 16 Jan 2007 11:55:33 -0500
Subject: [ragel-users] Re: Fixing an edge case
In-Reply-To: <45AC1719.60607@cs.queensu.ca>
References: <d56373190701150857m55c30464h584961023b62a012@mail.gmail.com> <45AC1719.60607@cs.queensu.ca>
Message-ID: <45AD0385.7040602@cs.queensu.ca>

Sorry, this was sloppy ... the question mark in the diff machine can be removed.

-Adrian

Adrian Thurston wrote:
> Hi Matt, try the attached file. The important part is in diff machine. The
> first alternative handles the edge case of an empty diff. The second part
> handles the regular case.
> 
> -Adrian
> 
> > 
> jinclude <stdio.h>
> 
> %%{
>     machine diff;
>     action count_line {}
>     action mark {}
>     action add_line {}
>     action push {}
>     action push_zero {}
>     action pop_hunk_spec {}
>     action copy_to_filespec {}
>     action enter_hunk { printf("  enter_hunk\n"); }
>     action exit_hunk {  printf("  exit_hunk\n"); }
>     action enter_diff { printf("enter_diff\n"); }
>     action exit_diff { printf("exit_diff\n"); }
>     action empty_diff { printf("  this diff is empty\n"); }
>     action binary_diff {}
>     action error {}
> 
>     nbsp = space - '\n' %count_line;
>     lineChar = extend - '\n';
>     
>     diffLine =         ( '\\' lineChar* '\n' %count_line ) |
>         ( ' ' | '-' | '+' ) >mark         lineChar* '\n' @add_line
> %count_line;
>     
>     separator = '='+ '\n' %count_line;
>     
>     oldFile = '---' lineChar+ '\n' %count_line;
>     newFile = '+++' lineChar+ '\n' %count_line;
>     
>     range = ( '-' | '+' ) ( digit+ >mark %push ) ( ' ' %push_zero
>             @{ fhold; }  | ',' ( digit+ >mark %push ) );
>     
>     hunkHeader = '@@' nbsp* range nbsp+ range nbsp* '@@' '\n'
>         @pop_hunk_spec %count_line;
>     
>     hunkBody = diffLine+;
>     
>     hunk = hunkHeader >enter_hunk hunkBody %exit_hunk %/exit_hunk;
>     
>     fileName = ( lineChar+ ) >mark %copy_to_filespec;
>     
>     fileSpec = "Index:" nbsp+ fileName '\n'+ @count_line;
>     
>     diffHeader = fileSpec separator;
>     
>     diffBody = hunk*;
>     
>     binaryDiff = 'C' lineChar+ '\n' %count_line lineChar+ '\n'
>         %binary_diff %count_line;
>     
>     textDiff = oldFile newFile diffBody;
>     
>     diff = (
>         diffHeader %empty_diff %/empty_diff |
>         diffHeader ( binaryDiff | textDiff ) ?
>     )
>     >enter_diff    %exit_diff %/exit_diff;
>     
>     main := diff* $!error;
> }%%
> 
> %% write data;
> 
> int main()
> {
>     static char buf[2000000];
>     int len = fread( buf, 1, sizeof(buf), stdin );
>     printf( "%i\n", len );
> 
>     int cs;
>     char *p = buf, *pe = buf+len;
>     %%{
>         write init;
>         write exec;
>     }%%
> 
>     if ( cs < diff_first_final )
>         printf(" ERROR \n" );
>     else {
>         %% write eof;
>     }
>     return 0;
> }
> 


From thurs... at cs.queensu.ca  Tue Jan 16 19:07:21 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Tue, 16 Jan 2007 14:07:21 -0500
Subject: [ragel-users] Re: Fixing an edge case
In-Reply-To: <45AD0385.7040602@cs.queensu.ca>
References: <d56373190701150857m55c30464h584961023b62a012@mail.gmail.com> <45AC1719.60607@cs.queensu.ca> <45AD0385.7040602@cs.queensu.ca>
Message-ID: <45AD2269.7050704@cs.queensu.ca>

I've made this thread a little confusing, so here's a recap with some
explanations.

This machine does not do what you want. It does properly execute empty_diff
when an empty diff is found, but it also executes empty_diff on the
transitions from diffHeader to either binaryDiff or textDiff.

diff1 = (
	diffHeader %empty_diff %/empty_diff
	( binaryDiff | textDiff ) ?
);


The following code is one way to fix the problem. It's like the above, but
separates the leaving/eof actions from the non-empty case. When diff2 exits
after only a diffHeader the empty diff action is executed. Note that here
diffHeader is unioned with itself. This relies on the fact that ragel
removes action duplicates from transition lists. Otherwise the actions of
diffHeader would be doubled up.

diff2 = (
	diffHeader %empty_diff %/empty_diff |
	diffHeader ( binaryDiff | textDiff )
);

And finally, this is another way to do it. I essentially factor out the
diffHeader. The "" machine is a single state which has the leaving/eof
actions embedded into it.
	
diff3 = (
	diffHeader (
		"" %empty_diff %/empty_diff |
		( binaryDiff | textDiff )
	)
);


I hope this helps,
 Adrian


From s... at mattmower.com  Tue Jan 16 21:55:12 2007
From: s... at mattmower.com (Matt Mower)
Date: Tue, 16 Jan 2007 21:55:12 +0000
Subject: [ragel-users] Re: Fixing an edge case
In-Reply-To: <45AD2269.7050704@cs.queensu.ca>
References: <d56373190701150857m55c30464h584961023b62a012@mail.gmail.com>
	 <45AC1719.60607@cs.queensu.ca> <45AD0385.7040602@cs.queensu.ca>
	 <45AD2269.7050704@cs.queensu.ca>
Message-ID: <d56373190701161355u3acae0ecl97885e4aadaa64cd@mail.gmail.com>

Hi Adrian,

Many thanks for the recap :)

On 16/01/07, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
> The following code is one way to fix the problem. It's like the above, but
> separates the leaving/eof actions from the non-empty case. When diff2 exits
> after only a diffHeader the empty diff action is executed. Note that here
> diffHeader is unioned with itself. This relies on the fact that ragel
> removes action duplicates from transition lists. Otherwise the actions of
> diffHeader would be doubled up.
>
> diff2 = (
>         diffHeader %empty_diff %/empty_diff |
>         diffHeader ( binaryDiff | textDiff )
> );
>

Interesting, so it can track that the leaving action should only
happen when neither of the non-empty diff paths is taken after
reduction? My gut feeling would have been that it would end up
executing them every time. I shall have to graph it and take a look.

> And finally, this is another way to do it. I essentially factor out the
> diffHeader. The "" machine is a single state which has the leaving/eof
> actions embedded into it.
>
> diff3 = (
>         diffHeader (
>                 "" %empty_diff %/empty_diff |
>                 ( binaryDiff | textDiff )
>         )
> );
>

Ah, I think that's more what I was intuitively trying to grasp for. Cool.

Thanks again for your help!

Regards,

Matt

-- 
Matt Mower :: http://matt.blogs.it/


From thurs... at cs.queensu.ca  Wed Jan 17 01:47:55 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Tue, 16 Jan 2007 20:47:55 -0500
Subject: [ragel-users] Re: Fixing an edge case
In-Reply-To: <d56373190701161355u3acae0ecl97885e4aadaa64cd@mail.gmail.com>
References: <d56373190701150857m55c30464h584961023b62a012@mail.gmail.com> <45AC1719.60607@cs.queensu.ca> <45AD0385.7040602@cs.queensu.ca> <45AD2269.7050704@cs.queensu.ca> <d56373190701161355u3acae0ecl97885e4aadaa64cd@mail.gmail.com>
Message-ID: <45AD804B.9060806@cs.queensu.ca>


Matt Mower wrote:
>> diff2 = (
>>         diffHeader %empty_diff %/empty_diff |
>>         diffHeader ( binaryDiff | textDiff )
>> );
>>
> 
> Interesting, so it can track that the leaving action should only
> happen when neither of the non-empty diff paths is taken after
> reduction? My gut feeling would have been that it would end up
> executing them every time. I shall have to graph it and take a look.

Leaving actions initially go into final states. They stay there, inactive,
until transitions are made which leave the machine from those final states.
This leaving is either by concatenation or by kleene star. So the
%empty_diff is left alone by the union, but when kleene star is applied to
diff2 it is transferred to the transition which wraps around and starts
diff2 over again.

If you were to use the @ action embedding operator then it would be executed
on the final character of diffHeader in both cases because it goes right
into transitions. It is not 'pending' as is the % operator.

Regards,
 Adrian


From thurs... at cs.queensu.ca  Sun Jan 21 23:58:30 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Sun, 21 Jan 2007 18:58:30 -0500 (EST)
Subject: public read-only svn repository
Message-ID: <1917.66.102.72.38.1169423910.squirrel@mambo.cs.queensu.ca>

Greetings,

There is now a public read-only subversion repository in which I will do
all my committing. It can be found at:

svn://mambo.cs.queensu.ca/

In it you'll find:

/ragel/tags/
/ragel/branches/
/ragel/trunk/

Cheers,
 Adrian


From dam... at gmail.com  Sat Jan 20 21:20:52 2007
From: dam... at gmail.com (Damir Nedzibovic)
Date: Sat, 20 Jan 2007 21:20:52 -0000
Subject: ragel and memory usage
Message-ID: <1169328052.670628.158880@m58g2000cwm.googlegroups.com>

Hi all,

I'm trying to build a grammar for parsing SIP headers (from rfc3261),
but I have encountered a problem which I cannot solve - it seems that
there's a state explosion somewhere when I try to compile my grammar
with ragel 5.16.

here's my grammar (sorry for pasting all of it here)

-- cut --
%%{
  machine sip_parser;

  action mark
  {
  }

  action req_i
  {
  }

  action req_a
  {
  }

  action req_o
  {
  }

  action req_b
  {
  }

  action req_c
  {
  }

  action req_r
  {
  }

  action create_req
  {
  }

  action request_method
  {
  }

  action uri_host
  {
  }

  action done
  {
    fbreak;
  }

  action uri_port
  {
  }

  action uri_pass
  {
  }

  action uri_user
  {
  }

  action uri_scheme
  {
  }

  action set_req_uri
  {
  }

  action add_param
  {
  }

  action add_param_value
  {
  }

  action uri_query
  {
  }

#### SIP PROTOCOL GRAMMAR

  CRLF = "\r\n";
  SP = " ";
  HTAB = "\t";
  DQUOTE = "\"";
  LHEX = digit | [a-f];

  alphanum = [a-zA-Z0-9];
  reserved = (";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" | "$" |
",");
  mark = ("-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")");
  unreserved = (alphanum | mark);
  escaped = ("%" xdigit xdigit);

  LWS = ((" "* CRLF)? " "+);
  SWS = (LWS?);

  HCOLON = ((" " | "\t")* ":" SWS);

  token = (alphanum | "-" | "." | "!" | "%" | "*" | "_" | "+" | "`" |
"'" | "~" )+;
  separators = ("(" | ")" | "<" | ">" | "@" | "," | ";" | ":" | "\\" |
DQUOTE | "/" | "[" | "]" | "?" | "=" | "{" | "}" | SP | HTAB);
  word = (alphanum | "-" | "." | "!" | "%" | "*" | "_" | "+" | "`" |
"'" | "~" | "(" | ")" | "<" | ">" | ":" | "\\" | DQUOTE | "/" | "[" |
"]" | "?" | "{" | "}")+;

  STAR   = (SWS "*" SWS);
  SLASH  = (SWS "/" SWS);
  EQUAL  = (SWS "=" SWS);
  LPAREN = (SWS "(" SWS);
  RPAREN = (SWS ")" SWS);
  RAQUOT = (">" SWS);
  LAQUOT = (SWS "<");
  COMMA  = (SWS "," SWS);
  SEMI   = (SWS ";" SWS);
  COLON  = (SWS ":" SWS);
  LDQUOT = (SWS DQUOTE);
  RDQUOT = (DQUOTE SWS);

  qdtext = (LWS | 0x21 | 0x23..0x5B | 0x5D..0x7E);
  quoted_pair = ("\\" (0x00..0x09 | 0x0B..0x0C | 0x0E..0x7F));
  quoted_string = (SWS DQUOTE (qdtext | quoted_pair)* DQUOTE);
  ctext    = (0x21..27 | 0x2A..0x5B | 0x5D..0x7E | LWS);
  comment_r = (LPAREN? (ctext | quoted_pair) RPAREN?);
  comment  = (LPAREN (comment_r)* RPAREN);

  port = digit+;
  IPv4address =  (digit{1,3} "." digit{1,3} "." digit{1,3} "."
digit{1,3});
  toplabel = (alpha | (alpha (alphanum | "-")* alphanum));
  domainlabel = (alphanum | (alphanum (alphanum | "-")* alphanum));
  hostname = ((domainlabel ".")* toplabel "."?);
  host = (hostname | IPv4address);
  hostport = (host >mark %uri_host (":" port >mark %uri_port)?);
  password = ((unreserved | escaped | "&" | "=" | "+" | "$" | "," )*);
  user_unreserved = ("&" | "=" | "+" | "$" | "," | ";" | "?" | "/");
  user = ((unreserved | escaped | user_unreserved)+);
  userinfo = (user >mark %uri_user (":" password >mark %uri_pass)?
"@");

  extension_method = token;
  Method = (("INVITE" %req_i | "ACK" %req_a | "OPTIONS" %req_o | "BYE"
%req_b | "CANCEL" %req_c | "REGISTER" %req_r | extension_method)) >mark
%request_method;

  hnv_unreserved = ("[" | "]" | "|" | "?" | ":" | "+" | "$");
  hvalue = ((hnv_unreserved | unreserved | escaped)*);
  hname = ((hnv_unreserved | unreserved | escaped)+);
  header = (hname "=" hvalue);
  headers = ("?" header ("&" header)*);
  param_unreserved = ("[" | "]" | "/" | ":" | "&" | "+" | "$");
  paramchar = (param_unreserved | unreserved | escaped);
  pvalue = (paramchar+);
  pname = (paramchar+);
  other_param = (pname >mark %add_param ("=" pvalue >mark
%add_param_value)?);
  lr_param = "lr" >mark %add_param;
  maddr_param = "maddr" >mark %add_param "=" host >mark
%add_param_value;
  method_param = "method" >mark %add_param "=" Method >mark
%add_param_value;
  ttl = (digit{1,3});
  ttl_param = "ttl" >mark %add_param "=" ttl >mark %add_param_value;
  other_user = token;
  user_param = "user" >mark %add_param "=" ("phone" | "ip" |
other_user) >mark %add_param_value;
  other_transport = token;
  transport_param = ("transport" >mark %add_param "=" ("udp" | "tcp" |
"sctp" | "tls" | other_transport) >mark %add_param_value);
  uri_parameter = (transport_param | user_param | method_param |
ttl_param | maddr_param | lr_param | other_param);
  uri_parameters = ((";" uri_parameter)*);
  SIP_URI = ("sip:" %{ m_data->m_uri.scheme() = "sip"; } (userinfo)?
hostport uri_parameters (headers)?);
  SIPS_URI = ("sips:" %{ m_data->m_uri.scheme() = "sips"; } (userinfo)?
hostport uri_parameters (headers)?);

  x_token = ("x-" token);
  ietf_token = token;
  extension_token = (ietf_token | x_token);
  composite_type = ("message" | "multipart" | extension_token);
  discrete_type = ("text" | "image" | "audio" | "video" | "application"
| extension_token);
  m_type = (discrete_type | composite_type);

  m_value = (token | quoted_string);
  m_attribute = token;
  m_parameter = (m_attribute EQUAL m_value);
  iana_token = token;
  m_subtype = (extension_token | iana_token);

  uric           = (reserved | unreserved | escaped);
  query          = (uric*);
  reg_name       = (unreserved | escaped | "$" | "," | ";" | ":" | "@"
| "&" | "=" | "+" )+;
  srvr           = ((userinfo "@")? hostport)?;
  authority      = (srvr | reg_name);
  scheme         = (alpha (alpha | digit | "+" | "-" | "." )*);
  pchar          = (unreserved | escaped | ":" | "@" | "&" | "=" | "+"
| "$" | ",");
  param          = (pchar*);
  segment        = (pchar* (";" param)*);
  path_segments  = (segment ("/" segment)*);
  uric_no_slash  = (unreserved | escaped | ";" | "?" | ":" | "@" | "&"
| "=" | "+" | "$" | ",");
  opaque_part    = (uric_no_slash uric*);
  abs_path       = ("/" path_segments);
  net_path       = ("//" authority (abs_path)?);
  hier_part      = ((net_path | abs_path) ("?" query >mark
%uri_query)?);
  absoluteURI    = (scheme >mark %uri_scheme ":" (hier_part |
opaque_part));

  gen_value = (token | host | quoted_string);
  generic_param = (token (EQUAL gen_value)?);
  qvalue = (("0" ("." digit{,3})?) | ("1" ("." ("0"){,3})?));
  accept_param = (("q" EQUAL qvalue) | generic_param);
  media_range = (("*" "/" "*" | ( m_type SLASH "*" ) | ( m_type SLASH
m_subtype )) (SEMI m_parameter)*);
  accept_range = (media_range (SEMI accept_param)*);
  Accept = ("Accept" HCOLON (accept_range (COMMA accept_range)*))?;

  content_coding   = (token);
  codings          = (content_coding | "*");
  encoding         = (codings (SEMI accept_param)*);
  Accept_Encoding  = ("Accept-Encoding" HCOLON (encoding (COMMA
encoding)*)?);

  language_range   = (((alpha{1,8} ("-" alpha{1,8})*) | "*" ));
  language         = (language_range (SEMI accept_param)*);
  Accept_Language  = ("Accept-Language" HCOLON (language (COMMA
language)*)?);

  alert_param      = (LAQUOT absoluteURI RAQUOT (SEMI generic_param
)*);
  Alert_Info       = ("Alert-Info" HCOLON alert_param (COMMA
alert_param)*);

  Allow            = ("Allow" HCOLON (Method (COMMA Method)*)?);

  opaque           = ("opaque" EQUAL quoted_string);
  algorithm        = ("algorithm" EQUAL ("MD5" | "MD5-sess" | token));
  realm_value      = (quoted_string);
  realm            = ("realm" EQUAL realm_value);
  auth_scheme      = (token);
  auth_param_name  = (token);
  auth_param       = (auth_param_name EQUAL (token | quoted_string));
  other_response   = (auth_scheme LWS auth_param (COMMA auth_param)*);
  request_digest   = (LDQUOT LHEX{32} RDQUOT);
  dresponse        = ("response" EQUAL request_digest);
  nonce_value      = (quoted_string);
  nonce            = ("nonce" EQUAL nonce_value);
  nc_value         = (LHEX{8});
  nonce_count      = ("nc" EQUAL nc_value);
  cnonce_value     = (nonce_value);
  cnonce           = ("cnonce" EQUAL cnonce_value);
  qop_value        = ("auth" | "auth-int" | token);
  message_qop      = ("qop" EQUAL qop_value);
  digest_uri_value = (absoluteURI); # fixme
  digest_uri       = ("uri" EQUAL LDQUOT digest_uri_value RDQUOT);
  username_value   = (quoted_string);
  username         = ("username" EQUAL username_value);
  dig_resp         = (username | realm | nonce | digest_uri | dresponse
| algorithm | cnonce | opaque | message_qop | nonce_count |
auth_param);
  digest_response  = (dig_resp (COMMA dig_resp)*);
  credentials      = (("Digest" LWS digest_response) | other_response);
  Authorization    = ("Authorization" HCOLON credentials);

  response_digest      = (LDQUOT LHEX* RDQUOT);
  response_auth        = ("rspauth" EQUAL response_digest);
  nextnonce            = ("nextnonce" EQUAL nonce_value);
  ainfo                = (nextnonce | message_qop | response_auth |
cnonce | nonce_count);
  Authentication_Info  = ("Authentication-Info" HCOLON ainfo (COMMA
ainfo)*);

  callid   =  (word ("@" word)?);
  Call_ID  = (( "Call-ID" | "i" ) HCOLON callid);

  info_param  = (("purpose" EQUAL ("icon" | "info" | "card" | token)) |
generic_param);
  info        = (LAQUOT absoluteURI RAQUOT (SEMI info_param)*);
  Call_Info   = ("Call-Info" HCOLON info (COMMA info)*);

  delta_seconds      = (digit+);
  contact_extension  = (generic_param);
  c_p_expires    = ("expires" EQUAL delta_seconds);
  c_p_q          = ("q" EQUAL qvalue);
  contact_params = (c_p_q | c_p_expires);
  display_name   = ((token LWS)* | quoted_string);
  addr_spec      = (SIP_URI | SIPS_URI | absoluteURI);
  name_addr      = ((display_name)? LAQUOT addr_spec RAQUOT);
  contact_param  = ((name_addr | addr_spec) (SEMI contact_params)*);
  Contact     = (("Contact" | "m" ) HCOLON (STAR | (contact_param
(COMMA contact_param)*)));

  disp_extension_token  = (token);
  other_handling        = (token);
  handling_param        = ("handling" EQUAL ( "optional" | "required" |
other_handling));
  disp_param            = (handling_param | generic_param);
  disp_type             = ("render" | "session" | "icon" | "alert" |
disp_extension_token);
  Content_Disposition   = ("Content-Disposition" HCOLON disp_type (SEMI
disp_param)*);

  Content_Encoding  = (("Content-Encoding" | "e" ) HCOLON
content_coding (COMMA content_coding)*);

  subtag            = (alpha{1,8});
  primary_tag       = (alpha{1,8});
  language_tag      = (primary_tag ("-" subtag)*);
  Content_Language  = ("Content-Language" HCOLON language_tag (COMMA
language_tag)*);

  Content_Length    = (("Content-Length" | "l") HCOLON digit+);

  media_type        = (m_type SLASH m_subtype (SEMI m_parameter)*);
  Content_Type      = (("Content-Type" | "c" ) HCOLON media_type);

  CSeq = ("CSeq" HCOLON digit+ LWS Method);

  message_header = (Accept |
                    Accept_Encoding |
                    Accept_Language |
                    Alert_Info |
                    Allow |
                    Authentication_Info |
                    Authorization |
                    Call_ID |
                    Call_Info |
                    Contact |
                    Content_Disposition |
                    Content_Encoding |
                    Content_Language |
                    Content_Length |
                    Content_Type |
                    CSeq) CRLF;

  SIP_Version    = "SIP" "/" digit "." digit;
  Request_URI    = SIP_URI | SIPS_URI | absoluteURI;
  Request_Line   = Method %create_req SP Request_URI %set_req_uri SP
SIP_Version CRLF;
  Request        = Request_Line (message_header)* CRLF;

main := Request;
}%%

%% write data;

-- cut --

it seems the problem is in this line:
hier_part      = ((net_path | abs_path) ("?" query >mark %uri_query)?);

if I remove ">mark %uri_query" ragel is able to generate the code.

Can anyone give me a clue what's going on here?

tia,
d


From dam... at gmail.com  Sat Jan 20 21:40:53 2007
From: dam... at gmail.com (Damir Nedzibovic)
Date: Sat, 20 Jan 2007 21:40:53 -0000
Subject: ragel and memory usage
Message-ID: <1169329253.204791.3690@38g2000cwa.googlegroups.com>

Hi all,

I'm trying to build a grammar for parsing SIP messages (as in rfc3261),
but I have encountered a problem that I cannot solve - it seems that
I've hit a state explosion, since ragel just keeps allocating memory
and finally dies.

Here's my grammar (sorry for pasting it here like this)

--cut--
%%{
  machine sip_parser;

  action mark
  {
  }

  action req_i
  {
  }

  action req_a
  {
  }

  action req_o
  {
  }

  action req_b
  {
  }

  action req_c
  {
  }

  action req_r
  {
  }

  action create_req
  {
  }

  action request_method
  {
  }

  action uri_host
  {
  }

  action done
  {
    fbreak;
  }

  action uri_port
  {
  }

  action uri_pass
  {
  }

  action uri_user
  {
  }

  action uri_scheme
  {
  }

  action set_req_uri
  {
  }

  action add_param
  {
  }

  action add_param_value
  {
  }

  action uri_query
  {
  }

#### SIP PROTOCOL GRAMMAR

  CRLF = "\r\n";
  SP = " ";
  HTAB = "\t";
  DQUOTE = "\"";
  LHEX = digit | [a-f];

  alphanum = [a-zA-Z0-9];
  reserved = (";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" | "$" |
",");
  mark = ("-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")");
  unreserved = (alphanum | mark);
  escaped = ("%" xdigit xdigit);

  LWS = ((" "* CRLF)? " "+);
  SWS = (LWS?);

  HCOLON = ((" " | "\t")* ":" SWS);

  token = (alphanum | "-" | "." | "!" | "%" | "*" | "_" | "+" | "`" |
"'" | "~" )+;
  separators = ("(" | ")" | "<" | ">" | "@" | "," | ";" | ":" | "\\" |
DQUOTE | "/" | "[" | "]" | "?" | "=" | "{" | "}" | SP | HTAB);
  word = (alphanum | "-" | "." | "!" | "%" | "*" | "_" | "+" | "`" |
"'" | "~" | "(" | ")" | "<" | ">" | ":" | "\\" | DQUOTE | "/" | "[" |
"]" | "?" | "{" | "}")+;

  STAR   = (SWS "*" SWS);
  SLASH  = (SWS "/" SWS);
  EQUAL  = (SWS "=" SWS);
  LPAREN = (SWS "(" SWS);
  RPAREN = (SWS ")" SWS);
  RAQUOT = (">" SWS);
  LAQUOT = (SWS "<");
  COMMA  = (SWS "," SWS);
  SEMI   = (SWS ";" SWS);
  COLON  = (SWS ":" SWS);
  LDQUOT = (SWS DQUOTE);
  RDQUOT = (DQUOTE SWS);

  qdtext = (LWS | 0x21 | 0x23..0x5B | 0x5D..0x7E);
  quoted_pair = ("\\" (0x00..0x09 | 0x0B..0x0C | 0x0E..0x7F));
  quoted_string = (SWS DQUOTE (qdtext | quoted_pair)* DQUOTE);
  ctext    = (0x21..27 | 0x2A..0x5B | 0x5D..0x7E | LWS);
  comment_r = (LPAREN? (ctext | quoted_pair) RPAREN?);
  comment  = (LPAREN (comment_r)* RPAREN);

  port = digit+;
  IPv4address =  (digit{1,3} "." digit{1,3} "." digit{1,3} "."
digit{1,3});
  toplabel = (alpha | (alpha (alphanum | "-")* alphanum));
  domainlabel = (alphanum | (alphanum (alphanum | "-")* alphanum));
  hostname = ((domainlabel ".")* toplabel "."?);
  host = (hostname | IPv4address);
  hostport = (host >mark %uri_host (":" port >mark %uri_port)?);
  password = ((unreserved | escaped | "&" | "=" | "+" | "$" | "," )*);
  user_unreserved = ("&" | "=" | "+" | "$" | "," | ";" | "?" | "/");
  user = ((unreserved | escaped | user_unreserved)+);
  userinfo = (user >mark %uri_user (":" password >mark %uri_pass)?
"@");

  extension_method = token;
  Method = (("INVITE" %req_i | "ACK" %req_a | "OPTIONS" %req_o | "BYE"
%req_b | "CANCEL" %req_c | "REGISTER" %req_r | extension_method)) >mark
%request_method;

  hnv_unreserved = ("[" | "]" | "|" | "?" | ":" | "+" | "$");
  hvalue = ((hnv_unreserved | unreserved | escaped)*);
  hname = ((hnv_unreserved | unreserved | escaped)+);
  header = (hname "=" hvalue);
  headers = ("?" header ("&" header)*);
  param_unreserved = ("[" | "]" | "/" | ":" | "&" | "+" | "$");
  paramchar = (param_unreserved | unreserved | escaped);
  pvalue = (paramchar+);
  pname = (paramchar+);
  other_param = (pname >mark %add_param ("=" pvalue >mark
%add_param_value)?);
  lr_param = "lr" >mark %add_param;
  maddr_param = "maddr" >mark %add_param "=" host >mark
%add_param_value;
  method_param = "method" >mark %add_param "=" Method >mark
%add_param_value;
  ttl = (digit{1,3});
  ttl_param = "ttl" >mark %add_param "=" ttl >mark %add_param_value;
  other_user = token;
  user_param = "user" >mark %add_param "=" ("phone" | "ip" |
other_user) >mark %add_param_value;
  other_transport = token;
  transport_param = ("transport" >mark %add_param "=" ("udp" | "tcp" |
"sctp" | "tls" | other_transport) >mark %add_param_value);
  uri_parameter = (transport_param | user_param | method_param |
ttl_param | maddr_param | lr_param | other_param);
  uri_parameters = ((";" uri_parameter)*);
  SIP_URI = ("sip:" %{ m_data->m_uri.scheme() = "sip"; } (userinfo)?
hostport uri_parameters (headers)?);
  SIPS_URI = ("sips:" %{ m_data->m_uri.scheme() = "sips"; } (userinfo)?
hostport uri_parameters (headers)?);

  x_token = ("x-" token);
  ietf_token = token;
  extension_token = (ietf_token | x_token);
  composite_type = ("message" | "multipart" | extension_token);
  discrete_type = ("text" | "image" | "audio" | "video" | "application"
| extension_token);
  m_type = (discrete_type | composite_type);

  m_value = (token | quoted_string);
  m_attribute = token;
  m_parameter = (m_attribute EQUAL m_value);
  iana_token = token;
  m_subtype = (extension_token | iana_token);

  uric           = (reserved | unreserved | escaped);
  query          = (uric*);
  reg_name       = (unreserved | escaped | "$" | "," | ";" | ":" | "@"
| "&" | "=" | "+" )+;
  srvr           = ((userinfo "@")? hostport)?;
  authority      = (srvr | reg_name);
  scheme         = (alpha (alpha | digit | "+" | "-" | "." )*);
  pchar          = (unreserved | escaped | ":" | "@" | "&" | "=" | "+"
| "$" | ",");
  param          = (pchar*);
  segment        = (pchar* (";" param)*);
  path_segments  = (segment ("/" segment)*);
  uric_no_slash  = (unreserved | escaped | ";" | "?" | ":" | "@" | "&"
| "=" | "+" | "$" | ",");
  opaque_part    = (uric_no_slash uric*);
  abs_path       = ("/" path_segments);
  net_path       = ("//" authority (abs_path)?);
  hier_part      = ((net_path | abs_path) ("?" query >mark
%uri_query)?);
  absoluteURI    = (scheme >mark %uri_scheme ":" (hier_part |
opaque_part));

  gen_value = (token | host | quoted_string);
  generic_param = (token (EQUAL gen_value)?);
  qvalue = (("0" ("." digit{,3})?) | ("1" ("." ("0"){,3})?));
  accept_param = (("q" EQUAL qvalue) | generic_param);
  media_range = (("*" "/" "*" | ( m_type SLASH "*" ) | ( m_type SLASH
m_subtype )) (SEMI m_parameter)*);
  accept_range = (media_range (SEMI accept_param)*);
  Accept = ("Accept" HCOLON (accept_range (COMMA accept_range)*))?;

  content_coding   = (token);
  codings          = (content_coding | "*");
  encoding         = (codings (SEMI accept_param)*);
  Accept_Encoding  = ("Accept-Encoding" HCOLON (encoding (COMMA
encoding)*)?);

  language_range   = (((alpha{1,8} ("-" alpha{1,8})*) | "*" ));
  language         = (language_range (SEMI accept_param)*);
  Accept_Language  = ("Accept-Language" HCOLON (language (COMMA
language)*)?);

  alert_param      = (LAQUOT absoluteURI RAQUOT (SEMI generic_param
)*);
  Alert_Info       = ("Alert-Info" HCOLON alert_param (COMMA
alert_param)*);

  Allow            = ("Allow" HCOLON (Method (COMMA Method)*)?);

  opaque           = ("opaque" EQUAL quoted_string);
  algorithm        = ("algorithm" EQUAL ("MD5" | "MD5-sess" | token));
  realm_value      = (quoted_string);
  realm            = ("realm" EQUAL realm_value);
  auth_scheme      = (token);
  auth_param_name  = (token);
  auth_param       = (auth_param_name EQUAL (token | quoted_string));
  other_response   = (auth_scheme LWS auth_param (COMMA auth_param)*);
  request_digest   = (LDQUOT LHEX{32} RDQUOT);
  dresponse        = ("response" EQUAL request_digest);
  nonce_value      = (quoted_string);
  nonce            = ("nonce" EQUAL nonce_value);
  nc_value         = (LHEX{8});
  nonce_count      = ("nc" EQUAL nc_value);
  cnonce_value     = (nonce_value);
  cnonce           = ("cnonce" EQUAL cnonce_value);
  qop_value        = ("auth" | "auth-int" | token);
  message_qop      = ("qop" EQUAL qop_value);
  digest_uri_value = (absoluteURI); # fixme
  digest_uri       = ("uri" EQUAL LDQUOT digest_uri_value RDQUOT);
  username_value   = (quoted_string);
  username         = ("username" EQUAL username_value);
  dig_resp         = (username | realm | nonce | digest_uri | dresponse
| algorithm | cnonce | opaque | message_qop | nonce_count |
auth_param);
  digest_response  = (dig_resp (COMMA dig_resp)*);
  credentials      = (("Digest" LWS digest_response) | other_response);
  Authorization    = ("Authorization" HCOLON credentials);

  response_digest      = (LDQUOT LHEX* RDQUOT);
  response_auth        = ("rspauth" EQUAL response_digest);
  nextnonce            = ("nextnonce" EQUAL nonce_value);
  ainfo                = (nextnonce | message_qop | response_auth |
cnonce | nonce_count);
  Authentication_Info  = ("Authentication-Info" HCOLON ainfo (COMMA
ainfo)*);

  callid   =  (word ("@" word)?);
  Call_ID  = (( "Call-ID" | "i" ) HCOLON callid);

  info_param  = (("purpose" EQUAL ("icon" | "info" | "card" | token)) |
generic_param);
  info        = (LAQUOT absoluteURI RAQUOT (SEMI info_param)*);
  Call_Info   = ("Call-Info" HCOLON info (COMMA info)*);

  delta_seconds      = (digit+);
  contact_extension  = (generic_param);
  c_p_expires    = ("expires" EQUAL delta_seconds);
  c_p_q          = ("q" EQUAL qvalue);
  contact_params = (c_p_q | c_p_expires);
  display_name   = ((token LWS)* | quoted_string);
  addr_spec      = (SIP_URI | SIPS_URI | absoluteURI);
  name_addr      = ((display_name)? LAQUOT addr_spec RAQUOT);
  contact_param  = ((name_addr | addr_spec) (SEMI contact_params)*);
  Contact     = (("Contact" | "m" ) HCOLON (STAR | (contact_param
(COMMA contact_param)*)));

  disp_extension_token  = (token);
  other_handling        = (token);
  handling_param        = ("handling" EQUAL ( "optional" | "required" |
other_handling));
  disp_param            = (handling_param | generic_param);
  disp_type             = ("render" | "session" | "icon" | "alert" |
disp_extension_token);
  Content_Disposition   = ("Content-Disposition" HCOLON disp_type (SEMI
disp_param)*);

  Content_Encoding  = (("Content-Encoding" | "e" ) HCOLON
content_coding (COMMA content_coding)*);

  subtag            = (alpha{1,8});
  primary_tag       = (alpha{1,8});
  language_tag      = (primary_tag ("-" subtag)*);
  Content_Language  = ("Content-Language" HCOLON language_tag (COMMA
language_tag)*);

  Content_Length    = (("Content-Length" | "l") HCOLON digit+);

  media_type        = (m_type SLASH m_subtype (SEMI m_parameter)*);
  Content_Type      = (("Content-Type" | "c" ) HCOLON media_type);

  CSeq = ("CSeq" HCOLON digit+ LWS Method);

  message_header = (Accept |
                    Accept_Encoding |
                    Accept_Language |
                    Alert_Info |
                    Allow |
                    Authentication_Info |
                    Authorization |
                    Call_ID |
                    Call_Info |
                    Contact |
                    Content_Disposition |
                    Content_Encoding |
                    Content_Language |
                    Content_Length |
                    Content_Type |
                    CSeq) CRLF;

  SIP_Version    = "SIP" "/" digit "." digit;
  Request_URI    = SIP_URI | SIPS_URI | absoluteURI;
  Request_Line   = Method %create_req SP Request_URI %set_req_uri SP
SIP_Version CRLF;
  Request        = Request_Line (message_header)* CRLF;

main := Request;
}%%

%% write data;
--cut--

I think that problems is somewhere around this line:

hier_part      = ((net_path | abs_path) ("?" query >mark %uri_query)?);

if I remove the ">mark %uri_query" part, ragel is able to complete the
operation.
Can anyone give me some clues what's gone bad?

tia,
d


From thurs... at cs.queensu.ca  Sat Jan 20 22:54:34 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Sat, 20 Jan 2007 17:54:34 -0500 (EST)
Subject: [ragel-users] ragel and memory usage
In-Reply-To: <1169329253.204791.3690@38g2000cwa.googlegroups.com>
References: <1169329253.204791.3690@38g2000cwa.googlegroups.com>
Message-ID: <1837.66.102.71.213.1169333674.squirrel@mambo.cs.queensu.ca>

Hi Damir,

There is likely an ambiguity in there which causes a state explosion. But
since the grammar is so large, trying to track it down is probably not
worth anybody's time. Instead I would suggest starting from scratch and
taking an incremental approach. Start with a simple superset of the
language. For example just separate the request line from the headers and
the message body. Be liberal with actions. Verify that it works properly,
then slowly refine the grammar. If you take this approach and test
frequently you'll easily discover where the ambiguities are because
suddenly things will go way wrong.

-Adrian

>
> Hi all,
>
> I'm trying to build a grammar for parsing SIP messages (as in rfc3261),
> but I have encountered a problem that I cannot solve - it seems that
> I've hit a state explosion, since ragel just keeps allocating memory
> and finally dies.
>
> Here's my grammar (sorry for pasting it here like this)
>
> --cut--
> %%{
>   machine sip_parser;
>
>   action mark
>   {
>   }
>
>   action req_i
>   {
>   }
>
>   action req_a
>   {
>   }
>
>   action req_o
>   {
>   }
>
>   action req_b
>   {
>   }
>
>   action req_c
>   {
>   }
>
>   action req_r
>   {
>   }
>
>   action create_req
>   {
>   }
>
>   action request_method
>   {
>   }
>
>   action uri_host
>   {
>   }
>
>   action done
>   {
>     fbreak;
>   }
>
>   action uri_port
>   {
>   }
>
>   action uri_pass
>   {
>   }
>
>   action uri_user
>   {
>   }
>
>   action uri_scheme
>   {
>   }
>
>   action set_req_uri
>   {
>   }
>
>   action add_param
>   {
>   }
>
>   action add_param_value
>   {
>   }
>
>   action uri_query
>   {
>   }
>
> #### SIP PROTOCOL GRAMMAR
>
>   CRLF = "\r\n";
>   SP = " ";
>   HTAB = "\t";
>   DQUOTE = "\"";
>   LHEX = digit | [a-f];
>
>   alphanum = [a-zA-Z0-9];
>   reserved = (";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" | "$" |
> ",");
>   mark = ("-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")");
>   unreserved = (alphanum | mark);
>   escaped = ("%" xdigit xdigit);
>
>   LWS = ((" "* CRLF)? " "+);
>   SWS = (LWS?);
>
>   HCOLON = ((" " | "\t")* ":" SWS);
>
>   token = (alphanum | "-" | "." | "!" | "%" | "*" | "_" | "+" | "`" |
> "'" | "~" )+;
>   separators = ("(" | ")" | "<" | ">" | "@" | "," | ";" | ":" | "\\" |
> DQUOTE | "/" | "[" | "]" | "?" | "=" | "{" | "}" | SP | HTAB);
>   word = (alphanum | "-" | "." | "!" | "%" | "*" | "_" | "+" | "`" |
> "'" | "~" | "(" | ")" | "<" | ">" | ":" | "\\" | DQUOTE | "/" | "[" |
> "]" | "?" | "{" | "}")+;
>
>   STAR   = (SWS "*" SWS);
>   SLASH  = (SWS "/" SWS);
>   EQUAL  = (SWS "=" SWS);
>   LPAREN = (SWS "(" SWS);
>   RPAREN = (SWS ")" SWS);
>   RAQUOT = (">" SWS);
>   LAQUOT = (SWS "<");
>   COMMA  = (SWS "," SWS);
>   SEMI   = (SWS ";" SWS);
>   COLON  = (SWS ":" SWS);
>   LDQUOT = (SWS DQUOTE);
>   RDQUOT = (DQUOTE SWS);
>
>   qdtext = (LWS | 0x21 | 0x23..0x5B | 0x5D..0x7E);
>   quoted_pair = ("\\" (0x00..0x09 | 0x0B..0x0C | 0x0E..0x7F));
>   quoted_string = (SWS DQUOTE (qdtext | quoted_pair)* DQUOTE);
>   ctext    = (0x21..27 | 0x2A..0x5B | 0x5D..0x7E | LWS);
>   comment_r = (LPAREN? (ctext | quoted_pair) RPAREN?);
>   comment  = (LPAREN (comment_r)* RPAREN);
>
>   port = digit+;
>   IPv4address =  (digit{1,3} "." digit{1,3} "." digit{1,3} "."
> digit{1,3});
>   toplabel = (alpha | (alpha (alphanum | "-")* alphanum));
>   domainlabel = (alphanum | (alphanum (alphanum | "-")* alphanum));
>   hostname = ((domainlabel ".")* toplabel "."?);
>   host = (hostname | IPv4address);
>   hostport = (host >mark %uri_host (":" port >mark %uri_port)?);
>   password = ((unreserved | escaped | "&" | "=" | "+" | "$" | "," )*);
>   user_unreserved = ("&" | "=" | "+" | "$" | "," | ";" | "?" | "/");
>   user = ((unreserved | escaped | user_unreserved)+);
>   userinfo = (user >mark %uri_user (":" password >mark %uri_pass)?
> "@");
>
>   extension_method = token;
>   Method = (("INVITE" %req_i | "ACK" %req_a | "OPTIONS" %req_o | "BYE"
> %req_b | "CANCEL" %req_c | "REGISTER" %req_r | extension_method)) >mark
> %request_method;
>
>   hnv_unreserved = ("[" | "]" | "|" | "?" | ":" | "+" | "$");
>   hvalue = ((hnv_unreserved | unreserved | escaped)*);
>   hname = ((hnv_unreserved | unreserved | escaped)+);
>   header = (hname "=" hvalue);
>   headers = ("?" header ("&" header)*);
>   param_unreserved = ("[" | "]" | "/" | ":" | "&" | "+" | "$");
>   paramchar = (param_unreserved | unreserved | escaped);
>   pvalue = (paramchar+);
>   pname = (paramchar+);
>   other_param = (pname >mark %add_param ("=" pvalue >mark
> %add_param_value)?);
>   lr_param = "lr" >mark %add_param;
>   maddr_param = "maddr" >mark %add_param "=" host >mark
> %add_param_value;
>   method_param = "method" >mark %add_param "=" Method >mark
> %add_param_value;
>   ttl = (digit{1,3});
>   ttl_param = "ttl" >mark %add_param "=" ttl >mark %add_param_value;
>   other_user = token;
>   user_param = "user" >mark %add_param "=" ("phone" | "ip" |
> other_user) >mark %add_param_value;
>   other_transport = token;
>   transport_param = ("transport" >mark %add_param "=" ("udp" | "tcp" |
> "sctp" | "tls" | other_transport) >mark %add_param_value);
>   uri_parameter = (transport_param | user_param | method_param |
> ttl_param | maddr_param | lr_param | other_param);
>   uri_parameters = ((";" uri_parameter)*);
>   SIP_URI = ("sip:" %{ m_data->m_uri.scheme() = "sip"; } (userinfo)?
> hostport uri_parameters (headers)?);
>   SIPS_URI = ("sips:" %{ m_data->m_uri.scheme() = "sips"; } (userinfo)?
> hostport uri_parameters (headers)?);
>
>   x_token = ("x-" token);
>   ietf_token = token;
>   extension_token = (ietf_token | x_token);
>   composite_type = ("message" | "multipart" | extension_token);
>   discrete_type = ("text" | "image" | "audio" | "video" | "application"
> | extension_token);
>   m_type = (discrete_type | composite_type);
>
>   m_value = (token | quoted_string);
>   m_attribute = token;
>   m_parameter = (m_attribute EQUAL m_value);
>   iana_token = token;
>   m_subtype = (extension_token | iana_token);
>
>   uric           = (reserved | unreserved | escaped);
>   query          = (uric*);
>   reg_name       = (unreserved | escaped | "$" | "," | ";" | ":" | "@"
> | "&" | "=" | "+" )+;
>   srvr           = ((userinfo "@")? hostport)?;
>   authority      = (srvr | reg_name);
>   scheme         = (alpha (alpha | digit | "+" | "-" | "." )*);
>   pchar          = (unreserved | escaped | ":" | "@" | "&" | "=" | "+"
> | "$" | ",");
>   param          = (pchar*);
>   segment        = (pchar* (";" param)*);
>   path_segments  = (segment ("/" segment)*);
>   uric_no_slash  = (unreserved | escaped | ";" | "?" | ":" | "@" | "&"
> | "=" | "+" | "$" | ",");
>   opaque_part    = (uric_no_slash uric*);
>   abs_path       = ("/" path_segments);
>   net_path       = ("//" authority (abs_path)?);
>   hier_part      = ((net_path | abs_path) ("?" query >mark
> %uri_query)?);
>   absoluteURI    = (scheme >mark %uri_scheme ":" (hier_part |
> opaque_part));
>
>   gen_value = (token | host | quoted_string);
>   generic_param = (token (EQUAL gen_value)?);
>   qvalue = (("0" ("." digit{,3})?) | ("1" ("." ("0"){,3})?));
>   accept_param = (("q" EQUAL qvalue) | generic_param);
>   media_range = (("*" "/" "*" | ( m_type SLASH "*" ) | ( m_type SLASH
> m_subtype )) (SEMI m_parameter)*);
>   accept_range = (media_range (SEMI accept_param)*);
>   Accept = ("Accept" HCOLON (accept_range (COMMA accept_range)*))?;
>
>   content_coding   = (token);
>   codings          = (content_coding | "*");
>   encoding         = (codings (SEMI accept_param)*);
>   Accept_Encoding  = ("Accept-Encoding" HCOLON (encoding (COMMA
> encoding)*)?);
>
>   language_range   = (((alpha{1,8} ("-" alpha{1,8})*) | "*" ));
>   language         = (language_range (SEMI accept_param)*);
>   Accept_Language  = ("Accept-Language" HCOLON (language (COMMA
> language)*)?);
>
>   alert_param      = (LAQUOT absoluteURI RAQUOT (SEMI generic_param
> )*);
>   Alert_Info       = ("Alert-Info" HCOLON alert_param (COMMA
> alert_param)*);
>
>   Allow            = ("Allow" HCOLON (Method (COMMA Method)*)?);
>
>   opaque           = ("opaque" EQUAL quoted_string);
>   algorithm        = ("algorithm" EQUAL ("MD5" | "MD5-sess" | token));
>   realm_value      = (quoted_string);
>   realm            = ("realm" EQUAL realm_value);
>   auth_scheme      = (token);
>   auth_param_name  = (token);
>   auth_param       = (auth_param_name EQUAL (token | quoted_string));
>   other_response   = (auth_scheme LWS auth_param (COMMA auth_param)*);
>   request_digest   = (LDQUOT LHEX{32} RDQUOT);
>   dresponse        = ("response" EQUAL request_digest);
>   nonce_value      = (quoted_string);
>   nonce            = ("nonce" EQUAL nonce_value);
>   nc_value         = (LHEX{8});
>   nonce_count      = ("nc" EQUAL nc_value);
>   cnonce_value     = (nonce_value);
>   cnonce           = ("cnonce" EQUAL cnonce_value);
>   qop_value        = ("auth" | "auth-int" | token);
>   message_qop      = ("qop" EQUAL qop_value);
>   digest_uri_value = (absoluteURI); # fixme
>   digest_uri       = ("uri" EQUAL LDQUOT digest_uri_value RDQUOT);
>   username_value   = (quoted_string);
>   username         = ("username" EQUAL username_value);
>   dig_resp         = (username | realm | nonce | digest_uri | dresponse
> | algorithm | cnonce | opaque | message_qop | nonce_count |
> auth_param);
>   digest_response  = (dig_resp (COMMA dig_resp)*);
>   credentials      = (("Digest" LWS digest_response) | other_response);
>   Authorization    = ("Authorization" HCOLON credentials);
>
>   response_digest      = (LDQUOT LHEX* RDQUOT);
>   response_auth        = ("rspauth" EQUAL response_digest);
>   nextnonce            = ("nextnonce" EQUAL nonce_value);
>   ainfo                = (nextnonce | message_qop | response_auth |
> cnonce | nonce_count);
>   Authentication_Info  = ("Authentication-Info" HCOLON ainfo (COMMA
> ainfo)*);
>
>   callid   =  (word ("@" word)?);
>   Call_ID  = (( "Call-ID" | "i" ) HCOLON callid);
>
>   info_param  = (("purpose" EQUAL ("icon" | "info" | "card" | token)) |
> generic_param);
>   info        = (LAQUOT absoluteURI RAQUOT (SEMI info_param)*);
>   Call_Info   = ("Call-Info" HCOLON info (COMMA info)*);
>
>   delta_seconds      = (digit+);
>   contact_extension  = (generic_param);
>   c_p_expires    = ("expires" EQUAL delta_seconds);
>   c_p_q          = ("q" EQUAL qvalue);
>   contact_params = (c_p_q | c_p_expires);
>   display_name   = ((token LWS)* | quoted_string);
>   addr_spec      = (SIP_URI | SIPS_URI | absoluteURI);
>   name_addr      = ((display_name)? LAQUOT addr_spec RAQUOT);
>   contact_param  = ((name_addr | addr_spec) (SEMI contact_params)*);
>   Contact     = (("Contact" | "m" ) HCOLON (STAR | (contact_param
> (COMMA contact_param)*)));
>
>   disp_extension_token  = (token);
>   other_handling        = (token);
>   handling_param        = ("handling" EQUAL ( "optional" | "required" |
> other_handling));
>   disp_param            = (handling_param | generic_param);
>   disp_type             = ("render" | "session" | "icon" | "alert" |
> disp_extension_token);
>   Content_Disposition   = ("Content-Disposition" HCOLON disp_type (SEMI
> disp_param)*);
>
>   Content_Encoding  = (("Content-Encoding" | "e" ) HCOLON
> content_coding (COMMA content_coding)*);
>
>   subtag            = (alpha{1,8});
>   primary_tag       = (alpha{1,8});
>   language_tag      = (primary_tag ("-" subtag)*);
>   Content_Language  = ("Content-Language" HCOLON language_tag (COMMA
> language_tag)*);
>
>   Content_Length    = (("Content-Length" | "l") HCOLON digit+);
>
>   media_type        = (m_type SLASH m_subtype (SEMI m_parameter)*);
>   Content_Type      = (("Content-Type" | "c" ) HCOLON media_type);
>
>   CSeq = ("CSeq" HCOLON digit+ LWS Method);
>
>   message_header = (Accept |
>                     Accept_Encoding |
>                     Accept_Language |
>                     Alert_Info |
>                     Allow |
>                     Authentication_Info |
>                     Authorization |
>                     Call_ID |
>                     Call_Info |
>                     Contact |
>                     Content_Disposition |
>                     Content_Encoding |
>                     Content_Language |
>                     Content_Length |
>                     Content_Type |
>                     CSeq) CRLF;
>
>   SIP_Version    = "SIP" "/" digit "." digit;
>   Request_URI    = SIP_URI | SIPS_URI | absoluteURI;
>   Request_Line   = Method %create_req SP Request_URI %set_req_uri SP
> SIP_Version CRLF;
>   Request        = Request_Line (message_header)* CRLF;
>
> main := Request;
> }%%
>
> %% write data;
> --cut--
>
> I think that problems is somewhere around this line:
>
> hier_part      = ((net_path | abs_path) ("?" query >mark %uri_query)?);
>
> if I remove the ">mark %uri_query" part, ragel is able to complete the
> operation.
> Can anyone give me some clues what's gone bad?
>
> tia,
> d
>
>
> >



From thurs... at cs.queensu.ca  Sun Jan 21 06:00:15 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Sun, 21 Jan 2007 01:00:15 -0500 (EST)
Subject: [ragel-users] ragel and memory usage
In-Reply-To: <1169329253.204791.3690@38g2000cwa.googlegroups.com>
References: <1169329253.204791.3690@38g2000cwa.googlegroups.com>
Message-ID: <1157.66.102.72.164.1169359215.squirrel@mambo.cs.queensu.ca>

Hi, sorry I didn't notice the message text at the bottom. I'll have a look
at it to find out why it fails when adding the actions mentioned.

-Adrian


> Hi all,
>
> I'm trying to build a grammar for parsing SIP messages (as in rfc3261),
> but I have encountered a problem that I cannot solve - it seems that
> I've hit a state explosion, since ragel just keeps allocating memory
> and finally dies.
>
> Here's my grammar (sorry for pasting it here like this)
>
> --cut--
> %%{
>   machine sip_parser;
>
>   action mark
>   {
>   }
>
>   action req_i
>   {
>   }
>
>   action req_a
>   {
>   }
>
>   action req_o
>   {
>   }
>
>   action req_b
>   {
>   }
>
>   action req_c
>   {
>   }
>
>   action req_r
>   {
>   }
>
>   action create_req
>   {
>   }
>
>   action request_method
>   {
>   }
>
>   action uri_host
>   {
>   }
>
>   action done
>   {
>     fbreak;
>   }
>
>   action uri_port
>   {
>   }
>
>   action uri_pass
>   {
>   }
>
>   action uri_user
>   {
>   }
>
>   action uri_scheme
>   {
>   }
>
>   action set_req_uri
>   {
>   }
>
>   action add_param
>   {
>   }
>
>   action add_param_value
>   {
>   }
>
>   action uri_query
>   {
>   }
>
> #### SIP PROTOCOL GRAMMAR
>
>   CRLF = "\r\n";
>   SP = " ";
>   HTAB = "\t";
>   DQUOTE = "\"";
>   LHEX = digit | [a-f];
>
>   alphanum = [a-zA-Z0-9];
>   reserved = (";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" | "$" |
> ",");
>   mark = ("-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")");
>   unreserved = (alphanum | mark);
>   escaped = ("%" xdigit xdigit);
>
>   LWS = ((" "* CRLF)? " "+);
>   SWS = (LWS?);
>
>   HCOLON = ((" " | "\t")* ":" SWS);
>
>   token = (alphanum | "-" | "." | "!" | "%" | "*" | "_" | "+" | "`" |
> "'" | "~" )+;
>   separators = ("(" | ")" | "<" | ">" | "@" | "," | ";" | ":" | "\\" |
> DQUOTE | "/" | "[" | "]" | "?" | "=" | "{" | "}" | SP | HTAB);
>   word = (alphanum | "-" | "." | "!" | "%" | "*" | "_" | "+" | "`" |
> "'" | "~" | "(" | ")" | "<" | ">" | ":" | "\\" | DQUOTE | "/" | "[" |
> "]" | "?" | "{" | "}")+;
>
>   STAR   = (SWS "*" SWS);
>   SLASH  = (SWS "/" SWS);
>   EQUAL  = (SWS "=" SWS);
>   LPAREN = (SWS "(" SWS);
>   RPAREN = (SWS ")" SWS);
>   RAQUOT = (">" SWS);
>   LAQUOT = (SWS "<");
>   COMMA  = (SWS "," SWS);
>   SEMI   = (SWS ";" SWS);
>   COLON  = (SWS ":" SWS);
>   LDQUOT = (SWS DQUOTE);
>   RDQUOT = (DQUOTE SWS);
>
>   qdtext = (LWS | 0x21 | 0x23..0x5B | 0x5D..0x7E);
>   quoted_pair = ("\\" (0x00..0x09 | 0x0B..0x0C | 0x0E..0x7F));
>   quoted_string = (SWS DQUOTE (qdtext | quoted_pair)* DQUOTE);
>   ctext    = (0x21..27 | 0x2A..0x5B | 0x5D..0x7E | LWS);
>   comment_r = (LPAREN? (ctext | quoted_pair) RPAREN?);
>   comment  = (LPAREN (comment_r)* RPAREN);
>
>   port = digit+;
>   IPv4address =  (digit{1,3} "." digit{1,3} "." digit{1,3} "."
> digit{1,3});
>   toplabel = (alpha | (alpha (alphanum | "-")* alphanum));
>   domainlabel = (alphanum | (alphanum (alphanum | "-")* alphanum));
>   hostname = ((domainlabel ".")* toplabel "."?);
>   host = (hostname | IPv4address);
>   hostport = (host >mark %uri_host (":" port >mark %uri_port)?);
>   password = ((unreserved | escaped | "&" | "=" | "+" | "$" | "," )*);
>   user_unreserved = ("&" | "=" | "+" | "$" | "," | ";" | "?" | "/");
>   user = ((unreserved | escaped | user_unreserved)+);
>   userinfo = (user >mark %uri_user (":" password >mark %uri_pass)?
> "@");
>
>   extension_method = token;
>   Method = (("INVITE" %req_i | "ACK" %req_a | "OPTIONS" %req_o | "BYE"
> %req_b | "CANCEL" %req_c | "REGISTER" %req_r | extension_method)) >mark
> %request_method;
>
>   hnv_unreserved = ("[" | "]" | "|" | "?" | ":" | "+" | "$");
>   hvalue = ((hnv_unreserved | unreserved | escaped)*);
>   hname = ((hnv_unreserved | unreserved | escaped)+);
>   header = (hname "=" hvalue);
>   headers = ("?" header ("&" header)*);
>   param_unreserved = ("[" | "]" | "/" | ":" | "&" | "+" | "$");
>   paramchar = (param_unreserved | unreserved | escaped);
>   pvalue = (paramchar+);
>   pname = (paramchar+);
>   other_param = (pname >mark %add_param ("=" pvalue >mark
> %add_param_value)?);
>   lr_param = "lr" >mark %add_param;
>   maddr_param = "maddr" >mark %add_param "=" host >mark
> %add_param_value;
>   method_param = "method" >mark %add_param "=" Method >mark
> %add_param_value;
>   ttl = (digit{1,3});
>   ttl_param = "ttl" >mark %add_param "=" ttl >mark %add_param_value;
>   other_user = token;
>   user_param = "user" >mark %add_param "=" ("phone" | "ip" |
> other_user) >mark %add_param_value;
>   other_transport = token;
>   transport_param = ("transport" >mark %add_param "=" ("udp" | "tcp" |
> "sctp" | "tls" | other_transport) >mark %add_param_value);
>   uri_parameter = (transport_param | user_param | method_param |
> ttl_param | maddr_param | lr_param | other_param);
>   uri_parameters = ((";" uri_parameter)*);
>   SIP_URI = ("sip:" %{ m_data->m_uri.scheme() = "sip"; } (userinfo)?
> hostport uri_parameters (headers)?);
>   SIPS_URI = ("sips:" %{ m_data->m_uri.scheme() = "sips"; } (userinfo)?
> hostport uri_parameters (headers)?);
>
>   x_token = ("x-" token);
>   ietf_token = token;
>   extension_token = (ietf_token | x_token);
>   composite_type = ("message" | "multipart" | extension_token);
>   discrete_type = ("text" | "image" | "audio" | "video" | "application"
> | extension_token);
>   m_type = (discrete_type | composite_type);
>
>   m_value = (token | quoted_string);
>   m_attribute = token;
>   m_parameter = (m_attribute EQUAL m_value);
>   iana_token = token;
>   m_subtype = (extension_token | iana_token);
>
>   uric           = (reserved | unreserved | escaped);
>   query          = (uric*);
>   reg_name       = (unreserved | escaped | "$" | "," | ";" | ":" | "@"
> | "&" | "=" | "+" )+;
>   srvr           = ((userinfo "@")? hostport)?;
>   authority      = (srvr | reg_name);
>   scheme         = (alpha (alpha | digit | "+" | "-" | "." )*);
>   pchar          = (unreserved | escaped | ":" | "@" | "&" | "=" | "+"
> | "$" | ",");
>   param          = (pchar*);
>   segment        = (pchar* (";" param)*);
>   path_segments  = (segment ("/" segment)*);
>   uric_no_slash  = (unreserved | escaped | ";" | "?" | ":" | "@" | "&"
> | "=" | "+" | "$" | ",");
>   opaque_part    = (uric_no_slash uric*);
>   abs_path       = ("/" path_segments);
>   net_path       = ("//" authority (abs_path)?);
>   hier_part      = ((net_path | abs_path) ("?" query >mark
> %uri_query)?);
>   absoluteURI    = (scheme >mark %uri_scheme ":" (hier_part |
> opaque_part));
>
>   gen_value = (token | host | quoted_string);
>   generic_param = (token (EQUAL gen_value)?);
>   qvalue = (("0" ("." digit{,3})?) | ("1" ("." ("0"){,3})?));
>   accept_param = (("q" EQUAL qvalue) | generic_param);
>   media_range = (("*" "/" "*" | ( m_type SLASH "*" ) | ( m_type SLASH
> m_subtype )) (SEMI m_parameter)*);
>   accept_range = (media_range (SEMI accept_param)*);
>   Accept = ("Accept" HCOLON (accept_range (COMMA accept_range)*))?;
>
>   content_coding   = (token);
>   codings          = (content_coding | "*");
>   encoding         = (codings (SEMI accept_param)*);
>   Accept_Encoding  = ("Accept-Encoding" HCOLON (encoding (COMMA
> encoding)*)?);
>
>   language_range   = (((alpha{1,8} ("-" alpha{1,8})*) | "*" ));
>   language         = (language_range (SEMI accept_param)*);
>   Accept_Language  = ("Accept-Language" HCOLON (language (COMMA
> language)*)?);
>
>   alert_param      = (LAQUOT absoluteURI RAQUOT (SEMI generic_param
> )*);
>   Alert_Info       = ("Alert-Info" HCOLON alert_param (COMMA
> alert_param)*);
>
>   Allow            = ("Allow" HCOLON (Method (COMMA Method)*)?);
>
>   opaque           = ("opaque" EQUAL quoted_string);
>   algorithm        = ("algorithm" EQUAL ("MD5" | "MD5-sess" | token));
>   realm_value      = (quoted_string);
>   realm            = ("realm" EQUAL realm_value);
>   auth_scheme      = (token);
>   auth_param_name  = (token);
>   auth_param       = (auth_param_name EQUAL (token | quoted_string));
>   other_response   = (auth_scheme LWS auth_param (COMMA auth_param)*);
>   request_digest   = (LDQUOT LHEX{32} RDQUOT);
>   dresponse        = ("response" EQUAL request_digest);
>   nonce_value      = (quoted_string);
>   nonce            = ("nonce" EQUAL nonce_value);
>   nc_value         = (LHEX{8});
>   nonce_count      = ("nc" EQUAL nc_value);
>   cnonce_value     = (nonce_value);
>   cnonce           = ("cnonce" EQUAL cnonce_value);
>   qop_value        = ("auth" | "auth-int" | token);
>   message_qop      = ("qop" EQUAL qop_value);
>   digest_uri_value = (absoluteURI); # fixme
>   digest_uri       = ("uri" EQUAL LDQUOT digest_uri_value RDQUOT);
>   username_value   = (quoted_string);
>   username         = ("username" EQUAL username_value);
>   dig_resp         = (username | realm | nonce | digest_uri | dresponse
> | algorithm | cnonce | opaque | message_qop | nonce_count |
> auth_param);
>   digest_response  = (dig_resp (COMMA dig_resp)*);
>   credentials      = (("Digest" LWS digest_response) | other_response);
>   Authorization    = ("Authorization" HCOLON credentials);
>
>   response_digest      = (LDQUOT LHEX* RDQUOT);
>   response_auth        = ("rspauth" EQUAL response_digest);
>   nextnonce            = ("nextnonce" EQUAL nonce_value);
>   ainfo                = (nextnonce | message_qop | response_auth |
> cnonce | nonce_count);
>   Authentication_Info  = ("Authentication-Info" HCOLON ainfo (COMMA
> ainfo)*);
>
>   callid   =  (word ("@" word)?);
>   Call_ID  = (( "Call-ID" | "i" ) HCOLON callid);
>
>   info_param  = (("purpose" EQUAL ("icon" | "info" | "card" | token)) |
> generic_param);
>   info        = (LAQUOT absoluteURI RAQUOT (SEMI info_param)*);
>   Call_Info   = ("Call-Info" HCOLON info (COMMA info)*);
>
>   delta_seconds      = (digit+);
>   contact_extension  = (generic_param);
>   c_p_expires    = ("expires" EQUAL delta_seconds);
>   c_p_q          = ("q" EQUAL qvalue);
>   contact_params = (c_p_q | c_p_expires);
>   display_name   = ((token LWS)* | quoted_string);
>   addr_spec      = (SIP_URI | SIPS_URI | absoluteURI);
>   name_addr      = ((display_name)? LAQUOT addr_spec RAQUOT);
>   contact_param  = ((name_addr | addr_spec) (SEMI contact_params)*);
>   Contact     = (("Contact" | "m" ) HCOLON (STAR | (contact_param
> (COMMA contact_param)*)));
>
>   disp_extension_token  = (token);
>   other_handling        = (token);
>   handling_param        = ("handling" EQUAL ( "optional" | "required" |
> other_handling));
>   disp_param            = (handling_param | generic_param);
>   disp_type             = ("render" | "session" | "icon" | "alert" |
> disp_extension_token);
>   Content_Disposition   = ("Content-Disposition" HCOLON disp_type (SEMI
> disp_param)*);
>
>   Content_Encoding  = (("Content-Encoding" | "e" ) HCOLON
> content_coding (COMMA content_coding)*);
>
>   subtag            = (alpha{1,8});
>   primary_tag       = (alpha{1,8});
>   language_tag      = (primary_tag ("-" subtag)*);
>   Content_Language  = ("Content-Language" HCOLON language_tag (COMMA
> language_tag)*);
>
>   Content_Length    = (("Content-Length" | "l") HCOLON digit+);
>
>   media_type        = (m_type SLASH m_subtype (SEMI m_parameter)*);
>   Content_Type      = (("Content-Type" | "c" ) HCOLON media_type);
>
>   CSeq = ("CSeq" HCOLON digit+ LWS Method);
>
>   message_header = (Accept |
>                     Accept_Encoding |
>                     Accept_Language |
>                     Alert_Info |
>                     Allow |
>                     Authentication_Info |
>                     Authorization |
>                     Call_ID |
>                     Call_Info |
>                     Contact |
>                     Content_Disposition |
>                     Content_Encoding |
>                     Content_Language |
>                     Content_Length |
>                     Content_Type |
>                     CSeq) CRLF;
>
>   SIP_Version    = "SIP" "/" digit "." digit;
>   Request_URI    = SIP_URI | SIPS_URI | absoluteURI;
>   Request_Line   = Method %create_req SP Request_URI %set_req_uri SP
> SIP_Version CRLF;
>   Request        = Request_Line (message_header)* CRLF;
>
> main := Request;
> }%%
>
> %% write data;
> --cut--
>
> I think that problems is somewhere around this line:
>
> hier_part      = ((net_path | abs_path) ("?" query >mark %uri_query)?);
>
> if I remove the ">mark %uri_query" part, ragel is able to complete the
> operation.
> Can anyone give me some clues what's gone bad?
>
> tia,
> d
>
>
> >



From dam... at gmail.com  Sun Jan 21 13:58:32 2007
From: dam... at gmail.com (Damir Nedzibovic)
Date: Sun, 21 Jan 2007 13:58:32 -0000
Subject: ragel and memory usage
In-Reply-To: <1157.66.102.72.164.1169359215.squirrel@mambo.cs.queensu.ca>
References: <1169329253.204791.3690@38g2000cwa.googlegroups.com>
   <1157.66.102.72.164.1169359215.squirrel@mambo.cs.queensu.ca>
Message-ID: <1169387912.529683.254540@51g2000cwl.googlegroups.com>

Hi Adrian,

thanks for your help - I managed to isolate the ambiguity in my grammar
and even to refine it a bit. It works much better now.

Once I finish the complete grammar I'll post it here, maybe somebody
else will find it useful

thanks,
d

On Jan 21, 7:00 am, "Adrian Thurston" <thurs... at cs.queensu.ca> wrote:
> Hi, sorry I didn't notice the message text at the bottom. I'll have a look
> at it to find out why it fails when adding the actions mentioned.
>
> -Adrian
>
> > Hi all,
>
> > I'm trying to build a grammar for parsing SIP messages (as in rfc3261),
> > but I have encountered a problem that I cannot solve - it seems that
> > I've hit a state explosion, since ragel just keeps allocating memory
> > and finally dies.
>
> > Here's my grammar (sorry for pasting it here like this)
>
> > --cut--
> > %%{
> >   machine sip_parser;
>
> >   action mark
> >   {
> >   }
>
> >   action req_i
> >   {
> >   }
>
> >   action req_a
> >   {
> >   }
>
> >   action req_o
> >   {
> >   }
>
> >   action req_b
> >   {
> >   }
>
> >   action req_c
> >   {
> >   }
>
> >   action req_r
> >   {
> >   }
>
> >   action create_req
> >   {
> >   }
>
> >   action request_method
> >   {
> >   }
>
> >   action uri_host
> >   {
> >   }
>
> >   action done
> >   {
> >     fbreak;
> >   }
>
> >   action uri_port
> >   {
> >   }
>
> >   action uri_pass
> >   {
> >   }
>
> >   action uri_user
> >   {
> >   }
>
> >   action uri_scheme
> >   {
> >   }
>
> >   action set_req_uri
> >   {
> >   }
>
> >   action add_param
> >   {
> >   }
>
> >   action add_param_value
> >   {
> >   }
>
> >   action uri_query
> >   {
> >   }
>
> > #### SIP PROTOCOL GRAMMAR
>
> >   CRLF = "\r\n";
> >   SP = " ";
> >   HTAB = "\t";
> >   DQUOTE = "\"";
> >   LHEX = digit | [a-f];
>
> >   alphanum = [a-zA-Z0-9];
> >   reserved = (";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" | "$" |
> > ",");
> >   mark = ("-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")");
> >   unreserved = (alphanum | mark);
> >   escaped = ("%" xdigit xdigit);
>
> >   LWS = ((" "* CRLF)? " "+);
> >   SWS = (LWS?);
>
> >   HCOLON = ((" " | "\t")* ":" SWS);
>
> >   token = (alphanum | "-" | "." | "!" | "%" | "*" | "_" | "+" | "`" |
> > "'" | "~" )+;
> >   separators = ("(" | ")" | "<" | ">" | "@" | "," | ";" | ":" | "\\" |
> > DQUOTE | "/" | "[" | "]" | "?" | "=" | "{" | "}" | SP | HTAB);
> >   word = (alphanum | "-" | "." | "!" | "%" | "*" | "_" | "+" | "`" |
> > "'" | "~" | "(" | ")" | "<" | ">" | ":" | "\\" | DQUOTE | "/" | "[" |
> > "]" | "?" | "{" | "}")+;
>
> >   STAR   = (SWS "*" SWS);
> >   SLASH  = (SWS "/" SWS);
> >   EQUAL  = (SWS "=" SWS);
> >   LPAREN = (SWS "(" SWS);
> >   RPAREN = (SWS ")" SWS);
> >   RAQUOT = (">" SWS);
> >   LAQUOT = (SWS "<");
> >   COMMA  = (SWS "," SWS);
> >   SEMI   = (SWS ";" SWS);
> >   COLON  = (SWS ":" SWS);
> >   LDQUOT = (SWS DQUOTE);
> >   RDQUOT = (DQUOTE SWS);
>
> >   qdtext = (LWS | 0x21 | 0x23..0x5B | 0x5D..0x7E);
> >   quoted_pair = ("\\" (0x00..0x09 | 0x0B..0x0C | 0x0E..0x7F));
> >   quoted_string = (SWS DQUOTE (qdtext | quoted_pair)* DQUOTE);
> >   ctext    = (0x21..27 | 0x2A..0x5B | 0x5D..0x7E | LWS);
> >   comment_r = (LPAREN? (ctext | quoted_pair) RPAREN?);
> >   comment  = (LPAREN (comment_r)* RPAREN);
>
> >   port = digit+;
> >   IPv4address =  (digit{1,3} "." digit{1,3} "." digit{1,3} "."
> > digit{1,3});
> >   toplabel = (alpha | (alpha (alphanum | "-")* alphanum));
> >   domainlabel = (alphanum | (alphanum (alphanum | "-")* alphanum));
> >   hostname = ((domainlabel ".")* toplabel "."?);
> >   host = (hostname | IPv4address);
> >   hostport = (host >mark %uri_host (":" port >mark %uri_port)?);
> >   password = ((unreserved | escaped | "&" | "=" | "+" | "$" | "," )*);
> >   user_unreserved = ("&" | "=" | "+" | "$" | "," | ";" | "?" | "/");
> >   user = ((unreserved | escaped | user_unreserved)+);
> >   userinfo = (user >mark %uri_user (":" password >mark %uri_pass)?
> > "@");
>
> >   extension_method = token;
> >   Method = (("INVITE" %req_i | "ACK" %req_a | "OPTIONS" %req_o | "BYE"
> > %req_b | "CANCEL" %req_c | "REGISTER" %req_r | extension_method)) >mark
> > %request_method;
>
> >   hnv_unreserved = ("[" | "]" | "|" | "?" | ":" | "+" | "$");
> >   hvalue = ((hnv_unreserved | unreserved | escaped)*);
> >   hname = ((hnv_unreserved | unreserved | escaped)+);
> >   header = (hname "=" hvalue);
> >   headers = ("?" header ("&" header)*);
> >   param_unreserved = ("[" | "]" | "/" | ":" | "&" | "+" | "$");
> >   paramchar = (param_unreserved | unreserved | escaped);
> >   pvalue = (paramchar+);
> >   pname = (paramchar+);
> >   other_param = (pname >mark %add_param ("=" pvalue >mark
> > %add_param_value)?);
> >   lr_param = "lr" >mark %add_param;
> >   maddr_param = "maddr" >mark %add_param "=" host >mark
> > %add_param_value;
> >   method_param = "method" >mark %add_param "=" Method >mark
> > %add_param_value;
> >   ttl = (digit{1,3});
> >   ttl_param = "ttl" >mark %add_param "=" ttl >mark %add_param_value;
> >   other_user = token;
> >   user_param = "user" >mark %add_param "=" ("phone" | "ip" |
> > other_user) >mark %add_param_value;
> >   other_transport = token;
> >   transport_param = ("transport" >mark %add_param "=" ("udp" | "tcp" |
> > "sctp" | "tls" | other_transport) >mark %add_param_value);
> >   uri_parameter = (transport_param | user_param | method_param |
> > ttl_param | maddr_param | lr_param | other_param);
> >   uri_parameters = ((";" uri_parameter)*);
> >   SIP_URI = ("sip:" %{ m_data->m_uri.scheme() = "sip"; } (userinfo)?
> > hostport uri_parameters (headers)?);
> >   SIPS_URI = ("sips:" %{ m_data->m_uri.scheme() = "sips"; } (userinfo)?
> > hostport uri_parameters (headers)?);
>
> >   x_token = ("x-" token);
> >   ietf_token = token;
> >   extension_token = (ietf_token | x_token);
> >   composite_type = ("message" | "multipart" | extension_token);
> >   discrete_type = ("text" | "image" | "audio" | "video" | "application"
> > | extension_token);
> >   m_type = (discrete_type | composite_type);
>
> >   m_value = (token | quoted_string);
> >   m_attribute = token;
> >   m_parameter = (m_attribute EQUAL m_value);
> >   iana_token = token;
> >   m_subtype = (extension_token | iana_token);
>
> >   uric           = (reserved | unreserved | escaped);
> >   query          = (uric*);
> >   reg_name       = (unreserved | escaped | "$" | "," | ";" | ":" | "@"
> > | "&" | "=" | "+" )+;
> >   srvr           = ((userinfo "@")? hostport)?;
> >   authority      = (srvr | reg_name);
> >   scheme         = (alpha (alpha | digit | "+" | "-" | "." )*);
> >   pchar          = (unreserved | escaped | ":" | "@" | "&" | "=" | "+"
> > | "$" | ",");
> >   param          = (pchar*);
> >   segment        = (pchar* (";" param)*);
> >   path_segments  = (segment ("/" segment)*);
> >   uric_no_slash  = (unreserved | escaped | ";" | "?" | ":" | "@" | "&"
> > | "=" | "+" | "$" | ",");
> >   opaque_part    = (uric_no_slash uric*);
> >   abs_path       = ("/" path_segments);
> >   net_path       = ("//" authority (abs_path)?);
> >   hier_part      = ((net_path | abs_path) ("?" query >mark
> > %uri_query)?);
> >   absoluteURI    = (scheme >mark %uri_scheme ":" (hier_part |
> > opaque_part));
>
> >   gen_value = (token | host | quoted_string);
> >   generic_param = (token (EQUAL gen_value)?);
> >   qvalue = (("0" ("." digit{,3})?) | ("1" ("." ("0"){,3})?));
> >   accept_param = (("q" EQUAL qvalue) | generic_param);
> >   media_range = (("*" "/" "*" | ( m_type SLASH "*" ) | ( m_type SLASH
> > m_subtype )) (SEMI m_parameter)*);
> >   accept_range = (media_range (SEMI accept_param)*);
> >   Accept = ("Accept" HCOLON (accept_range (COMMA accept_range)*))?;
>
> >   content_coding   = (token);
> >   codings          = (content_coding | "*");
> >   encoding         = (codings (SEMI accept_param)*);
> >   Accept_Encoding  = ("Accept-Encoding" HCOLON (encoding (COMMA
> > encoding)*)?);
>
> >   language_range   = (((alpha{1,8} ("-" alpha{1,8})*) | "*" ));
> >   language         = (language_range (SEMI accept_param)*);
> >   Accept_Language  = ("Accept-Language" HCOLON (language (COMMA
> > language)*)?);
>
> >   alert_param      = (LAQUOT absoluteURI RAQUOT (SEMI generic_param
> > )*);
> >   Alert_Info       = ("Alert-Info" HCOLON alert_param (COMMA
> > alert_param)*);
>
> >   Allow            = ("Allow" HCOLON (Method (COMMA Method)*)?);
>
> >   opaque           = ("opaque" EQUAL quoted_string);
> >   algorithm        = ("algorithm" EQUAL ("MD5" | "MD5-sess" | token));
> >   realm_value      = (quoted_string);
> >   realm            = ("realm" EQUAL realm_value);
> >   auth_scheme      = (token);
> >   auth_param_name  = (token);
> >   auth_param       = (auth_param_name EQUAL (token | quoted_string));
> >   other_response   = (auth_scheme LWS auth_param (COMMA auth_param)*);
> >   request_digest   = (LDQUOT LHEX{32} RDQUOT);
> >   dresponse        = ("response" EQUAL request_digest);
> >   nonce_value      = (quoted_string);
> >   nonce            = ("nonce" EQUAL nonce_value);
> >   nc_value         = (LHEX{8});
> >   nonce_count      = ("nc" EQUAL nc_value);
> >   cnonce_value     = (nonce_value);
> >   cnonce           = ("cnonce" EQUAL cnonce_value);
> >   qop_value        = ("auth" | "auth-int" | token);
> >   message_qop      = ("qop" EQUAL qop_value);
> >   digest_uri_value = (absoluteURI); # fixme
> >   digest_uri       = ("uri" EQUAL LDQUOT digest_uri_value RDQUOT);
> >   username_value   = (quoted_string);
> >   username         = ("username" EQUAL username_value);
> >   dig_resp         = (username | realm | nonce | digest_uri | dresponse
> > | algorithm | cnonce | opaque | message_qop | nonce_count |
> > auth_param);
> >   digest_response  = (dig_resp (COMMA dig_resp)*);
> >   credentials      = (("Digest" LWS digest_response) | other_response);
> >   Authorization    = ("Authorization" HCOLON credentials);
>
> >   response_digest      = (LDQUOT LHEX* RDQUOT);
> >   response_auth        = ("rspauth" EQUAL response_digest);
> >   nextnonce            = ("nextnonce" EQUAL nonce_value);
> >   ainfo                = (nextnonce | message_qop | response_auth |
> > cnonce | nonce_count);
> >   Authentication_Info  = ("Authentication-Info" HCOLON ainfo (COMMA
> > ainfo)*);
>
> >   callid   =  (word ("@" word)?);
> >   Call_ID  = (( "Call-ID" | "i" ) HCOLON callid);
>
> >   info_param  = (("purpose" EQUAL ("icon" | "info" | "card" | token)) |
> > generic_param);
> >   info        = (LAQUOT absoluteURI RAQUOT (SEMI info_param)*);
> >   Call_Info   = ("Call-Info" HCOLON info (COMMA info)*);
>
> >   delta_seconds      = (digit+);
> >   contact_extension  = (generic_param);
> >   c_p_expires    = ("expires" EQUAL delta_seconds);
> >   c_p_q          = ("q" EQUAL qvalue);
> >   contact_params = (c_p_q | c_p_expires);
> >   display_name   = ((token LWS)* | quoted_string);
> >   addr_spec    ...
> 
> read more »


From thurs... at cs.queensu.ca  Mon Jan 22 04:53:40 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Sun, 21 Jan 2007 23:53:40 -0500 (EST)
Subject: [ragel-users] Re: ragel and memory usage
In-Reply-To: <1169387912.529683.254540@51g2000cwl.googlegroups.com>
References: <1169329253.204791.3690@38g2000cwa.googlegroups.com>
    <1157.66.102.72.164.1169359215.squirrel@mambo.cs.queensu.ca>
    <1169387912.529683.254540@51g2000cwl.googlegroups.com>
Message-ID: <3279.66.102.72.38.1169441620.squirrel@mambo.cs.queensu.ca>


> Once I finish the complete grammar I'll post it here, maybe somebody
> else will find it useful

That would be great! I heard from at least one other person using Ragel
for parsing SIP. Also, it would be a good grammar for profiling Ragel.

Cheers,
 Adrian


From dam... at gmail.com  Mon Jan 22 14:03:02 2007
From: dam... at gmail.com (Damir Nedzibovic)
Date: Mon, 22 Jan 2007 14:03:02 -0000
Subject: ragel and memory usage
In-Reply-To: <3279.66.102.72.38.1169441620.squirrel@mambo.cs.queensu.ca>
References: <1169329253.204791.3690@38g2000cwa.googlegroups.com>
   <1157.66.102.72.164.1169359215.squirrel@mambo.cs.queensu.ca>
   <1169387912.529683.254540@51g2000cwl.googlegroups.com>
   <3279.66.102.72.38.1169441620.squirrel@mambo.cs.queensu.ca>
Message-ID: <1169474582.584908.99340@l53g2000cwa.googlegroups.com>

Hi Adrian,

it seems that I wasn't able to remove the ambiguity after all :-(

I managed to further isolate the problem, I think:

if I replace this line

contact_param  = ((name_addr | addr_spec) (SEMI contact_params)*);

with

contact_param  = ((name_addr ) (SEMI contact_params)*);

the problem goes away, and ragel is able to complete the task.

I'm pretty much clues at this point...

thanks,
d


From thurs... at cs.queensu.ca  Mon Jan 22 16:45:26 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Mon, 22 Jan 2007 11:45:26 -0500
Subject: [ragel-users] Re: ragel and memory usage
In-Reply-To: <1169474582.584908.99340@l53g2000cwa.googlegroups.com>
References: <1169329253.204791.3690@38g2000cwa.googlegroups.com> <1157.66.102.72.164.1169359215.squirrel@mambo.cs.queensu.ca> <1169387912.529683.254540@51g2000cwl.googlegroups.com> <3279.66.102.72.38.1169441620.squirrel@mambo.cs.queensu.ca> <1169474582.584908.99340@l53g2000cwa.googlegroups.com>
Message-ID: <45B4EA26.1000803@cs.queensu.ca>

Hi Damir,

If you run

ragel -M contact_param -s memory.rl >memory.xml

And then look at the XML file you'll see that there are several final states
with transitions on ',' (44) in them. They seem to come from URIs. This is a
problem for making a comma-separated list of contact_param. You need to
exclude the comma if you want to make an unambiguous list.

Contact = (("Contact" | "m" ) HCOLON
    (STAR | (contact_param (COMMA contact_param)*)));

You should probably see what the RFC has to say, but if you want a quick fix
you can resolve the ambiguity explicitly using priorities. This resolution
favours the the COMMA which separates items.

COMMA_pri = (SWS "," @(contact_COMMA, 1) SWS);
contact_param_pri = contact_param $(contact_COMMA, 0);

Contact = ( ( "Contact" | "m" ) HCOLON (STAR |
    (contact_param_pri (COMMA_pri contact_param_pri)*)));

You can also resolve the ambiguity by making a new version of contact_param
that does not have any commas. This can be done with "strong subtraction"
(see the manual).

contact_param_nocomma = contact_param -- ",";

To get a feel for what is going on here play around with a mini-version of
your parser and look at the graphviz output.

action in {}
action all {}
action out {}

sym = "+" | "-" | ",";
word = ( [a-z] | sym )+ >in $all %out;

WS = ' ';
COMMA = WS* "," @1 WS*;

word_lowpri = word $(COMMA,0);
word_nocomma = word -- ',';

main := ':' word_nocomma (COMMA word_nocomma)*;

Cheers,
 Adrian

Damir Nedzibovic wrote:
> Hi Adrian,
> 
> it seems that I wasn't able to remove the ambiguity after all :-(
> 
> I managed to further isolate the problem, I think:
> 
> if I replace this line
> 
> contact_param  = ((name_addr | addr_spec) (SEMI contact_params)*);
> 
> with
> 
> contact_param  = ((name_addr ) (SEMI contact_params)*);
> 
> the problem goes away, and ragel is able to complete the task.
> 
> I'm pretty much clues at this point...
> 
> thanks,
> d
> 
> 
> 


From thurs... at cs.queensu.ca  Tue Jan 23 05:15:09 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Tue, 23 Jan 2007 00:15:09 -0500
Subject: need help testing
Message-ID: <45B599DD.1010202@cs.queensu.ca>

Hi, the holdup over the rewrite of the parsers is almost over. But 
before I do a release ... I've changed a lot of code and there is a 
pretty good chance I broke something that I don't know about. In fact 
I'm sure of it. So I'm asking for some help testing.

Here's how (it's easy).

1. Grab the latest from

http://www.cs.queensu.ca/~thurston/ragel/ragel-20070122.tar.gz
or
svn://mambo.cs.queensu.ca/ragel/trunk/ (requires ragel and kelbt)

2. Run it on your .rl files.

3. Diff the output against the old output of ragel.

4. Tell me if anything is different.
Note some minor whitespace changes are expected.

Thanks!

Adrian


From astra... at gmail.com  Tue Jan 23 21:38:25 2007
From: astra... at gmail.com (Alexander Strange)
Date: Tue, 23 Jan 2007 13:38:25 -0800
Subject: Reproducable crash
Message-ID: <1169588305.955977.317210@k78g2000cwa.googlegroups.com>

The attached file causes "ragel" (not rlcodegen) to bus error.

Program received signal EXC_BAD_ACCESS, Could not access memory.
Reason: KERN_PROTECTION_FAILURE at address: 0x00000064
0x0002e355 in STable<SBstMapEl<int, Action*> >::length (this=0x64) at
../aapl/table.h:152
152                     { return data == 0 ? 0 : (((STabHead*)data) -
1)->tabLen; }
(gdb) bt
#0  0x0002e355 in STable<SBstMapEl<int, Action*> >::length (this=0x64)
at ../aapl/table.h:152
#1  0x00022432 in FsmAp::hasOutData (this=0x60a8c0, state=0x0) at
fsmap.cpp:790
#2  0x00020796 in FsmAp::mergeStatesLeaving (this=0x60a8c0,
md=@0xbfffeda4, destState=0x0, srcState=0x610af0) at fsmgraph.cpp:1178
#3  0x00021b7c in FsmAp::starOp (this=0x60a8c0) at fsmgraph.cpp:228
#4  0x000119f9 in FactorWithRep::walk (this=0x609c50, pd=0x600460) at
parsetree.cpp:1356
#5  0x00012316 in FactorWithAug::walk (this=0x609c80, pd=0x600460) at
parsetree.cpp:1109
#6  0x00012af9 in Term::walk (this=0x609cd0, pd=0x600460,
lastInSeq=true) at parsetree.cpp:845
#7  0x00012d5e in Expression::walk (this=0x609cf0, pd=0x600460,
lastInSeq=true) at parsetree.cpp:687
#8  0x00012f98 in Join::walk (this=0x609d10, pd=0x600460) at
parsetree.cpp:502
#9  0x000112b4 in JoinOrLm::walk (this=0x609d30, pd=0x600460) at
parsetree.cpp:446
#10 0x00011329 in VarDef::walk (this=0x609d70, pd=0x600460) at
parsetree.cpp:44
#11 0x00017cbb in ParseData::makeInstance (this=0x600460,
gdNode=0x609d40) at parsedata.cpp:1025
#12 0x00017ef6 in ParseData::makeAll (this=0x600460) at
parsedata.cpp:1141
#13 0x000180a1 in ParseData::prepareMachineGen (this=0x600460,
graphDictEl=0x0) at parsedata.cpp:1302
#14 0x00018184 in writeMachines (out=@0xa0b0a920, hostData=@0xbffff284,
inputFileName=0xbffff41c "SSATagParsing.m.rl") at parsedata.cpp:1368
#15 0x0000c66b in main (argc=2, argv=0xbffff300) at main.cpp:372

The error can be worked around by removing "crasher" from the "tag"
machine.

(The intent of this was to be able to match any text inside a special
tag as valid, so my added actions would clean tags out of the text even
if I hadn't implemented all the commands inside them.)

Some other issues I've noticed writing this (a parser for text style
annotations in a subtitle format):

1. I get a warning:
SSATagParsing.m.rl:200:28: warning: applying plus operator to a machine
that accpets zero length word

This is obviously misspelled. Besides that, is there a way to avoid
this? I really am scanning any text that may have optional special
codes in it at random places, and empty text is perfectly fine by me.

2. According to the graph, once inside the "tag" machine, it generates
transitions to reenter that state upon reading '{', or to enter the nl
machine upon '\'. tag and nl should be exclusive, according to:

				tag = "{" cmd* "}";

				nl = "\\" [Nn];

				special = nl % nl_handler |
						 (tag > enter_tag % exit_tag);

and it shouldn't be looking for either of those until it's met a '}'.
Am I wrong?

Finally, just as a feature request, the things I'm using actions for
some of the time seem too obvious. I use several just to save the
current buffer position, since all the ending actions get is a pointer
past the end of what they want to read, and one to reimplement strtod.
I don't want to use the full tokenizing machinery since I have the
entire buffer available at once, but I would like beginning positions
of machines.


From thurs... at cs.queensu.ca  Wed Jan 24 00:00:16 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Tue, 23 Jan 2007 19:00:16 -0500
Subject: [ragel-users] Reproducable crash
In-Reply-To: <1169588305.955977.317210@k78g2000cwa.googlegroups.com>
References: <1169588305.955977.317210@k78g2000cwa.googlegroups.com>
Message-ID: <45B6A190.70605@cs.queensu.ca>

Hi Alex, it appears that the attachment didn't make it. Could you resend?

> This is obviously misspelled. Besides that, is there a way to avoid
> this? I really am scanning any text that may have optional special
> codes in it at random places, and empty text is perfectly fine by me.

It's not normally necessary to have the empty case in something that's
repeated. In theory it creates an infinite loop. If ragel actions strictly
adhered to the rules of automata theory then action foo would be executed an
infinite number of times in between each "bar". But ragel can only
approximate this behaviour, and the approximation is a little wonky in the
case of repeating the empty word.

main := ( "" %foo | "bar" )+ '\n';

If you look at the graphviz drawing of the above you'll see that on the
first and second 'b' foo is executed once, on all subsequent b's it is not
executed. This is inconsistent at best, so ragel yields a warning. A better
implementation isn't really worth it because you can usually just factor the
empty case out of a repetition.

> I don't want to use the full tokenizing machinery since I have the
> entire buffer available at once, but I would like beginning positions
> of machines.

While providing pointers to machines would be useful, here are my reasons
for opting not to.

Ragel is often used to parse text that arrives in blocks. When pointers get
invalidated by moving to the next block, something needs to be done. There
are many options for dealing with this and they depend on how input arrives.
Rather than make any assumptions I feel it is better to leave it up to the
user. At least in Ragel that is. I think auto-pointers is something that
could be done in a higher-level type of program. This is something I intend
to work on in the future (in the broader context of source transformation
systems).

Also, since it would be wasteful to automatically save pointers for every
named machine, the machines for which pointers are saved would need to be
explicitly declared. They can't be extracted from the host language because
the host language is not parsed. I think doing >{ptr = p;} is not much more
typing than a declaration :)

Regards,
 Adrian



From astra... at gmail.com  Wed Jan 24 00:51:46 2007
From: astra... at gmail.com (Alexander Strange)
Date: Tue, 23 Jan 2007 16:51:46 -0800
Subject: Reproducable crash
In-Reply-To: <45B6A190.70605@cs.queensu.ca>
References: <1169588305.955977.317210@k78g2000cwa.googlegroups.com>
   <45B6A190.70605@cs.queensu.ca>
Message-ID: <1169599906.519853.160970@m58g2000cwm.googlegroups.com>



On Jan 23, 7:00 pm, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
> Hi Alex, it appears that the attachment didn't make it. Could you resend?

Oh, sorry, I forgot to add it.

Actually, it doesn't look like the Google post field lets you attach
files, so here's a URL:
http://astrange.ithinksw.net/tools/SSATagParsing.m.rl

> Also, since it would be wasteful to automatically save pointers for every
> named machine, the machines for which pointers are saved would need to be
> explicitly declared. They can't be extracted from the host language because
> the host language is not parsed. I think doing >{ptr = p;} is not much more
> typing than a declaration :)

I see your point; the manual method certainly works for me now.

> Regards,
>  Adrian


From thurs... at cs.queensu.ca  Wed Jan 24 01:27:17 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Tue, 23 Jan 2007 20:27:17 -0500
Subject: [ragel-users] Re: Reproducable crash
In-Reply-To: <1169599906.519853.160970@m58g2000cwm.googlegroups.com>
References: <1169588305.955977.317210@k78g2000cwa.googlegroups.com> <45B6A190.70605@cs.queensu.ca> <1169599906.519853.160970@m58g2000cwm.googlegroups.com>
Message-ID: <45B6B5F5.9080007@cs.queensu.ca>

I can't seem to reproduce the crash. I think it might be architecture 
dependent. Are you running on a Mac? Bus errors in Ragel seem to crop up 
only on Macs.

crasher = any*;
tag = "{" cmd* crasher "}";

This is heavily ambiguous. The any* will never end. Also the any* of the 
text machine will never end. What happens when you change it to 
something unambiguous?

crasher = [^}]*;
text = [^\\{]*;

Regards,
  Adrian

Alexander Strange wrote:
> 
> 
> On Jan 23, 7:00 pm, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
>> Hi Alex, it appears that the attachment didn't make it. Could you resend?
> 
> Oh, sorry, I forgot to add it.
> 
> Actually, it doesn't look like the Google post field lets you attach
> files, so here's a URL:
> http://astrange.ithinksw.net/tools/SSATagParsing.m.rl
> 
>> Also, since it would be wasteful to automatically save pointers for every
>> named machine, the machines for which pointers are saved would need to be
>> explicitly declared. They can't be extracted from the host language because
>> the host language is not parsed. I think doing >{ptr = p;} is not much more
>> typing than a declaration :)
> 
> I see your point; the manual method certainly works for me now.
> 
>> Regards,
>>  Adrian
> 
> 
> 


From astra... at gmail.com  Wed Jan 24 02:58:36 2007
From: astra... at gmail.com (Alexander Strange)
Date: Tue, 23 Jan 2007 18:58:36 -0800
Subject: Reproducable crash
In-Reply-To: <45B6B5F5.9080007@cs.queensu.ca>
References: <1169588305.955977.317210@k78g2000cwa.googlegroups.com>
   <45B6A190.70605@cs.queensu.ca>
   <1169599906.519853.160970@m58g2000cwm.googlegroups.com>
   <45B6B5F5.9080007@cs.queensu.ca>
Message-ID: <1169607516.432704.179790@j27g2000cwj.googlegroups.com>



On Jan 23, 8:27 pm, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
> I can't seem to reproduce the crash. I think it might be architecture
> dependent. Are you running on a Mac? Bus errors in Ragel seem to crop up
> only on Macs.

Yes (10.4.8 i386), which means I don't have access to valgrind. I might
try to debug it later myself if you can't reproduce it, though.

> crasher = any*;
> tag = "{" cmd* crasher "}";
>
> This is heavily ambiguous. The any* will never end. Also the any* of the
> text machine will never end. What happens when you change it to
> something unambiguous?
>
> crasher = [^}]*;
> text = [^\\{]*;

text is actually supposed to be ambiguous; the people who made this
file format didn't think about parsing simplicity when they did it :(

I can certainly give that up for now, though.

With the current file, those two lines work. Changing either of them to
any* crashes. Using them and -m or -n crashes.

There are a few more situations, but since the presence of crasher was
causing cmd to do unintentional things (call the num and fsize exit
actions on every digit of "{\fs40.12}" instead of only at the end) I've
removed it anyway.

So, it looks like all is well. I'll report back if I have any useful
patches.

> Regards,
>   Adrian


From thurs... at cs.queensu.ca  Wed Jan 24 04:32:27 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Tue, 23 Jan 2007 23:32:27 -0500
Subject: [ragel-users] Reproducable crash
In-Reply-To: <1169588305.955977.317210@k78g2000cwa.googlegroups.com>
References: <1169588305.955977.317210@k78g2000cwa.googlegroups.com>
Message-ID: <45B6E15B.7030402@cs.queensu.ca>

The second argument (destState) of mergeStatesLeaving should never be 
null. Somehow a null value has gotten into the final state set of the 
machine starOp is applied to.

If you're willing to give me an account on your machine I can try to 
track it down remotely.

Adrian

Alexander Strange wrote:
> #2  0x00020796 in FsmAp::mergeStatesLeaving (this=0x60a8c0,
> md=@0xbfffeda4, destState=0x0, srcState=0x610af0) at fsmgraph.cpp:1178
> #3  0x00021b7c in FsmAp::starOp (this=0x60a8c0) at fsmgraph.cpp:228


From astra... at gmail.com  Wed Jan 24 18:45:27 2007
From: astra... at gmail.com (Alexander Strange)
Date: Wed, 24 Jan 2007 18:45:27 -0000
Subject: Reproducable crash
In-Reply-To: <45B6E15B.7030402@cs.queensu.ca>
References: <1169588305.955977.317210@k78g2000cwa.googlegroups.com>
   <45B6E15B.7030402@cs.queensu.ca>
Message-ID: <1169664327.253872.248100@k78g2000cwa.googlegroups.com>



On Jan 23, 11:32 pm, Adrian Thurston <thurs... at cs.queensu.ca> wrote:
> The second argument (destState) of mergeStatesLeaving should never be
> null. Somehow a null value has gotten into the final state set of the
> machine starOp is applied to.
>
> If you're willing to give me an account on your machine I can try to
> track it down remotely.
>
> Adrian

I'm on a laptop behind a NAT, so no exporting shells for me. I did a
bit of poking but didn't get anywhere, will do some more later.

It doesn't break in FreeBSD, and valgrind reports nothing funny there
aside from a bit of memory leaked.
(http://astrange.ithinksw.net/valgrind.txt)

> Alexander Strange wrote:
> > #2  0x00020796 in FsmAp::mergeStatesLeaving (this=0x60a8c0,
> > md=@0xbfffeda4, destState=0x0, srcState=0x610af0) at fsmgraph.cpp:1178
> > #3  0x00021b7c in FsmAp::starOp (this=0x60a8c0) at fsmgraph.cpp:228


From thurs... at cs.queensu.ca  Sun Jan 28 05:44:35 2007
From: thurs... at cs.queensu.ca (Adrian Thurston)
Date: Sun, 28 Jan 2007 00:44:35 -0500
Subject: version 5.17
Message-ID: <45BC3843.1090503@cs.queensu.ca>

Hi all,

Version 5.17 has been released. This is the self-hosting release. Both 
the scanners and the parsers have been completely rewritten. For 
context-free parsing I use Kelbt, another project of mine.

This release has been tested, but I still believe that problems are 
likely to show up. A lot of code that hasn't been touched for a really 
long time is suddenly way different. Please post any problems you have 
to the mailing list.

Thanks,
  Adrian


