From buserror at gmail.com  Thu Sep  2 14:41:36 2010
From: buserror at gmail.com (M P)
Date: Thu, 2 Sep 2010 15:41:36 +0100
Subject: [ragel-users] parser getting gigantic ?
Message-ID: <AANLkTin3+rrwwKt-i4vXChzg1ELmn7sB8gespN-DPHHx@mail.gmail.com>

I decided to play with Ragel by making a parser for an extended
version of JSON.

After falling into every single pitfall possible, I managed to get the
whole thing working pretty well, but I just had a look at the
generated code and it reached 600KB total, using -G1 (!)

So, what am I doing wrong ? I'm certain there's probably a lot of
stuff wrong with the way I made the parser, but really, I'm not sure
what so having experts eyeballing this would be very nice...

There are 2 different json parsers in the file; one is for the string
constants, one (the main one) is for the language proper...


/*
 * IF YOU ARE LOOKING AT A .c FILE, YOUR ARE LOOKING AT THE WRONG ONE
 *
 * This file is autogenerated from a .rl source file for 'ragel'
parser generator.
 */
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "json.h"

%%{
	machine json_str;
	write data;
}%%

static char * json_append_utf8_glyph(
	char * dst,
	unsigned long inUnicode )
{
	if (!(inUnicode & ~0x7f)) {
		*dst++ = ((char)inUnicode);
		return dst;	// that was easy
	}
	unsigned char *cur = dst;

	unsigned long currentMask = ~0x7ff;
	int bits = 6;
	int header = 5;

	while ((inUnicode & currentMask) && bits <= 24) {
		currentMask = currentMask << 6;
		bits += 6; header--;
	}
	*cur++ = (0xfe << header) | (unsigned char)(inUnicode >> (bits));
	bits -= 6;
	while (bits >= 0) {
		*cur++ = 0x80 | ((unsigned char)(inUnicode >> bits) & 0x3f);
		bits -= 6;
	}
	return cur;
}

int json_parse_string(char * str, char *end, char * out)
{
	char *p = str, *pe = end ? end : str + strlen( str ), *eof = pe;
	int cs;
	out = out ? out : str;
	uint16_t u;
	%%{
		machine json_str;

		xxdigit = (
			([0-9] @{ u = (u << 4) | fc - '0'; }) |
			([a-f] @{ u = (u << 4) | fc - 'a' + 0xa; }) |
			([A-F] @{ u = (u << 4) | fc - 'A' + 0xa; })			
		);
		utf16 = ( xxdigit{4} ) >{ u = 0; } @{ out = json_append_utf8_glyph(out, u); };
		
		normal = any @{*out++ = fc;};
		escape =
				('\\' %{ *out++ = '\\'; } ) |
				('t' %{ *out++ = '\t'; } )  |
				('b' %{ *out++ = '\b'; } )  |
				('f' %{ *out++ = '\f'; } )  |
				('n' %{ *out++ = '\n'; } )  |
				('r' %{ *out++ = '\r'; } )  |
				('u' utf16 ) |
				( normal -- [\\tbfntu] )
			;
		main := (
			('\\' escape) |
			( normal -- '\\' )
		)*;
		
		# Initialize and execute.
		write init;
		write exec;
	}%%
	*out = 0;
	
	return 0;
}

%%{
	machine json;
	write data;
}%%

int json_parse( json_driver_t *d, char * str )
{
	char *p = str, *pe = str + strlen( str ), *eof = pe;
	int cs;
	int stack[32], top = 0;
	int integer_sign;	// for integer decode
	char * float_start;
	json_driver_value_t v;
	uint32_t b64;
	int b64_cnt;
	
	%%{
		machine json;
		action obj_field_list_start { d->open_object(d); }
		action obj_field_list_done { d->close_object(d); }
		action obj_value_list_start { d->open_array(d); }
		action obj_value_list_done { d->close_array(d); }
		action obj_create_name { d->set_name(d, &v); }
		action obj_set_flag { if (d->add_flag) d->add_flag(d, &v); }
		action obj_set_string { d->set_value(d, json_driver_type_string, &v); }
		action obj_set_integer { d->set_value(d, json_driver_type_integer, &v); }
		action obj_set_float { d->set_value(d, json_driver_type_float, &v); }
		action obj_set_hex { d->set_value(d, json_driver_type_hex, &v); }
		action obj_set_true { v.u.v_bool = 1; d->set_value(d,
json_driver_type_bool, &v); }
		action obj_set_false { v.u.v_bool = 0; d->set_value(d,
json_driver_type_bool, &v); }
		action obj_set_null { d->set_value(d, json_driver_type_null, NULL); }
		
		action obj_start_data { if (d->open_data) d->open_data(d); }
		action obj_flush_data { if (d->add_data) for (int s=16,i = 0;
i<b64_cnt; i++,s-=8) d->add_data(d, (b64 >> s) & 0xff); }
		action obj_end_data { if (d->close_data) d->close_data(d); }
		
		W = [ \t\n]**;

		#
		# quoted or unquoted string
		#
		action str_init { v.u.v_str.start = v.u.v_str.end = fpc; }
		action str_done { v.u.v_str.end = fpc; }
			
		string = '"' ((([^"] | '\"')*) >str_init %str_done)  '"';
		ident = ((alpha | '_') (alnum | '_')*) >str_init %str_done;
		
		#
		#	negative/positive Integer
		#
		action integer_init { v.u.v_int = 0; integer_sign = 1; }
		action integer_minus { integer_sign = -1; }
		action integer_digit { v.u.v_int = (v.u.v_int * 10) + (fc - '0'); }
		action integer_done {  v.u.v_int *= integer_sign; }
		
		integer = (('-' @integer_minus | '+')? (digit+ @integer_digit))
			>integer_init %integer_done;
		
		#
		# hex integer
		#
		xxdigit = (
			([0-9] @{ v.u.v_int = (v.u.v_int << 4) | fc - '0'; }) |
			([a-f] @{ v.u.v_int = (v.u.v_int << 4) | fc - 'a' + 0xa; }) |
			([A-F] @{ v.u.v_int = (v.u.v_int << 4) | fc - 'A' + 0xa; })			
		);
		hex = (('-' @integer_minus | '+')?( '0x' xxdigit+))
			>integer_init %integer_done;
		
		#
		# float/double value
		#
		action float_init { float_start = fpc; }
		action float_done { sscanf(float_start, "%lf", &v.u.v_float); }
		#
		# float values
		#
		float = (
			('-' | '+')? digit* '.' digit+ [fd]?
		) >float_init %float_done;

		#
		# base64 decoder
		#
		base64_char = (
			([A-Z] @{ b64 = (b64 << 6) | (fc - 'A'); }) |
			([a-z] @{ b64 = (b64 << 6) | (fc - 'a' + 26 ); }) |
			([0-9] @{ b64 = (b64 << 6) | (fc - '0' + 52 ); }) |
			('+' @{ b64 = (b64 << 6) | 62; }) |
			('/' @{ b64 = (b64 << 6) | 63; })
		);
		base64_pad = '=' @{ b64 = (b64 << 6); };
		base64_four = (
			base64_char base64_char base64_char base64_char
		) %{ b64_cnt = 3; } %obj_flush_data;
		base64_padder = (
			base64_char base64_char
			(
				(( base64_char base64_pad )
					%{ b64_cnt = 2; } ) |
				(( base64_pad base64_pad )
					%{ b64_cnt = 1; } )
			)
		) %obj_flush_data;

		base64 = ( base64_four** (base64_four | base64_padder) ) >{b64 = 0;}
				%err{ printf("### base64 Error : '%s'\n", p); };

		#
		# JSON value, extended
		#
		json_value = (
			(string %obj_set_string) |
			(integer %obj_set_integer) |
			(hex %obj_set_hex ) |
			(float %obj_set_float) |
			('true' %obj_set_true) |
			('false' %obj_set_false) |
			('null' %obj_set_null) |
			('{' @{ fhold; fcall obj_field_list; } ) |
			('[' @{ fhold; fcall json_value_list; } ) |
			(('%' (W base64)* W '%') >obj_start_data %obj_end_data)
		);
		
		json_value_list := (
			'[' (
				'' |
				(W json_value (W ',' W json_value)* )
			) W ','? W ']'
		) >obj_value_list_start @obj_value_list_done @{ fret; }
				%err{ printf("### Array[%d] Error : '%s'\n", top, p); };
		
		obj_field_flag = ( ident ) %obj_set_flag;
		obj_field_flags = (
			'(' W obj_field_flag (W ',' W obj_field_flag)** ')'
		);
		obj_field = ((string | ident) %obj_create_name) W obj_field_flags? W
':' W json_value;
		
		obj_field_list := (
			'{' (
				'' |
				(W obj_field (W ',' W obj_field)** )
			) W ','? W '}'
		) >obj_field_list_start @obj_field_list_done @{ fret; }
				%err{ printf("### Object[%d] Error : '%s'\n", top, p); };
		
		main := (
			W json_value
		) %err{ printf("### JSON Error : '%s'\n", p); };

		# Initialize and execute.
		write init;
		write exec;
	}%%

	return 0;
};

#ifdef JSON_TEST_UNIT
static void d_set_name(struct json_driver_t *d,
		json_driver_value_t * v)
{
	int l = v->u.v_str.end - v->u.v_str.start;
	printf("\"%*.*s\": ", l, l, v->u.v_str.start);
}

static void d_open_array(struct json_driver_t *d)
{
	printf("[");fflush(stdout);
}

static void d_open_object(struct json_driver_t *d)
{
	printf("{");fflush(stdout);
}

static void d_set_value(struct json_driver_t *d,
		int type,
		json_driver_value_t * v)
{
	switch (type) {
		case json_driver_type_null:
			printf("null, ");
			break;
		case json_driver_type_bool:
			printf("%s, ", v->u.v_bool ? "true" : "false");
			break;
		case json_driver_type_integer:
			printf("%d, ", (int)v->u.v_int);
			break;
		case json_driver_type_hex:
			printf("0x%x, ", (int)v->u.v_int);
			break;
		case json_driver_type_float:
			printf("%f, ", (float)v->u.v_float);
			break;
		case json_driver_type_string: {
			char buf[256];
			json_parse_string(v->u.v_str.start, v->u.v_str.end, buf);
			printf("\"%s\": ", buf);
		}	break;
	}
	fflush(stdout);
}

static void d_close_array(struct json_driver_t *d)
{
	printf("],");fflush(stdout);
}

static void d_close_object(struct json_driver_t *d)
{
	printf("},");fflush(stdout);
}

static void d_open_data(struct json_driver_t *d)
{
	printf("%% '");fflush(stdout);	
}
static void d_add_data(struct json_driver_t *d, uint8_t data)
{
	printf("%c",data);fflush(stdout);
}
static void d_close_data(struct json_driver_t *d)
{
	printf("' %%,");fflush(stdout);
}

json_driver_t driver = {
	.set_name = d_set_name,
	.open_array = d_open_array,
	.open_object = d_open_object,
	.set_value = d_set_value,
	.close_array = d_close_array,
	.close_object = d_close_object,
	
	.open_data = d_open_data,
	.add_data = d_add_data,
	.close_data = d_close_data,
};

int main(int argc, char * argv[])
{

	for (int i = 1; i < argc; i++) {
		printf("### parsing '%s'\n", argv[i]);
		json_parse(&driver, argv[i]);printf("\n");
	}
	return 0;
}

#endif

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From buserror at gmail.com  Thu Sep  2 17:14:02 2010
From: buserror at gmail.com (M P)
Date: Thu, 2 Sep 2010 18:14:02 +0100
Subject: [ragel-users] parser getting gigantic ?
In-Reply-To: <AANLkTin3+rrwwKt-i4vXChzg1ELmn7sB8gespN-DPHHx@mail.gmail.com>
References: <AANLkTin3+rrwwKt-i4vXChzg1ELmn7sB8gespN-DPHHx@mail.gmail.com>
Message-ID: <AANLkTimCsQ4KhrQ9zbW9N09KP+HQnxaSY2CiPpBsK9r-@mail.gmail.com>

I found one problem already,
>                string = '"' ((([^"] | '\"')*) >str_init %str_done)  '"';
Needs a '**'. That reduces the size considerably...

It's still >100KB tho. I've been digging a bit, and there are a LOT of
instances of that "W" rule that gets inlined, even tho the output (and
the value) is just discarded.

I attempted to factor that a bit by doing :
eatme := space** @{ fret; }
W = '' @{ fcall eatme; }

But that didn't work... I wish we could mark a rule as "discard,
factor" or something...

Michael

On Thu, Sep 2, 2010 at 3:41 PM, M P <buserror at gmail.com> wrote:
> I decided to play with Ragel by making a parser for an extended
> version of JSON.
>
> After falling into every single pitfall possible, I managed to get the
> whole thing working pretty well, but I just had a look at the
> generated code and it reached 600KB total, using -G1 (!)
>
> So, what am I doing wrong ? I'm certain there's probably a lot of
> stuff wrong with the way I made the parser, but really, I'm not sure
> what so having experts eyeballing this would be very nice...
>
> There are 2 different json parsers in the file; one is for the string
> constants, one (the main one) is for the language proper...
>
>
> /*
>  * IF YOU ARE LOOKING AT A .c FILE, YOUR ARE LOOKING AT THE WRONG ONE
>  *
>  * This file is autogenerated from a .rl source file for 'ragel'
> parser generator.
>  */
> #include <stdlib.h>
> #include <string.h>
> #include <stdio.h>
>
> #include "json.h"
>
> %%{
>        machine json_str;
>        write data;
> }%%
>
> static char * json_append_utf8_glyph(
>        char * dst,
>        unsigned long inUnicode )
> {
>        if (!(inUnicode & ~0x7f)) {
>                *dst++ = ((char)inUnicode);
>                return dst;     // that was easy
>        }
>        unsigned char *cur = dst;
>
>        unsigned long currentMask = ~0x7ff;
>        int bits = 6;
>        int header = 5;
>
>        while ((inUnicode & currentMask) && bits <= 24) {
>                currentMask = currentMask << 6;
>                bits += 6; header--;
>        }
>        *cur++ = (0xfe << header) | (unsigned char)(inUnicode >> (bits));
>        bits -= 6;
>        while (bits >= 0) {
>                *cur++ = 0x80 | ((unsigned char)(inUnicode >> bits) & 0x3f);
>                bits -= 6;
>        }
>        return cur;
> }
>
> int json_parse_string(char * str, char *end, char * out)
> {
>        char *p = str, *pe = end ? end : str + strlen( str ), *eof = pe;
>        int cs;
>        out = out ? out : str;
>        uint16_t u;
>        %%{
>                machine json_str;
>
>                xxdigit = (
>                        ([0-9] @{ u = (u << 4) | fc - '0'; }) |
>                        ([a-f] @{ u = (u << 4) | fc - 'a' + 0xa; }) |
>                        ([A-F] @{ u = (u << 4) | fc - 'A' + 0xa; })
>                );
>                utf16 = ( xxdigit{4} ) >{ u = 0; } @{ out = json_append_utf8_glyph(out, u); };
>
>                normal = any @{*out++ = fc;};
>                escape =
>                                ('\\' %{ *out++ = '\\'; } ) |
>                                ('t' %{ *out++ = '\t'; } )  |
>                                ('b' %{ *out++ = '\b'; } )  |
>                                ('f' %{ *out++ = '\f'; } )  |
>                                ('n' %{ *out++ = '\n'; } )  |
>                                ('r' %{ *out++ = '\r'; } )  |
>                                ('u' utf16 ) |
>                                ( normal -- [\\tbfntu] )
>                        ;
>                main := (
>                        ('\\' escape) |
>                        ( normal -- '\\' )
>                )*;
>
>                # Initialize and execute.
>                write init;
>                write exec;
>        }%%
>        *out = 0;
>
>        return 0;
> }
>
> %%{
>        machine json;
>        write data;
> }%%
>
> int json_parse( json_driver_t *d, char * str )
> {
>        char *p = str, *pe = str + strlen( str ), *eof = pe;
>        int cs;
>        int stack[32], top = 0;
>        int integer_sign;       // for integer decode
>        char * float_start;
>        json_driver_value_t v;
>        uint32_t b64;
>        int b64_cnt;
>
>        %%{
>                machine json;
>                action obj_field_list_start { d->open_object(d); }
>                action obj_field_list_done { d->close_object(d); }
>                action obj_value_list_start { d->open_array(d); }
>                action obj_value_list_done { d->close_array(d); }
>                action obj_create_name { d->set_name(d, &v); }
>                action obj_set_flag { if (d->add_flag) d->add_flag(d, &v); }
>                action obj_set_string { d->set_value(d, json_driver_type_string, &v); }
>                action obj_set_integer { d->set_value(d, json_driver_type_integer, &v); }
>                action obj_set_float { d->set_value(d, json_driver_type_float, &v); }
>                action obj_set_hex { d->set_value(d, json_driver_type_hex, &v); }
>                action obj_set_true { v.u.v_bool = 1; d->set_value(d,
> json_driver_type_bool, &v); }
>                action obj_set_false { v.u.v_bool = 0; d->set_value(d,
> json_driver_type_bool, &v); }
>                action obj_set_null { d->set_value(d, json_driver_type_null, NULL); }
>
>                action obj_start_data { if (d->open_data) d->open_data(d); }
>                action obj_flush_data { if (d->add_data) for (int s=16,i = 0;
> i<b64_cnt; i++,s-=8) d->add_data(d, (b64 >> s) & 0xff); }
>                action obj_end_data { if (d->close_data) d->close_data(d); }
>
>                W = [ \t\n]**;
>
>                #
>                # quoted or unquoted string
>                #
>                action str_init { v.u.v_str.start = v.u.v_str.end = fpc; }
>                action str_done { v.u.v_str.end = fpc; }
>
>                string = '"' ((([^"] | '\"')*) >str_init %str_done)  '"';
>                ident = ((alpha | '_') (alnum | '_')*) >str_init %str_done;
>
>                #
>                #       negative/positive Integer
>                #
>                action integer_init { v.u.v_int = 0; integer_sign = 1; }
>                action integer_minus { integer_sign = -1; }
>                action integer_digit { v.u.v_int = (v.u.v_int * 10) + (fc - '0'); }
>                action integer_done {  v.u.v_int *= integer_sign; }
>
>                integer = (('-' @integer_minus | '+')? (digit+ @integer_digit))
>                        >integer_init %integer_done;
>
>                #
>                # hex integer
>                #
>                xxdigit = (
>                        ([0-9] @{ v.u.v_int = (v.u.v_int << 4) | fc - '0'; }) |
>                        ([a-f] @{ v.u.v_int = (v.u.v_int << 4) | fc - 'a' + 0xa; }) |
>                        ([A-F] @{ v.u.v_int = (v.u.v_int << 4) | fc - 'A' + 0xa; })
>                );
>                hex = (('-' @integer_minus | '+')?( '0x' xxdigit+))
>                        >integer_init %integer_done;
>
>                #
>                # float/double value
>                #
>                action float_init { float_start = fpc; }
>                action float_done { sscanf(float_start, "%lf", &v.u.v_float); }
>                #
>                # float values
>                #
>                float = (
>                        ('-' | '+')? digit* '.' digit+ [fd]?
>                ) >float_init %float_done;
>
>                #
>                # base64 decoder
>                #
>                base64_char = (
>                        ([A-Z] @{ b64 = (b64 << 6) | (fc - 'A'); }) |
>                        ([a-z] @{ b64 = (b64 << 6) | (fc - 'a' + 26 ); }) |
>                        ([0-9] @{ b64 = (b64 << 6) | (fc - '0' + 52 ); }) |
>                        ('+' @{ b64 = (b64 << 6) | 62; }) |
>                        ('/' @{ b64 = (b64 << 6) | 63; })
>                );
>                base64_pad = '=' @{ b64 = (b64 << 6); };
>                base64_four = (
>                        base64_char base64_char base64_char base64_char
>                ) %{ b64_cnt = 3; } %obj_flush_data;
>                base64_padder = (
>                        base64_char base64_char
>                        (
>                                (( base64_char base64_pad )
>                                        %{ b64_cnt = 2; } ) |
>                                (( base64_pad base64_pad )
>                                        %{ b64_cnt = 1; } )
>                        )
>                ) %obj_flush_data;
>
>                base64 = ( base64_four** (base64_four | base64_padder) ) >{b64 = 0;}
>                                %err{ printf("### base64 Error : '%s'\n", p); };
>
>                #
>                # JSON value, extended
>                #
>                json_value = (
>                        (string %obj_set_string) |
>                        (integer %obj_set_integer) |
>                        (hex %obj_set_hex ) |
>                        (float %obj_set_float) |
>                        ('true' %obj_set_true) |
>                        ('false' %obj_set_false) |
>                        ('null' %obj_set_null) |
>                        ('{' @{ fhold; fcall obj_field_list; } ) |
>                        ('[' @{ fhold; fcall json_value_list; } ) |
>                        (('%' (W base64)* W '%') >obj_start_data %obj_end_data)
>                );
>
>                json_value_list := (
>                        '[' (
>                                '' |
>                                (W json_value (W ',' W json_value)* )
>                        ) W ','? W ']'
>                ) >obj_value_list_start @obj_value_list_done @{ fret; }
>                                %err{ printf("### Array[%d] Error : '%s'\n", top, p); };
>
>                obj_field_flag = ( ident ) %obj_set_flag;
>                obj_field_flags = (
>                        '(' W obj_field_flag (W ',' W obj_field_flag)** ')'
>                );
>                obj_field = ((string | ident) %obj_create_name) W obj_field_flags? W
> ':' W json_value;
>
>                obj_field_list := (
>                        '{' (
>                                '' |
>                                (W obj_field (W ',' W obj_field)** )
>                        ) W ','? W '}'
>                ) >obj_field_list_start @obj_field_list_done @{ fret; }
>                                %err{ printf("### Object[%d] Error : '%s'\n", top, p); };
>
>                main := (
>                        W json_value
>                ) %err{ printf("### JSON Error : '%s'\n", p); };
>
>                # Initialize and execute.
>                write init;
>                write exec;
>        }%%
>
>        return 0;
> };
>
> #ifdef JSON_TEST_UNIT
> static void d_set_name(struct json_driver_t *d,
>                json_driver_value_t * v)
> {
>        int l = v->u.v_str.end - v->u.v_str.start;
>        printf("\"%*.*s\": ", l, l, v->u.v_str.start);
> }
>
> static void d_open_array(struct json_driver_t *d)
> {
>        printf("[");fflush(stdout);
> }
>
> static void d_open_object(struct json_driver_t *d)
> {
>        printf("{");fflush(stdout);
> }
>
> static void d_set_value(struct json_driver_t *d,
>                int type,
>                json_driver_value_t * v)
> {
>        switch (type) {
>                case json_driver_type_null:
>                        printf("null, ");
>                        break;
>                case json_driver_type_bool:
>                        printf("%s, ", v->u.v_bool ? "true" : "false");
>                        break;
>                case json_driver_type_integer:
>                        printf("%d, ", (int)v->u.v_int);
>                        break;
>                case json_driver_type_hex:
>                        printf("0x%x, ", (int)v->u.v_int);
>                        break;
>                case json_driver_type_float:
>                        printf("%f, ", (float)v->u.v_float);
>                        break;
>                case json_driver_type_string: {
>                        char buf[256];
>                        json_parse_string(v->u.v_str.start, v->u.v_str.end, buf);
>                        printf("\"%s\": ", buf);
>                }       break;
>        }
>        fflush(stdout);
> }
>
> static void d_close_array(struct json_driver_t *d)
> {
>        printf("],");fflush(stdout);
> }
>
> static void d_close_object(struct json_driver_t *d)
> {
>        printf("},");fflush(stdout);
> }
>
> static void d_open_data(struct json_driver_t *d)
> {
>        printf("%% '");fflush(stdout);
> }
> static void d_add_data(struct json_driver_t *d, uint8_t data)
> {
>        printf("%c",data);fflush(stdout);
> }
> static void d_close_data(struct json_driver_t *d)
> {
>        printf("' %%,");fflush(stdout);
> }
>
> json_driver_t driver = {
>        .set_name = d_set_name,
>        .open_array = d_open_array,
>        .open_object = d_open_object,
>        .set_value = d_set_value,
>        .close_array = d_close_array,
>        .close_object = d_close_object,
>
>        .open_data = d_open_data,
>        .add_data = d_add_data,
>        .close_data = d_close_data,
> };
>
> int main(int argc, char * argv[])
> {
>
>        for (int i = 1; i < argc; i++) {
>                printf("### parsing '%s'\n", argv[i]);
>                json_parse(&driver, argv[i]);printf("\n");
>        }
>        return 0;
> }
>
> #endif
>

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From twisolar at gmail.com  Wed Sep 29 03:30:40 2010
From: twisolar at gmail.com (Jonathan Castello)
Date: Tue, 28 Sep 2010 20:30:40 -0700
Subject: [ragel-users] Writing a Telnet parser
Message-ID: <AANLkTi=VsNUCYx4sgVsB5VjKw5jSW74sQxSzCeNb9Pz1@mail.gmail.com>

Hello,

I'm building a Telnet parser using Ragel, and I'm having an issue
making the actions do what I want. I've pasted the machine definition
to a gist: http://gist.github.com/602242

The issue is a little hard for me to describe, so I'll try to
illustrate it as best as I can. If I have a stream of input, and some
part of it is "abcdef<IAC><GA>ghi" (where <x> is a mnemonic for a
single byte), I want to emit events as such: text("abcdef"),
command("<GA>"), text("ghi"). The caller provides callbacks, and I
would pass the data to them as I interpret it.

The problem is that I can't figure out how to define actions that
would only trigger when the next character doesn't match plain_text
(or there's no more data left to parse in that particular packet), so
I can get that full stretch of characters. At the moment, I can only
get text("a"), text("b"), text("c") etc. to work, i.e. one plain_text
match at a time.

I suspect the problem is that cr_sequence and iac_sequence are
supposed to behave this way - they, too, match singular "terms" each
time before returning to the start - but here I am, wanting to give
plain_text special treatment. Am I even coming at this from the right
angle?

Thanks in advance for any advice!
~Jonathan Castello

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From adrian.thurston at esentire.com  Wed Sep 29 17:07:07 2010
From: adrian.thurston at esentire.com (Adrian Thurston)
Date: Wed, 29 Sep 2010 10:07:07 -0700
Subject: [ragel-users] Writing a Telnet parser
In-Reply-To: <AANLkTi=VsNUCYx4sgVsB5VjKw5jSW74sQxSzCeNb9Pz1@mail.gmail.com>
References: <AANLkTi=VsNUCYx4sgVsB5VjKw5jSW74sQxSzCeNb9Pz1@mail.gmail.com>
Message-ID: <4CA3723B.5060000@esentire.com>

Hi Jonathan,

Ragel does not do any buffering of text for you. It's up to you to 
decide how you want to do that, then implement it yourself. There are a 
couple options. You can copy text to a buffer as you move over 
characters, or you can extract them from the input buffer when you need 
them. The first approach is simpler and guaranteed to work without 
hitches. The second technique is faster, but you have to consider buffer 
block boundaries.

-Adrian

On 10-09-28 08:30 PM, Jonathan Castello wrote:
> Hello,
>
> I'm building a Telnet parser using Ragel, and I'm having an issue
> making the actions do what I want. I've pasted the machine definition
> to a gist: http://gist.github.com/602242
>
> The issue is a little hard for me to describe, so I'll try to
> illustrate it as best as I can. If I have a stream of input, and some
> part of it is "abcdef<IAC><GA>ghi" (where<x>  is a mnemonic for a
> single byte), I want to emit events as such: text("abcdef"),
> command("<GA>"), text("ghi"). The caller provides callbacks, and I
> would pass the data to them as I interpret it.
>
> The problem is that I can't figure out how to define actions that
> would only trigger when the next character doesn't match plain_text
> (or there's no more data left to parse in that particular packet), so
> I can get that full stretch of characters. At the moment, I can only
> get text("a"), text("b"), text("c") etc. to work, i.e. one plain_text
> match at a time.
>
> I suspect the problem is that cr_sequence and iac_sequence are
> supposed to behave this way - they, too, match singular "terms" each
> time before returning to the start - but here I am, wanting to give
> plain_text special treatment. Am I even coming at this from the right
> angle?
>
> Thanks in advance for any advice!
> ~Jonathan Castello
>
> _______________________________________________
> ragel-users mailing list
> ragel-users at complang.org
> http://www.complang.org/mailman/listinfo/ragel-users
>

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From twisolar at gmail.com  Wed Sep 29 17:34:53 2010
From: twisolar at gmail.com (Jonathan Castello)
Date: Wed, 29 Sep 2010 10:34:53 -0700
Subject: [ragel-users] Writing a Telnet parser
In-Reply-To: <4CA3723B.5060000@esentire.com>
References: <AANLkTi=VsNUCYx4sgVsB5VjKw5jSW74sQxSzCeNb9Pz1@mail.gmail.com>
	<4CA3723B.5060000@esentire.com>
Message-ID: <AANLkTikZe6jTT4tV4ZLicJyTpWmhQb5aXaEXjL3bfAp-@mail.gmail.com>

Hi Adrian,

Thanks for your help. Actually, I know how I want to buffer them; the
problem is actually extracting them when I want to. I need some way to
extract the characters only when the next character isn't plain_text
or there is no next character. I've tried adding an entry action to
cr_sequence and iac_sequence, but that doesn't work when you reach the
end of the subject data without seeing a CR or IAC. What I was hoping
to do is maintain a 'left' pointer to the first plain_text character,
and use fpc as the 'right' pointer when I reach the last contiguous
plain_text character. Then I would pass the left pointer and the
length of that contiguous stretch (fpc-left) to the user-provided
callback.

I could copy each character to a temporary buffer, but I was hoping to
avoid extra allocations. I want to just pass pointers into the
original block of text being parsed, so the calling code can do any
copying and allocating required. My entry action attempt was the
closest I could get: it would properly fire before a non plain_text
sequence, but the major issue is that it wouldn't fire at all when it
reached the end of the subject line.

Thanks again,
~Jonathan

On Wed, Sep 29, 2010 at 10:07 AM, Adrian Thurston
<adrian.thurston at esentire.com> wrote:
> Hi Jonathan,
>
> Ragel does not do any buffering of text for you. It's up to you to decide
> how you want to do that, then implement it yourself. There are a couple
> options. You can copy text to a buffer as you move over characters, or you
> can extract them from the input buffer when you need them. The first
> approach is simpler and guaranteed to work without hitches. The second
> technique is faster, but you have to consider buffer block boundaries.
>
> -Adrian
>
> On 10-09-28 08:30 PM, Jonathan Castello wrote:
>>
>> Hello,
>>
>> I'm building a Telnet parser using Ragel, and I'm having an issue
>> making the actions do what I want. I've pasted the machine definition
>> to a gist: http://gist.github.com/602242
>>
>> The issue is a little hard for me to describe, so I'll try to
>> illustrate it as best as I can. If I have a stream of input, and some
>> part of it is "abcdef<IAC><GA>ghi" (where<x>  is a mnemonic for a
>> single byte), I want to emit events as such: text("abcdef"),
>> command("<GA>"), text("ghi"). The caller provides callbacks, and I
>> would pass the data to them as I interpret it.
>>
>> The problem is that I can't figure out how to define actions that
>> would only trigger when the next character doesn't match plain_text
>> (or there's no more data left to parse in that particular packet), so
>> I can get that full stretch of characters. At the moment, I can only
>> get text("a"), text("b"), text("c") etc. to work, i.e. one plain_text
>> match at a time.
>>
>> I suspect the problem is that cr_sequence and iac_sequence are
>> supposed to behave this way - they, too, match singular "terms" each
>> time before returning to the start - but here I am, wanting to give
>> plain_text special treatment. Am I even coming at this from the right
>> angle?
>>
>> Thanks in advance for any advice!
>> ~Jonathan Castello
>>
>> _______________________________________________
>> ragel-users mailing list
>> ragel-users at complang.org
>> http://www.complang.org/mailman/listinfo/ragel-users
>>
>
> _______________________________________________
> ragel-users mailing list
> ragel-users at complang.org
> http://www.complang.org/mailman/listinfo/ragel-users
>

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From adrian.thurston at esentire.com  Wed Sep 29 17:43:10 2010
From: adrian.thurston at esentire.com (Adrian Thurston)
Date: Wed, 29 Sep 2010 10:43:10 -0700
Subject: [ragel-users] Writing a Telnet parser
In-Reply-To: <AANLkTikZe6jTT4tV4ZLicJyTpWmhQb5aXaEXjL3bfAp-@mail.gmail.com>
References: <AANLkTi=VsNUCYx4sgVsB5VjKw5jSW74sQxSzCeNb9Pz1@mail.gmail.com>	<4CA3723B.5060000@esentire.com>
	<AANLkTikZe6jTT4tV4ZLicJyTpWmhQb5aXaEXjL3bfAp-@mail.gmail.com>
Message-ID: <4CA37AAE.4040706@esentire.com>

Have you tried leaving actions? It sounds like that is what you want.

-Adrian

On 10-09-29 10:34 AM, Jonathan Castello wrote:
> Hi Adrian,
>
> Thanks for your help. Actually, I know how I want to buffer them; the
> problem is actually extracting them when I want to. I need some way to
> extract the characters only when the next character isn't plain_text
> or there is no next character. I've tried adding an entry action to
> cr_sequence and iac_sequence, but that doesn't work when you reach the
> end of the subject data without seeing a CR or IAC. What I was hoping
> to do is maintain a 'left' pointer to the first plain_text character,
> and use fpc as the 'right' pointer when I reach the last contiguous
> plain_text character. Then I would pass the left pointer and the
> length of that contiguous stretch (fpc-left) to the user-provided
> callback.
>
> I could copy each character to a temporary buffer, but I was hoping to
> avoid extra allocations. I want to just pass pointers into the
> original block of text being parsed, so the calling code can do any
> copying and allocating required. My entry action attempt was the
> closest I could get: it would properly fire before a non plain_text
> sequence, but the major issue is that it wouldn't fire at all when it
> reached the end of the subject line.
>
> Thanks again,
> ~Jonathan
>
> On Wed, Sep 29, 2010 at 10:07 AM, Adrian Thurston
> <adrian.thurston at esentire.com>  wrote:
>> Hi Jonathan,
>>
>> Ragel does not do any buffering of text for you. It's up to you to decide
>> how you want to do that, then implement it yourself. There are a couple
>> options. You can copy text to a buffer as you move over characters, or you
>> can extract them from the input buffer when you need them. The first
>> approach is simpler and guaranteed to work without hitches. The second
>> technique is faster, but you have to consider buffer block boundaries.
>>
>> -Adrian
>>
>> On 10-09-28 08:30 PM, Jonathan Castello wrote:
>>>
>>> Hello,
>>>
>>> I'm building a Telnet parser using Ragel, and I'm having an issue
>>> making the actions do what I want. I've pasted the machine definition
>>> to a gist: http://gist.github.com/602242
>>>
>>> The issue is a little hard for me to describe, so I'll try to
>>> illustrate it as best as I can. If I have a stream of input, and some
>>> part of it is "abcdef<IAC><GA>ghi" (where<x>    is a mnemonic for a
>>> single byte), I want to emit events as such: text("abcdef"),
>>> command("<GA>"), text("ghi"). The caller provides callbacks, and I
>>> would pass the data to them as I interpret it.
>>>
>>> The problem is that I can't figure out how to define actions that
>>> would only trigger when the next character doesn't match plain_text
>>> (or there's no more data left to parse in that particular packet), so
>>> I can get that full stretch of characters. At the moment, I can only
>>> get text("a"), text("b"), text("c") etc. to work, i.e. one plain_text
>>> match at a time.
>>>
>>> I suspect the problem is that cr_sequence and iac_sequence are
>>> supposed to behave this way - they, too, match singular "terms" each
>>> time before returning to the start - but here I am, wanting to give
>>> plain_text special treatment. Am I even coming at this from the right
>>> angle?
>>>
>>> Thanks in advance for any advice!
>>> ~Jonathan Castello
>>>
>>> _______________________________________________
>>> ragel-users mailing list
>>> ragel-users at complang.org
>>> http://www.complang.org/mailman/listinfo/ragel-users
>>>
>>
>> _______________________________________________
>> ragel-users mailing list
>> ragel-users at complang.org
>> http://www.complang.org/mailman/listinfo/ragel-users
>>
>
> _______________________________________________
> ragel-users mailing list
> ragel-users at complang.org
> http://www.complang.org/mailman/listinfo/ragel-users
>

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From buserror at gmail.com  Wed Sep 29 18:19:11 2010
From: buserror at gmail.com (M P)
Date: Wed, 29 Sep 2010 19:19:11 +0100
Subject: [ragel-users] ANN: libejson, extended JSON parser library
Message-ID: <AANLkTi=v3A8PPBPHO=dkftGd3gdqOMkS+QH+T49=TEao@mail.gmail.com>

I open-sourced a ragel-based parser for an extended version of JSON (I
had posted a problematic version some weeks ago)

http://bliterness.blogspot.com/2010/09/new-libejson-json-parser-on-steroids.html

Michael

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From adrian.thurston at esentire.com  Wed Sep 29 18:21:49 2010
From: adrian.thurston at esentire.com (Adrian Thurston)
Date: Wed, 29 Sep 2010 11:21:49 -0700
Subject: [ragel-users] ANN: libejson, extended JSON parser library
In-Reply-To: <AANLkTi=v3A8PPBPHO=dkftGd3gdqOMkS+QH+T49=TEao@mail.gmail.com>
References: <AANLkTi=v3A8PPBPHO=dkftGd3gdqOMkS+QH+T49=TEao@mail.gmail.com>
Message-ID: <4CA383BD.9070907@esentire.com>

Thanks!

I'm very sorry I never responded to your messages. Did you get all the 
issues worked out?

-Adrian

On 10-09-29 11:19 AM, M P wrote:
> I open-sourced a ragel-based parser for an extended version of JSON (I
> had posted a problematic version some weeks ago)
>
> http://bliterness.blogspot.com/2010/09/new-libejson-json-parser-on-steroids.html
>
> Michael
>
> _______________________________________________
> ragel-users mailing list
> ragel-users at complang.org
> http://www.complang.org/mailman/listinfo/ragel-users
>

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From buserror at gmail.com  Wed Sep 29 18:31:49 2010
From: buserror at gmail.com (M P)
Date: Wed, 29 Sep 2010 19:31:49 +0100
Subject: [ragel-users] ANN: libejson, extended JSON parser library
In-Reply-To: <4CA383BD.9070907@esentire.com>
References: <AANLkTi=v3A8PPBPHO=dkftGd3gdqOMkS+QH+T49=TEao@mail.gmail.com>
	<4CA383BD.9070907@esentire.com>
Message-ID: <AANLkTikZE2Xb5PpJbCFn6qyd=8sy_7XNwc+5yzehGhQ+@mail.gmail.com>

Only partially -- I managed to get the whole parser working, BAR the
comments... I had tried to embed the comment 'detection' into the
"whitespace" rule ("W"), but I never managed to get it to work, so I
yanked the comment bit for now..

I think there's probably a need in ragel to specify a "skip" rule
flag, to prevent the parser getting gigantic with "instances" of these
empty rules... I tried to do an fcall/fret but didn't get that to work
either...

Right now the parser is about 50kb expanded, and thats as low as I
managed it to get, I think that given the relative complexity of it,
it's probably OK...

If you want to have a quick review and/or submit patches, I would be
very grateful !

Michael


On Wed, Sep 29, 2010 at 7:21 PM, Adrian Thurston
<adrian.thurston at esentire.com> wrote:
> Thanks!
>
> I'm very sorry I never responded to your messages. Did you get all the
> issues worked out?
>
> -Adrian
>
> On 10-09-29 11:19 AM, M P wrote:
>>
>> I open-sourced a ragel-based parser for an extended version of JSON (I
>> had posted a problematic version some weeks ago)
>>
>>
>> http://bliterness.blogspot.com/2010/09/new-libejson-json-parser-on-steroids.html
>>
>> Michael
>>
>> _______________________________________________
>> ragel-users mailing list
>> ragel-users at complang.org
>> http://www.complang.org/mailman/listinfo/ragel-users
>>
>
> _______________________________________________
> ragel-users mailing list
> ragel-users at complang.org
> http://www.complang.org/mailman/listinfo/ragel-users
>

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From twisolar at gmail.com  Thu Sep 30 00:39:04 2010
From: twisolar at gmail.com (Jonathan Castello)
Date: Wed, 29 Sep 2010 17:39:04 -0700
Subject: [ragel-users] Writing a Telnet parser
In-Reply-To: <4CA37AAE.4040706@esentire.com>
References: <AANLkTi=VsNUCYx4sgVsB5VjKw5jSW74sQxSzCeNb9Pz1@mail.gmail.com>
	<4CA3723B.5060000@esentire.com>
	<AANLkTikZe6jTT4tV4ZLicJyTpWmhQb5aXaEXjL3bfAp-@mail.gmail.com>
	<4CA37AAE.4040706@esentire.com>
Message-ID: <AANLkTi=xGnS+S9agqdTXTy76rS3jBdkMPnpWMHGz22KF@mail.gmail.com>

I have, actually. If I have "plain_text %leaving", the leaving action
is still executed after every plain_text character, as the generated
graph seems to indicate. If I put %leaving after the telnet_stream
itself, the graph suggests that it's only executed on EOF, which will
never occur as I am processing a potentially infinite network stream.
(Because of this, I explicitly set eof = NULL in the code before "%%
write init", as the documentation suggests.)

~Jonathan

On Wed, Sep 29, 2010 at 10:43 AM, Adrian Thurston
<adrian.thurston at esentire.com> wrote:
> Have you tried leaving actions? It sounds like that is what you want.
>
> -Adrian
>
> On 10-09-29 10:34 AM, Jonathan Castello wrote:
>>
>> Hi Adrian,
>>
>> Thanks for your help. Actually, I know how I want to buffer them; the
>> problem is actually extracting them when I want to. I need some way to
>> extract the characters only when the next character isn't plain_text
>> or there is no next character. I've tried adding an entry action to
>> cr_sequence and iac_sequence, but that doesn't work when you reach the
>> end of the subject data without seeing a CR or IAC. What I was hoping
>> to do is maintain a 'left' pointer to the first plain_text character,
>> and use fpc as the 'right' pointer when I reach the last contiguous
>> plain_text character. Then I would pass the left pointer and the
>> length of that contiguous stretch (fpc-left) to the user-provided
>> callback.
>>
>> I could copy each character to a temporary buffer, but I was hoping to
>> avoid extra allocations. I want to just pass pointers into the
>> original block of text being parsed, so the calling code can do any
>> copying and allocating required. My entry action attempt was the
>> closest I could get: it would properly fire before a non plain_text
>> sequence, but the major issue is that it wouldn't fire at all when it
>> reached the end of the subject line.
>>
>> Thanks again,
>> ~Jonathan
>>
>> On Wed, Sep 29, 2010 at 10:07 AM, Adrian Thurston
>> <adrian.thurston at esentire.com>  wrote:
>>>
>>> Hi Jonathan,
>>>
>>> Ragel does not do any buffering of text for you. It's up to you to decide
>>> how you want to do that, then implement it yourself. There are a couple
>>> options. You can copy text to a buffer as you move over characters, or
>>> you
>>> can extract them from the input buffer when you need them. The first
>>> approach is simpler and guaranteed to work without hitches. The second
>>> technique is faster, but you have to consider buffer block boundaries.
>>>
>>> -Adrian
>>>
>>> On 10-09-28 08:30 PM, Jonathan Castello wrote:
>>>>
>>>> Hello,
>>>>
>>>> I'm building a Telnet parser using Ragel, and I'm having an issue
>>>> making the actions do what I want. I've pasted the machine definition
>>>> to a gist: http://gist.github.com/602242
>>>>
>>>> The issue is a little hard for me to describe, so I'll try to
>>>> illustrate it as best as I can. If I have a stream of input, and some
>>>> part of it is "abcdef<IAC><GA>ghi" (where<x>    is a mnemonic for a
>>>> single byte), I want to emit events as such: text("abcdef"),
>>>> command("<GA>"), text("ghi"). The caller provides callbacks, and I
>>>> would pass the data to them as I interpret it.
>>>>
>>>> The problem is that I can't figure out how to define actions that
>>>> would only trigger when the next character doesn't match plain_text
>>>> (or there's no more data left to parse in that particular packet), so
>>>> I can get that full stretch of characters. At the moment, I can only
>>>> get text("a"), text("b"), text("c") etc. to work, i.e. one plain_text
>>>> match at a time.
>>>>
>>>> I suspect the problem is that cr_sequence and iac_sequence are
>>>> supposed to behave this way - they, too, match singular "terms" each
>>>> time before returning to the start - but here I am, wanting to give
>>>> plain_text special treatment. Am I even coming at this from the right
>>>> angle?
>>>>
>>>> Thanks in advance for any advice!
>>>> ~Jonathan Castello
>>>>
>>>> _______________________________________________
>>>> ragel-users mailing list
>>>> ragel-users at complang.org
>>>> http://www.complang.org/mailman/listinfo/ragel-users
>>>>
>>>
>>> _______________________________________________
>>> ragel-users mailing list
>>> ragel-users at complang.org
>>> http://www.complang.org/mailman/listinfo/ragel-users
>>>
>>
>> _______________________________________________
>> ragel-users mailing list
>> ragel-users at complang.org
>> http://www.complang.org/mailman/listinfo/ragel-users
>>
>
> _______________________________________________
> ragel-users mailing list
> ragel-users at complang.org
> http://www.complang.org/mailman/listinfo/ragel-users
>

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From buserror at gmail.com  Thu Sep  2 14:41:36 2010
From: buserror at gmail.com (M P)
Date: Thu, 2 Sep 2010 15:41:36 +0100
Subject: [ragel-users] parser getting gigantic ?
Message-ID: <AANLkTin3+rrwwKt-i4vXChzg1ELmn7sB8gespN-DPHHx@mail.gmail.com>

I decided to play with Ragel by making a parser for an extended
version of JSON.

After falling into every single pitfall possible, I managed to get the
whole thing working pretty well, but I just had a look at the
generated code and it reached 600KB total, using -G1 (!)

So, what am I doing wrong ? I'm certain there's probably a lot of
stuff wrong with the way I made the parser, but really, I'm not sure
what so having experts eyeballing this would be very nice...

There are 2 different json parsers in the file; one is for the string
constants, one (the main one) is for the language proper...


/*
 * IF YOU ARE LOOKING AT A .c FILE, YOUR ARE LOOKING AT THE WRONG ONE
 *
 * This file is autogenerated from a .rl source file for 'ragel'
parser generator.
 */
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "json.h"

%%{
	machine json_str;
	write data;
}%%

static char * json_append_utf8_glyph(
	char * dst,
	unsigned long inUnicode )
{
	if (!(inUnicode & ~0x7f)) {
		*dst++ = ((char)inUnicode);
		return dst;	// that was easy
	}
	unsigned char *cur = dst;

	unsigned long currentMask = ~0x7ff;
	int bits = 6;
	int header = 5;

	while ((inUnicode & currentMask) && bits <= 24) {
		currentMask = currentMask << 6;
		bits += 6; header--;
	}
	*cur++ = (0xfe << header) | (unsigned char)(inUnicode >> (bits));
	bits -= 6;
	while (bits >= 0) {
		*cur++ = 0x80 | ((unsigned char)(inUnicode >> bits) & 0x3f);
		bits -= 6;
	}
	return cur;
}

int json_parse_string(char * str, char *end, char * out)
{
	char *p = str, *pe = end ? end : str + strlen( str ), *eof = pe;
	int cs;
	out = out ? out : str;
	uint16_t u;
	%%{
		machine json_str;

		xxdigit = (
			([0-9] @{ u = (u << 4) | fc - '0'; }) |
			([a-f] @{ u = (u << 4) | fc - 'a' + 0xa; }) |
			([A-F] @{ u = (u << 4) | fc - 'A' + 0xa; })			
		);
		utf16 = ( xxdigit{4} ) >{ u = 0; } @{ out = json_append_utf8_glyph(out, u); };
		
		normal = any @{*out++ = fc;};
		escape =
				('\\' %{ *out++ = '\\'; } ) |
				('t' %{ *out++ = '\t'; } )  |
				('b' %{ *out++ = '\b'; } )  |
				('f' %{ *out++ = '\f'; } )  |
				('n' %{ *out++ = '\n'; } )  |
				('r' %{ *out++ = '\r'; } )  |
				('u' utf16 ) |
				( normal -- [\\tbfntu] )
			;
		main := (
			('\\' escape) |
			( normal -- '\\' )
		)*;
		
		# Initialize and execute.
		write init;
		write exec;
	}%%
	*out = 0;
	
	return 0;
}

%%{
	machine json;
	write data;
}%%

int json_parse( json_driver_t *d, char * str )
{
	char *p = str, *pe = str + strlen( str ), *eof = pe;
	int cs;
	int stack[32], top = 0;
	int integer_sign;	// for integer decode
	char * float_start;
	json_driver_value_t v;
	uint32_t b64;
	int b64_cnt;
	
	%%{
		machine json;
		action obj_field_list_start { d->open_object(d); }
		action obj_field_list_done { d->close_object(d); }
		action obj_value_list_start { d->open_array(d); }
		action obj_value_list_done { d->close_array(d); }
		action obj_create_name { d->set_name(d, &v); }
		action obj_set_flag { if (d->add_flag) d->add_flag(d, &v); }
		action obj_set_string { d->set_value(d, json_driver_type_string, &v); }
		action obj_set_integer { d->set_value(d, json_driver_type_integer, &v); }
		action obj_set_float { d->set_value(d, json_driver_type_float, &v); }
		action obj_set_hex { d->set_value(d, json_driver_type_hex, &v); }
		action obj_set_true { v.u.v_bool = 1; d->set_value(d,
json_driver_type_bool, &v); }
		action obj_set_false { v.u.v_bool = 0; d->set_value(d,
json_driver_type_bool, &v); }
		action obj_set_null { d->set_value(d, json_driver_type_null, NULL); }
		
		action obj_start_data { if (d->open_data) d->open_data(d); }
		action obj_flush_data { if (d->add_data) for (int s=16,i = 0;
i<b64_cnt; i++,s-=8) d->add_data(d, (b64 >> s) & 0xff); }
		action obj_end_data { if (d->close_data) d->close_data(d); }
		
		W = [ \t\n]**;

		#
		# quoted or unquoted string
		#
		action str_init { v.u.v_str.start = v.u.v_str.end = fpc; }
		action str_done { v.u.v_str.end = fpc; }
			
		string = '"' ((([^"] | '\"')*) >str_init %str_done)  '"';
		ident = ((alpha | '_') (alnum | '_')*) >str_init %str_done;
		
		#
		#	negative/positive Integer
		#
		action integer_init { v.u.v_int = 0; integer_sign = 1; }
		action integer_minus { integer_sign = -1; }
		action integer_digit { v.u.v_int = (v.u.v_int * 10) + (fc - '0'); }
		action integer_done {  v.u.v_int *= integer_sign; }
		
		integer = (('-' @integer_minus | '+')? (digit+ @integer_digit))
			>integer_init %integer_done;
		
		#
		# hex integer
		#
		xxdigit = (
			([0-9] @{ v.u.v_int = (v.u.v_int << 4) | fc - '0'; }) |
			([a-f] @{ v.u.v_int = (v.u.v_int << 4) | fc - 'a' + 0xa; }) |
			([A-F] @{ v.u.v_int = (v.u.v_int << 4) | fc - 'A' + 0xa; })			
		);
		hex = (('-' @integer_minus | '+')?( '0x' xxdigit+))
			>integer_init %integer_done;
		
		#
		# float/double value
		#
		action float_init { float_start = fpc; }
		action float_done { sscanf(float_start, "%lf", &v.u.v_float); }
		#
		# float values
		#
		float = (
			('-' | '+')? digit* '.' digit+ [fd]?
		) >float_init %float_done;

		#
		# base64 decoder
		#
		base64_char = (
			([A-Z] @{ b64 = (b64 << 6) | (fc - 'A'); }) |
			([a-z] @{ b64 = (b64 << 6) | (fc - 'a' + 26 ); }) |
			([0-9] @{ b64 = (b64 << 6) | (fc - '0' + 52 ); }) |
			('+' @{ b64 = (b64 << 6) | 62; }) |
			('/' @{ b64 = (b64 << 6) | 63; })
		);
		base64_pad = '=' @{ b64 = (b64 << 6); };
		base64_four = (
			base64_char base64_char base64_char base64_char
		) %{ b64_cnt = 3; } %obj_flush_data;
		base64_padder = (
			base64_char base64_char
			(
				(( base64_char base64_pad )
					%{ b64_cnt = 2; } ) |
				(( base64_pad base64_pad )
					%{ b64_cnt = 1; } )
			)
		) %obj_flush_data;

		base64 = ( base64_four** (base64_four | base64_padder) ) >{b64 = 0;}
				%err{ printf("### base64 Error : '%s'\n", p); };

		#
		# JSON value, extended
		#
		json_value = (
			(string %obj_set_string) |
			(integer %obj_set_integer) |
			(hex %obj_set_hex ) |
			(float %obj_set_float) |
			('true' %obj_set_true) |
			('false' %obj_set_false) |
			('null' %obj_set_null) |
			('{' @{ fhold; fcall obj_field_list; } ) |
			('[' @{ fhold; fcall json_value_list; } ) |
			(('%' (W base64)* W '%') >obj_start_data %obj_end_data)
		);
		
		json_value_list := (
			'[' (
				'' |
				(W json_value (W ',' W json_value)* )
			) W ','? W ']'
		) >obj_value_list_start @obj_value_list_done @{ fret; }
				%err{ printf("### Array[%d] Error : '%s'\n", top, p); };
		
		obj_field_flag = ( ident ) %obj_set_flag;
		obj_field_flags = (
			'(' W obj_field_flag (W ',' W obj_field_flag)** ')'
		);
		obj_field = ((string | ident) %obj_create_name) W obj_field_flags? W
':' W json_value;
		
		obj_field_list := (
			'{' (
				'' |
				(W obj_field (W ',' W obj_field)** )
			) W ','? W '}'
		) >obj_field_list_start @obj_field_list_done @{ fret; }
				%err{ printf("### Object[%d] Error : '%s'\n", top, p); };
		
		main := (
			W json_value
		) %err{ printf("### JSON Error : '%s'\n", p); };

		# Initialize and execute.
		write init;
		write exec;
	}%%

	return 0;
};

#ifdef JSON_TEST_UNIT
static void d_set_name(struct json_driver_t *d,
		json_driver_value_t * v)
{
	int l = v->u.v_str.end - v->u.v_str.start;
	printf("\"%*.*s\": ", l, l, v->u.v_str.start);
}

static void d_open_array(struct json_driver_t *d)
{
	printf("[");fflush(stdout);
}

static void d_open_object(struct json_driver_t *d)
{
	printf("{");fflush(stdout);
}

static void d_set_value(struct json_driver_t *d,
		int type,
		json_driver_value_t * v)
{
	switch (type) {
		case json_driver_type_null:
			printf("null, ");
			break;
		case json_driver_type_bool:
			printf("%s, ", v->u.v_bool ? "true" : "false");
			break;
		case json_driver_type_integer:
			printf("%d, ", (int)v->u.v_int);
			break;
		case json_driver_type_hex:
			printf("0x%x, ", (int)v->u.v_int);
			break;
		case json_driver_type_float:
			printf("%f, ", (float)v->u.v_float);
			break;
		case json_driver_type_string: {
			char buf[256];
			json_parse_string(v->u.v_str.start, v->u.v_str.end, buf);
			printf("\"%s\": ", buf);
		}	break;
	}
	fflush(stdout);
}

static void d_close_array(struct json_driver_t *d)
{
	printf("],");fflush(stdout);
}

static void d_close_object(struct json_driver_t *d)
{
	printf("},");fflush(stdout);
}

static void d_open_data(struct json_driver_t *d)
{
	printf("%% '");fflush(stdout);	
}
static void d_add_data(struct json_driver_t *d, uint8_t data)
{
	printf("%c",data);fflush(stdout);
}
static void d_close_data(struct json_driver_t *d)
{
	printf("' %%,");fflush(stdout);
}

json_driver_t driver = {
	.set_name = d_set_name,
	.open_array = d_open_array,
	.open_object = d_open_object,
	.set_value = d_set_value,
	.close_array = d_close_array,
	.close_object = d_close_object,
	
	.open_data = d_open_data,
	.add_data = d_add_data,
	.close_data = d_close_data,
};

int main(int argc, char * argv[])
{

	for (int i = 1; i < argc; i++) {
		printf("### parsing '%s'\n", argv[i]);
		json_parse(&driver, argv[i]);printf("\n");
	}
	return 0;
}

#endif

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From buserror at gmail.com  Thu Sep  2 17:14:02 2010
From: buserror at gmail.com (M P)
Date: Thu, 2 Sep 2010 18:14:02 +0100
Subject: [ragel-users] parser getting gigantic ?
In-Reply-To: <AANLkTin3+rrwwKt-i4vXChzg1ELmn7sB8gespN-DPHHx@mail.gmail.com>
References: <AANLkTin3+rrwwKt-i4vXChzg1ELmn7sB8gespN-DPHHx@mail.gmail.com>
Message-ID: <AANLkTimCsQ4KhrQ9zbW9N09KP+HQnxaSY2CiPpBsK9r-@mail.gmail.com>

I found one problem already,
>                string = '"' ((([^"] | '\"')*) >str_init %str_done)  '"';
Needs a '**'. That reduces the size considerably...

It's still >100KB tho. I've been digging a bit, and there are a LOT of
instances of that "W" rule that gets inlined, even tho the output (and
the value) is just discarded.

I attempted to factor that a bit by doing :
eatme := space** @{ fret; }
W = '' @{ fcall eatme; }

But that didn't work... I wish we could mark a rule as "discard,
factor" or something...

Michael

On Thu, Sep 2, 2010 at 3:41 PM, M P <buserror at gmail.com> wrote:
> I decided to play with Ragel by making a parser for an extended
> version of JSON.
>
> After falling into every single pitfall possible, I managed to get the
> whole thing working pretty well, but I just had a look at the
> generated code and it reached 600KB total, using -G1 (!)
>
> So, what am I doing wrong ? I'm certain there's probably a lot of
> stuff wrong with the way I made the parser, but really, I'm not sure
> what so having experts eyeballing this would be very nice...
>
> There are 2 different json parsers in the file; one is for the string
> constants, one (the main one) is for the language proper...
>
>
> /*
>  * IF YOU ARE LOOKING AT A .c FILE, YOUR ARE LOOKING AT THE WRONG ONE
>  *
>  * This file is autogenerated from a .rl source file for 'ragel'
> parser generator.
>  */
> #include <stdlib.h>
> #include <string.h>
> #include <stdio.h>
>
> #include "json.h"
>
> %%{
>        machine json_str;
>        write data;
> }%%
>
> static char * json_append_utf8_glyph(
>        char * dst,
>        unsigned long inUnicode )
> {
>        if (!(inUnicode & ~0x7f)) {
>                *dst++ = ((char)inUnicode);
>                return dst;     // that was easy
>        }
>        unsigned char *cur = dst;
>
>        unsigned long currentMask = ~0x7ff;
>        int bits = 6;
>        int header = 5;
>
>        while ((inUnicode & currentMask) && bits <= 24) {
>                currentMask = currentMask << 6;
>                bits += 6; header--;
>        }
>        *cur++ = (0xfe << header) | (unsigned char)(inUnicode >> (bits));
>        bits -= 6;
>        while (bits >= 0) {
>                *cur++ = 0x80 | ((unsigned char)(inUnicode >> bits) & 0x3f);
>                bits -= 6;
>        }
>        return cur;
> }
>
> int json_parse_string(char * str, char *end, char * out)
> {
>        char *p = str, *pe = end ? end : str + strlen( str ), *eof = pe;
>        int cs;
>        out = out ? out : str;
>        uint16_t u;
>        %%{
>                machine json_str;
>
>                xxdigit = (
>                        ([0-9] @{ u = (u << 4) | fc - '0'; }) |
>                        ([a-f] @{ u = (u << 4) | fc - 'a' + 0xa; }) |
>                        ([A-F] @{ u = (u << 4) | fc - 'A' + 0xa; })
>                );
>                utf16 = ( xxdigit{4} ) >{ u = 0; } @{ out = json_append_utf8_glyph(out, u); };
>
>                normal = any @{*out++ = fc;};
>                escape =
>                                ('\\' %{ *out++ = '\\'; } ) |
>                                ('t' %{ *out++ = '\t'; } )  |
>                                ('b' %{ *out++ = '\b'; } )  |
>                                ('f' %{ *out++ = '\f'; } )  |
>                                ('n' %{ *out++ = '\n'; } )  |
>                                ('r' %{ *out++ = '\r'; } )  |
>                                ('u' utf16 ) |
>                                ( normal -- [\\tbfntu] )
>                        ;
>                main := (
>                        ('\\' escape) |
>                        ( normal -- '\\' )
>                )*;
>
>                # Initialize and execute.
>                write init;
>                write exec;
>        }%%
>        *out = 0;
>
>        return 0;
> }
>
> %%{
>        machine json;
>        write data;
> }%%
>
> int json_parse( json_driver_t *d, char * str )
> {
>        char *p = str, *pe = str + strlen( str ), *eof = pe;
>        int cs;
>        int stack[32], top = 0;
>        int integer_sign;       // for integer decode
>        char * float_start;
>        json_driver_value_t v;
>        uint32_t b64;
>        int b64_cnt;
>
>        %%{
>                machine json;
>                action obj_field_list_start { d->open_object(d); }
>                action obj_field_list_done { d->close_object(d); }
>                action obj_value_list_start { d->open_array(d); }
>                action obj_value_list_done { d->close_array(d); }
>                action obj_create_name { d->set_name(d, &v); }
>                action obj_set_flag { if (d->add_flag) d->add_flag(d, &v); }
>                action obj_set_string { d->set_value(d, json_driver_type_string, &v); }
>                action obj_set_integer { d->set_value(d, json_driver_type_integer, &v); }
>                action obj_set_float { d->set_value(d, json_driver_type_float, &v); }
>                action obj_set_hex { d->set_value(d, json_driver_type_hex, &v); }
>                action obj_set_true { v.u.v_bool = 1; d->set_value(d,
> json_driver_type_bool, &v); }
>                action obj_set_false { v.u.v_bool = 0; d->set_value(d,
> json_driver_type_bool, &v); }
>                action obj_set_null { d->set_value(d, json_driver_type_null, NULL); }
>
>                action obj_start_data { if (d->open_data) d->open_data(d); }
>                action obj_flush_data { if (d->add_data) for (int s=16,i = 0;
> i<b64_cnt; i++,s-=8) d->add_data(d, (b64 >> s) & 0xff); }
>                action obj_end_data { if (d->close_data) d->close_data(d); }
>
>                W = [ \t\n]**;
>
>                #
>                # quoted or unquoted string
>                #
>                action str_init { v.u.v_str.start = v.u.v_str.end = fpc; }
>                action str_done { v.u.v_str.end = fpc; }
>
>                string = '"' ((([^"] | '\"')*) >str_init %str_done)  '"';
>                ident = ((alpha | '_') (alnum | '_')*) >str_init %str_done;
>
>                #
>                #       negative/positive Integer
>                #
>                action integer_init { v.u.v_int = 0; integer_sign = 1; }
>                action integer_minus { integer_sign = -1; }
>                action integer_digit { v.u.v_int = (v.u.v_int * 10) + (fc - '0'); }
>                action integer_done {  v.u.v_int *= integer_sign; }
>
>                integer = (('-' @integer_minus | '+')? (digit+ @integer_digit))
>                        >integer_init %integer_done;
>
>                #
>                # hex integer
>                #
>                xxdigit = (
>                        ([0-9] @{ v.u.v_int = (v.u.v_int << 4) | fc - '0'; }) |
>                        ([a-f] @{ v.u.v_int = (v.u.v_int << 4) | fc - 'a' + 0xa; }) |
>                        ([A-F] @{ v.u.v_int = (v.u.v_int << 4) | fc - 'A' + 0xa; })
>                );
>                hex = (('-' @integer_minus | '+')?( '0x' xxdigit+))
>                        >integer_init %integer_done;
>
>                #
>                # float/double value
>                #
>                action float_init { float_start = fpc; }
>                action float_done { sscanf(float_start, "%lf", &v.u.v_float); }
>                #
>                # float values
>                #
>                float = (
>                        ('-' | '+')? digit* '.' digit+ [fd]?
>                ) >float_init %float_done;
>
>                #
>                # base64 decoder
>                #
>                base64_char = (
>                        ([A-Z] @{ b64 = (b64 << 6) | (fc - 'A'); }) |
>                        ([a-z] @{ b64 = (b64 << 6) | (fc - 'a' + 26 ); }) |
>                        ([0-9] @{ b64 = (b64 << 6) | (fc - '0' + 52 ); }) |
>                        ('+' @{ b64 = (b64 << 6) | 62; }) |
>                        ('/' @{ b64 = (b64 << 6) | 63; })
>                );
>                base64_pad = '=' @{ b64 = (b64 << 6); };
>                base64_four = (
>                        base64_char base64_char base64_char base64_char
>                ) %{ b64_cnt = 3; } %obj_flush_data;
>                base64_padder = (
>                        base64_char base64_char
>                        (
>                                (( base64_char base64_pad )
>                                        %{ b64_cnt = 2; } ) |
>                                (( base64_pad base64_pad )
>                                        %{ b64_cnt = 1; } )
>                        )
>                ) %obj_flush_data;
>
>                base64 = ( base64_four** (base64_four | base64_padder) ) >{b64 = 0;}
>                                %err{ printf("### base64 Error : '%s'\n", p); };
>
>                #
>                # JSON value, extended
>                #
>                json_value = (
>                        (string %obj_set_string) |
>                        (integer %obj_set_integer) |
>                        (hex %obj_set_hex ) |
>                        (float %obj_set_float) |
>                        ('true' %obj_set_true) |
>                        ('false' %obj_set_false) |
>                        ('null' %obj_set_null) |
>                        ('{' @{ fhold; fcall obj_field_list; } ) |
>                        ('[' @{ fhold; fcall json_value_list; } ) |
>                        (('%' (W base64)* W '%') >obj_start_data %obj_end_data)
>                );
>
>                json_value_list := (
>                        '[' (
>                                '' |
>                                (W json_value (W ',' W json_value)* )
>                        ) W ','? W ']'
>                ) >obj_value_list_start @obj_value_list_done @{ fret; }
>                                %err{ printf("### Array[%d] Error : '%s'\n", top, p); };
>
>                obj_field_flag = ( ident ) %obj_set_flag;
>                obj_field_flags = (
>                        '(' W obj_field_flag (W ',' W obj_field_flag)** ')'
>                );
>                obj_field = ((string | ident) %obj_create_name) W obj_field_flags? W
> ':' W json_value;
>
>                obj_field_list := (
>                        '{' (
>                                '' |
>                                (W obj_field (W ',' W obj_field)** )
>                        ) W ','? W '}'
>                ) >obj_field_list_start @obj_field_list_done @{ fret; }
>                                %err{ printf("### Object[%d] Error : '%s'\n", top, p); };
>
>                main := (
>                        W json_value
>                ) %err{ printf("### JSON Error : '%s'\n", p); };
>
>                # Initialize and execute.
>                write init;
>                write exec;
>        }%%
>
>        return 0;
> };
>
> #ifdef JSON_TEST_UNIT
> static void d_set_name(struct json_driver_t *d,
>                json_driver_value_t * v)
> {
>        int l = v->u.v_str.end - v->u.v_str.start;
>        printf("\"%*.*s\": ", l, l, v->u.v_str.start);
> }
>
> static void d_open_array(struct json_driver_t *d)
> {
>        printf("[");fflush(stdout);
> }
>
> static void d_open_object(struct json_driver_t *d)
> {
>        printf("{");fflush(stdout);
> }
>
> static void d_set_value(struct json_driver_t *d,
>                int type,
>                json_driver_value_t * v)
> {
>        switch (type) {
>                case json_driver_type_null:
>                        printf("null, ");
>                        break;
>                case json_driver_type_bool:
>                        printf("%s, ", v->u.v_bool ? "true" : "false");
>                        break;
>                case json_driver_type_integer:
>                        printf("%d, ", (int)v->u.v_int);
>                        break;
>                case json_driver_type_hex:
>                        printf("0x%x, ", (int)v->u.v_int);
>                        break;
>                case json_driver_type_float:
>                        printf("%f, ", (float)v->u.v_float);
>                        break;
>                case json_driver_type_string: {
>                        char buf[256];
>                        json_parse_string(v->u.v_str.start, v->u.v_str.end, buf);
>                        printf("\"%s\": ", buf);
>                }       break;
>        }
>        fflush(stdout);
> }
>
> static void d_close_array(struct json_driver_t *d)
> {
>        printf("],");fflush(stdout);
> }
>
> static void d_close_object(struct json_driver_t *d)
> {
>        printf("},");fflush(stdout);
> }
>
> static void d_open_data(struct json_driver_t *d)
> {
>        printf("%% '");fflush(stdout);
> }
> static void d_add_data(struct json_driver_t *d, uint8_t data)
> {
>        printf("%c",data);fflush(stdout);
> }
> static void d_close_data(struct json_driver_t *d)
> {
>        printf("' %%,");fflush(stdout);
> }
>
> json_driver_t driver = {
>        .set_name = d_set_name,
>        .open_array = d_open_array,
>        .open_object = d_open_object,
>        .set_value = d_set_value,
>        .close_array = d_close_array,
>        .close_object = d_close_object,
>
>        .open_data = d_open_data,
>        .add_data = d_add_data,
>        .close_data = d_close_data,
> };
>
> int main(int argc, char * argv[])
> {
>
>        for (int i = 1; i < argc; i++) {
>                printf("### parsing '%s'\n", argv[i]);
>                json_parse(&driver, argv[i]);printf("\n");
>        }
>        return 0;
> }
>
> #endif
>

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From twisolar at gmail.com  Wed Sep 29 03:30:40 2010
From: twisolar at gmail.com (Jonathan Castello)
Date: Tue, 28 Sep 2010 20:30:40 -0700
Subject: [ragel-users] Writing a Telnet parser
Message-ID: <AANLkTi=VsNUCYx4sgVsB5VjKw5jSW74sQxSzCeNb9Pz1@mail.gmail.com>

Hello,

I'm building a Telnet parser using Ragel, and I'm having an issue
making the actions do what I want. I've pasted the machine definition
to a gist: http://gist.github.com/602242

The issue is a little hard for me to describe, so I'll try to
illustrate it as best as I can. If I have a stream of input, and some
part of it is "abcdef<IAC><GA>ghi" (where <x> is a mnemonic for a
single byte), I want to emit events as such: text("abcdef"),
command("<GA>"), text("ghi"). The caller provides callbacks, and I
would pass the data to them as I interpret it.

The problem is that I can't figure out how to define actions that
would only trigger when the next character doesn't match plain_text
(or there's no more data left to parse in that particular packet), so
I can get that full stretch of characters. At the moment, I can only
get text("a"), text("b"), text("c") etc. to work, i.e. one plain_text
match at a time.

I suspect the problem is that cr_sequence and iac_sequence are
supposed to behave this way - they, too, match singular "terms" each
time before returning to the start - but here I am, wanting to give
plain_text special treatment. Am I even coming at this from the right
angle?

Thanks in advance for any advice!
~Jonathan Castello

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From adrian.thurston at esentire.com  Wed Sep 29 17:07:07 2010
From: adrian.thurston at esentire.com (Adrian Thurston)
Date: Wed, 29 Sep 2010 10:07:07 -0700
Subject: [ragel-users] Writing a Telnet parser
In-Reply-To: <AANLkTi=VsNUCYx4sgVsB5VjKw5jSW74sQxSzCeNb9Pz1@mail.gmail.com>
References: <AANLkTi=VsNUCYx4sgVsB5VjKw5jSW74sQxSzCeNb9Pz1@mail.gmail.com>
Message-ID: <4CA3723B.5060000@esentire.com>

Hi Jonathan,

Ragel does not do any buffering of text for you. It's up to you to 
decide how you want to do that, then implement it yourself. There are a 
couple options. You can copy text to a buffer as you move over 
characters, or you can extract them from the input buffer when you need 
them. The first approach is simpler and guaranteed to work without 
hitches. The second technique is faster, but you have to consider buffer 
block boundaries.

-Adrian

On 10-09-28 08:30 PM, Jonathan Castello wrote:
> Hello,
>
> I'm building a Telnet parser using Ragel, and I'm having an issue
> making the actions do what I want. I've pasted the machine definition
> to a gist: http://gist.github.com/602242
>
> The issue is a little hard for me to describe, so I'll try to
> illustrate it as best as I can. If I have a stream of input, and some
> part of it is "abcdef<IAC><GA>ghi" (where<x>  is a mnemonic for a
> single byte), I want to emit events as such: text("abcdef"),
> command("<GA>"), text("ghi"). The caller provides callbacks, and I
> would pass the data to them as I interpret it.
>
> The problem is that I can't figure out how to define actions that
> would only trigger when the next character doesn't match plain_text
> (or there's no more data left to parse in that particular packet), so
> I can get that full stretch of characters. At the moment, I can only
> get text("a"), text("b"), text("c") etc. to work, i.e. one plain_text
> match at a time.
>
> I suspect the problem is that cr_sequence and iac_sequence are
> supposed to behave this way - they, too, match singular "terms" each
> time before returning to the start - but here I am, wanting to give
> plain_text special treatment. Am I even coming at this from the right
> angle?
>
> Thanks in advance for any advice!
> ~Jonathan Castello
>
> _______________________________________________
> ragel-users mailing list
> ragel-users at complang.org
> http://www.complang.org/mailman/listinfo/ragel-users
>

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From twisolar at gmail.com  Wed Sep 29 17:34:53 2010
From: twisolar at gmail.com (Jonathan Castello)
Date: Wed, 29 Sep 2010 10:34:53 -0700
Subject: [ragel-users] Writing a Telnet parser
In-Reply-To: <4CA3723B.5060000@esentire.com>
References: <AANLkTi=VsNUCYx4sgVsB5VjKw5jSW74sQxSzCeNb9Pz1@mail.gmail.com>
	<4CA3723B.5060000@esentire.com>
Message-ID: <AANLkTikZe6jTT4tV4ZLicJyTpWmhQb5aXaEXjL3bfAp-@mail.gmail.com>

Hi Adrian,

Thanks for your help. Actually, I know how I want to buffer them; the
problem is actually extracting them when I want to. I need some way to
extract the characters only when the next character isn't plain_text
or there is no next character. I've tried adding an entry action to
cr_sequence and iac_sequence, but that doesn't work when you reach the
end of the subject data without seeing a CR or IAC. What I was hoping
to do is maintain a 'left' pointer to the first plain_text character,
and use fpc as the 'right' pointer when I reach the last contiguous
plain_text character. Then I would pass the left pointer and the
length of that contiguous stretch (fpc-left) to the user-provided
callback.

I could copy each character to a temporary buffer, but I was hoping to
avoid extra allocations. I want to just pass pointers into the
original block of text being parsed, so the calling code can do any
copying and allocating required. My entry action attempt was the
closest I could get: it would properly fire before a non plain_text
sequence, but the major issue is that it wouldn't fire at all when it
reached the end of the subject line.

Thanks again,
~Jonathan

On Wed, Sep 29, 2010 at 10:07 AM, Adrian Thurston
<adrian.thurston at esentire.com> wrote:
> Hi Jonathan,
>
> Ragel does not do any buffering of text for you. It's up to you to decide
> how you want to do that, then implement it yourself. There are a couple
> options. You can copy text to a buffer as you move over characters, or you
> can extract them from the input buffer when you need them. The first
> approach is simpler and guaranteed to work without hitches. The second
> technique is faster, but you have to consider buffer block boundaries.
>
> -Adrian
>
> On 10-09-28 08:30 PM, Jonathan Castello wrote:
>>
>> Hello,
>>
>> I'm building a Telnet parser using Ragel, and I'm having an issue
>> making the actions do what I want. I've pasted the machine definition
>> to a gist: http://gist.github.com/602242
>>
>> The issue is a little hard for me to describe, so I'll try to
>> illustrate it as best as I can. If I have a stream of input, and some
>> part of it is "abcdef<IAC><GA>ghi" (where<x>  is a mnemonic for a
>> single byte), I want to emit events as such: text("abcdef"),
>> command("<GA>"), text("ghi"). The caller provides callbacks, and I
>> would pass the data to them as I interpret it.
>>
>> The problem is that I can't figure out how to define actions that
>> would only trigger when the next character doesn't match plain_text
>> (or there's no more data left to parse in that particular packet), so
>> I can get that full stretch of characters. At the moment, I can only
>> get text("a"), text("b"), text("c") etc. to work, i.e. one plain_text
>> match at a time.
>>
>> I suspect the problem is that cr_sequence and iac_sequence are
>> supposed to behave this way - they, too, match singular "terms" each
>> time before returning to the start - but here I am, wanting to give
>> plain_text special treatment. Am I even coming at this from the right
>> angle?
>>
>> Thanks in advance for any advice!
>> ~Jonathan Castello
>>
>> _______________________________________________
>> ragel-users mailing list
>> ragel-users at complang.org
>> http://www.complang.org/mailman/listinfo/ragel-users
>>
>
> _______________________________________________
> ragel-users mailing list
> ragel-users at complang.org
> http://www.complang.org/mailman/listinfo/ragel-users
>

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From adrian.thurston at esentire.com  Wed Sep 29 17:43:10 2010
From: adrian.thurston at esentire.com (Adrian Thurston)
Date: Wed, 29 Sep 2010 10:43:10 -0700
Subject: [ragel-users] Writing a Telnet parser
In-Reply-To: <AANLkTikZe6jTT4tV4ZLicJyTpWmhQb5aXaEXjL3bfAp-@mail.gmail.com>
References: <AANLkTi=VsNUCYx4sgVsB5VjKw5jSW74sQxSzCeNb9Pz1@mail.gmail.com>	<4CA3723B.5060000@esentire.com>
	<AANLkTikZe6jTT4tV4ZLicJyTpWmhQb5aXaEXjL3bfAp-@mail.gmail.com>
Message-ID: <4CA37AAE.4040706@esentire.com>

Have you tried leaving actions? It sounds like that is what you want.

-Adrian

On 10-09-29 10:34 AM, Jonathan Castello wrote:
> Hi Adrian,
>
> Thanks for your help. Actually, I know how I want to buffer them; the
> problem is actually extracting them when I want to. I need some way to
> extract the characters only when the next character isn't plain_text
> or there is no next character. I've tried adding an entry action to
> cr_sequence and iac_sequence, but that doesn't work when you reach the
> end of the subject data without seeing a CR or IAC. What I was hoping
> to do is maintain a 'left' pointer to the first plain_text character,
> and use fpc as the 'right' pointer when I reach the last contiguous
> plain_text character. Then I would pass the left pointer and the
> length of that contiguous stretch (fpc-left) to the user-provided
> callback.
>
> I could copy each character to a temporary buffer, but I was hoping to
> avoid extra allocations. I want to just pass pointers into the
> original block of text being parsed, so the calling code can do any
> copying and allocating required. My entry action attempt was the
> closest I could get: it would properly fire before a non plain_text
> sequence, but the major issue is that it wouldn't fire at all when it
> reached the end of the subject line.
>
> Thanks again,
> ~Jonathan
>
> On Wed, Sep 29, 2010 at 10:07 AM, Adrian Thurston
> <adrian.thurston at esentire.com>  wrote:
>> Hi Jonathan,
>>
>> Ragel does not do any buffering of text for you. It's up to you to decide
>> how you want to do that, then implement it yourself. There are a couple
>> options. You can copy text to a buffer as you move over characters, or you
>> can extract them from the input buffer when you need them. The first
>> approach is simpler and guaranteed to work without hitches. The second
>> technique is faster, but you have to consider buffer block boundaries.
>>
>> -Adrian
>>
>> On 10-09-28 08:30 PM, Jonathan Castello wrote:
>>>
>>> Hello,
>>>
>>> I'm building a Telnet parser using Ragel, and I'm having an issue
>>> making the actions do what I want. I've pasted the machine definition
>>> to a gist: http://gist.github.com/602242
>>>
>>> The issue is a little hard for me to describe, so I'll try to
>>> illustrate it as best as I can. If I have a stream of input, and some
>>> part of it is "abcdef<IAC><GA>ghi" (where<x>    is a mnemonic for a
>>> single byte), I want to emit events as such: text("abcdef"),
>>> command("<GA>"), text("ghi"). The caller provides callbacks, and I
>>> would pass the data to them as I interpret it.
>>>
>>> The problem is that I can't figure out how to define actions that
>>> would only trigger when the next character doesn't match plain_text
>>> (or there's no more data left to parse in that particular packet), so
>>> I can get that full stretch of characters. At the moment, I can only
>>> get text("a"), text("b"), text("c") etc. to work, i.e. one plain_text
>>> match at a time.
>>>
>>> I suspect the problem is that cr_sequence and iac_sequence are
>>> supposed to behave this way - they, too, match singular "terms" each
>>> time before returning to the start - but here I am, wanting to give
>>> plain_text special treatment. Am I even coming at this from the right
>>> angle?
>>>
>>> Thanks in advance for any advice!
>>> ~Jonathan Castello
>>>
>>> _______________________________________________
>>> ragel-users mailing list
>>> ragel-users at complang.org
>>> http://www.complang.org/mailman/listinfo/ragel-users
>>>
>>
>> _______________________________________________
>> ragel-users mailing list
>> ragel-users at complang.org
>> http://www.complang.org/mailman/listinfo/ragel-users
>>
>
> _______________________________________________
> ragel-users mailing list
> ragel-users at complang.org
> http://www.complang.org/mailman/listinfo/ragel-users
>

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From buserror at gmail.com  Wed Sep 29 18:19:11 2010
From: buserror at gmail.com (M P)
Date: Wed, 29 Sep 2010 19:19:11 +0100
Subject: [ragel-users] ANN: libejson, extended JSON parser library
Message-ID: <AANLkTi=v3A8PPBPHO=dkftGd3gdqOMkS+QH+T49=TEao@mail.gmail.com>

I open-sourced a ragel-based parser for an extended version of JSON (I
had posted a problematic version some weeks ago)

http://bliterness.blogspot.com/2010/09/new-libejson-json-parser-on-steroids.html

Michael

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From adrian.thurston at esentire.com  Wed Sep 29 18:21:49 2010
From: adrian.thurston at esentire.com (Adrian Thurston)
Date: Wed, 29 Sep 2010 11:21:49 -0700
Subject: [ragel-users] ANN: libejson, extended JSON parser library
In-Reply-To: <AANLkTi=v3A8PPBPHO=dkftGd3gdqOMkS+QH+T49=TEao@mail.gmail.com>
References: <AANLkTi=v3A8PPBPHO=dkftGd3gdqOMkS+QH+T49=TEao@mail.gmail.com>
Message-ID: <4CA383BD.9070907@esentire.com>

Thanks!

I'm very sorry I never responded to your messages. Did you get all the 
issues worked out?

-Adrian

On 10-09-29 11:19 AM, M P wrote:
> I open-sourced a ragel-based parser for an extended version of JSON (I
> had posted a problematic version some weeks ago)
>
> http://bliterness.blogspot.com/2010/09/new-libejson-json-parser-on-steroids.html
>
> Michael
>
> _______________________________________________
> ragel-users mailing list
> ragel-users at complang.org
> http://www.complang.org/mailman/listinfo/ragel-users
>

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From buserror at gmail.com  Wed Sep 29 18:31:49 2010
From: buserror at gmail.com (M P)
Date: Wed, 29 Sep 2010 19:31:49 +0100
Subject: [ragel-users] ANN: libejson, extended JSON parser library
In-Reply-To: <4CA383BD.9070907@esentire.com>
References: <AANLkTi=v3A8PPBPHO=dkftGd3gdqOMkS+QH+T49=TEao@mail.gmail.com>
	<4CA383BD.9070907@esentire.com>
Message-ID: <AANLkTikZE2Xb5PpJbCFn6qyd=8sy_7XNwc+5yzehGhQ+@mail.gmail.com>

Only partially -- I managed to get the whole parser working, BAR the
comments... I had tried to embed the comment 'detection' into the
"whitespace" rule ("W"), but I never managed to get it to work, so I
yanked the comment bit for now..

I think there's probably a need in ragel to specify a "skip" rule
flag, to prevent the parser getting gigantic with "instances" of these
empty rules... I tried to do an fcall/fret but didn't get that to work
either...

Right now the parser is about 50kb expanded, and thats as low as I
managed it to get, I think that given the relative complexity of it,
it's probably OK...

If you want to have a quick review and/or submit patches, I would be
very grateful !

Michael


On Wed, Sep 29, 2010 at 7:21 PM, Adrian Thurston
<adrian.thurston at esentire.com> wrote:
> Thanks!
>
> I'm very sorry I never responded to your messages. Did you get all the
> issues worked out?
>
> -Adrian
>
> On 10-09-29 11:19 AM, M P wrote:
>>
>> I open-sourced a ragel-based parser for an extended version of JSON (I
>> had posted a problematic version some weeks ago)
>>
>>
>> http://bliterness.blogspot.com/2010/09/new-libejson-json-parser-on-steroids.html
>>
>> Michael
>>
>> _______________________________________________
>> ragel-users mailing list
>> ragel-users at complang.org
>> http://www.complang.org/mailman/listinfo/ragel-users
>>
>
> _______________________________________________
> ragel-users mailing list
> ragel-users at complang.org
> http://www.complang.org/mailman/listinfo/ragel-users
>

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


From twisolar at gmail.com  Thu Sep 30 00:39:04 2010
From: twisolar at gmail.com (Jonathan Castello)
Date: Wed, 29 Sep 2010 17:39:04 -0700
Subject: [ragel-users] Writing a Telnet parser
In-Reply-To: <4CA37AAE.4040706@esentire.com>
References: <AANLkTi=VsNUCYx4sgVsB5VjKw5jSW74sQxSzCeNb9Pz1@mail.gmail.com>
	<4CA3723B.5060000@esentire.com>
	<AANLkTikZe6jTT4tV4ZLicJyTpWmhQb5aXaEXjL3bfAp-@mail.gmail.com>
	<4CA37AAE.4040706@esentire.com>
Message-ID: <AANLkTi=xGnS+S9agqdTXTy76rS3jBdkMPnpWMHGz22KF@mail.gmail.com>

I have, actually. If I have "plain_text %leaving", the leaving action
is still executed after every plain_text character, as the generated
graph seems to indicate. If I put %leaving after the telnet_stream
itself, the graph suggests that it's only executed on EOF, which will
never occur as I am processing a potentially infinite network stream.
(Because of this, I explicitly set eof = NULL in the code before "%%
write init", as the documentation suggests.)

~Jonathan

On Wed, Sep 29, 2010 at 10:43 AM, Adrian Thurston
<adrian.thurston at esentire.com> wrote:
> Have you tried leaving actions? It sounds like that is what you want.
>
> -Adrian
>
> On 10-09-29 10:34 AM, Jonathan Castello wrote:
>>
>> Hi Adrian,
>>
>> Thanks for your help. Actually, I know how I want to buffer them; the
>> problem is actually extracting them when I want to. I need some way to
>> extract the characters only when the next character isn't plain_text
>> or there is no next character. I've tried adding an entry action to
>> cr_sequence and iac_sequence, but that doesn't work when you reach the
>> end of the subject data without seeing a CR or IAC. What I was hoping
>> to do is maintain a 'left' pointer to the first plain_text character,
>> and use fpc as the 'right' pointer when I reach the last contiguous
>> plain_text character. Then I would pass the left pointer and the
>> length of that contiguous stretch (fpc-left) to the user-provided
>> callback.
>>
>> I could copy each character to a temporary buffer, but I was hoping to
>> avoid extra allocations. I want to just pass pointers into the
>> original block of text being parsed, so the calling code can do any
>> copying and allocating required. My entry action attempt was the
>> closest I could get: it would properly fire before a non plain_text
>> sequence, but the major issue is that it wouldn't fire at all when it
>> reached the end of the subject line.
>>
>> Thanks again,
>> ~Jonathan
>>
>> On Wed, Sep 29, 2010 at 10:07 AM, Adrian Thurston
>> <adrian.thurston at esentire.com>  wrote:
>>>
>>> Hi Jonathan,
>>>
>>> Ragel does not do any buffering of text for you. It's up to you to decide
>>> how you want to do that, then implement it yourself. There are a couple
>>> options. You can copy text to a buffer as you move over characters, or
>>> you
>>> can extract them from the input buffer when you need them. The first
>>> approach is simpler and guaranteed to work without hitches. The second
>>> technique is faster, but you have to consider buffer block boundaries.
>>>
>>> -Adrian
>>>
>>> On 10-09-28 08:30 PM, Jonathan Castello wrote:
>>>>
>>>> Hello,
>>>>
>>>> I'm building a Telnet parser using Ragel, and I'm having an issue
>>>> making the actions do what I want. I've pasted the machine definition
>>>> to a gist: http://gist.github.com/602242
>>>>
>>>> The issue is a little hard for me to describe, so I'll try to
>>>> illustrate it as best as I can. If I have a stream of input, and some
>>>> part of it is "abcdef<IAC><GA>ghi" (where<x>    is a mnemonic for a
>>>> single byte), I want to emit events as such: text("abcdef"),
>>>> command("<GA>"), text("ghi"). The caller provides callbacks, and I
>>>> would pass the data to them as I interpret it.
>>>>
>>>> The problem is that I can't figure out how to define actions that
>>>> would only trigger when the next character doesn't match plain_text
>>>> (or there's no more data left to parse in that particular packet), so
>>>> I can get that full stretch of characters. At the moment, I can only
>>>> get text("a"), text("b"), text("c") etc. to work, i.e. one plain_text
>>>> match at a time.
>>>>
>>>> I suspect the problem is that cr_sequence and iac_sequence are
>>>> supposed to behave this way - they, too, match singular "terms" each
>>>> time before returning to the start - but here I am, wanting to give
>>>> plain_text special treatment. Am I even coming at this from the right
>>>> angle?
>>>>
>>>> Thanks in advance for any advice!
>>>> ~Jonathan Castello
>>>>
>>>> _______________________________________________
>>>> ragel-users mailing list
>>>> ragel-users at complang.org
>>>> http://www.complang.org/mailman/listinfo/ragel-users
>>>>
>>>
>>> _______________________________________________
>>> ragel-users mailing list
>>> ragel-users at complang.org
>>> http://www.complang.org/mailman/listinfo/ragel-users
>>>
>>
>> _______________________________________________
>> ragel-users mailing list
>> ragel-users at complang.org
>> http://www.complang.org/mailman/listinfo/ragel-users
>>
>
> _______________________________________________
> ragel-users mailing list
> ragel-users at complang.org
> http://www.complang.org/mailman/listinfo/ragel-users
>

_______________________________________________
ragel-users mailing list
ragel-users at complang.org
http://www.complang.org/mailman/listinfo/ragel-users


